{"meta":{"title":"kaihao","subtitle":"屠龙的少年仍在燃烧","description":null,"author":"Kaihao Li","url":"http://kaihaoli.github.io"},"pages":[{"title":"Kaihao Li","date":"2018-04-10T21:03:53.000Z","updated":"2018-04-16T04:11:45.587Z","comments":true,"path":"about/index.html","permalink":"http://kaihaoli.github.io/about/index.html","excerpt":"","text":"Email: kaihaohust#gmail.com (replace # with @ please) Tel: (+1)631-428-7454 EDUCATION 2017.01 ~ 2018.12: M.S. in Computer Science, Stony Brook University 2011.09 ~ 2015.06: B.S. in Computer Science Engineering, Huazhong University of Science and Technology SKILLS Programming Languages: Python, Java, C. Go, Scala Full Stack:React, Express, Node.js Tools: Tensorflow,"},{"title":"categories","date":"2018-04-10T20:18:48.000Z","updated":"2018-04-10T20:19:56.378Z","comments":true,"path":"categories/index.html","permalink":"http://kaihaoli.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-10T20:22:05.000Z","updated":"2018-04-10T20:22:32.914Z","comments":true,"path":"tags/index.html","permalink":"http://kaihaoli.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Message Queue 消息队列","slug":"message-queue","date":"2018-04-18T22:21:34.000Z","updated":"2018-04-18T22:28:21.883Z","comments":true,"path":"2018/04/18/message-queue/","link":"","permalink":"http://kaihaoli.github.io/2018/04/18/message-queue/","excerpt":"","text":"参考资料: 大型网站架构系列：分布式消息队列 What is Message Queue A message queue is a queue of messages sent between applications. 中间人 Message queues provide an asynchronous communications protocol, meaning that the sender and receiver of the message do not need to interact with the message queue at the same time. An application framework for sending and receiving messages A way to communicate between applications / systems A way to decouple components A way to offload work (handle to another worker) Application Allow web servers to respond to requests quickly instead of being forced to perform resource-heavy procedures. Able to distribute a message to multiple recipients for consumption or for balancing loads between workers. 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。 目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。 Message Queue in Real Life对实时性要求不高的任务！ Image Resizing Video Processing Sending out Emails (Ad Campaigns) Log Analysis … AMPQ协议Message Queue Protocol AMQP - Advanced Message Queue Protocol (RabbitMQ) STOMP - Streaming Text Oriented Messaging Protocol (ActiveMQ) XMPP - Extensible Messaging and Presence Protocol Network wire-level protocol Defines how clients and brokers talk Data serialization, heartbeat AMQP Model Defines routing and storing of messages Defines rules how these are wired together Exported API RabbitMQ RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。Implements AMQP Easy to use, 支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 Open source and commercially supported RabiitMQ Solution Could-based Solution CloudAMQP CloudAMPQ in Python使用教程 Local1brew install rabbitmq # would take long","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Redis","slug":"redis","date":"2018-04-17T23:23:40.000Z","updated":"2018-04-18T22:32:23.103Z","comments":true,"path":"2018/04/17/redis/","link":"","permalink":"http://kaihaoli.github.io/2018/04/17/redis/","excerpt":"","text":"(参考资料:Redis学习教程Gitbook, RUNOOB Redis 教程) What is Redis Redis is an opensource(BSDlicensed), in-memory datas tructure store, used as database, cache and message broker. database只是Redis的一个应用， In-memory data structure store Data Structure Operations Strings - 字符串 SET, GET, APPEND Hashes - 哈希表 HSET, HGET List - 列表 LPUSH, LRANGE, LSET, LTRIM Set - 集合 SADD, SMEMBERS Sorted Set ZADD, ZRANGE, ZRANGEBYSCORE Why Redis Redis 有三个主要的特点, 有别于其它很多竞争对手 ： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以 再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Application (1) Cache Replacement - LRU LFU Pre-load (2) Message Broker MQ (3) Database Redis Install &amp; Config Install Redis with MAC 12345678910# Installbrew install redis# Startbrew services start redis# or redis-server /usr/local/etc/redis.conf# CMD~ % redis-cli127.0.0.1:6379&gt; Try CMD here : Redis Interactive Online Redis in PythonThe Python interface to the Redis key-value store. Install1sudo pip install redis ConnectionOpening a Connection to Redis Using redis-py123456#The following code creates a connection to Redis using redis-py:import redisredis_client = redis.Redis( host = 'hostname', port = port # redis default port 6379) redis提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。 redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。如果需要另一个Redis实例（or Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。同理，python的redis没有实现select命令。 12345# set, getr.set('name', 'junxi') # key是\"foo\" value是\"bar\" 将键值对存入redis缓存print(r['name'])print(r.get('name')) # 取出键name对应的值print(type(r.get('name')))","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Binary Search 二分查找","slug":"binary-search","date":"2018-04-16T03:31:10.000Z","updated":"2018-04-16T04:09:33.357Z","comments":true,"path":"2018/04/15/binary-search/","link":"","permalink":"http://kaihaoli.github.io/2018/04/15/binary-search/","excerpt":"","text":"#Binary Search 二分查找 经典二分查找LintCode 457. \bClassical Binary Search基础应用 输入是单调递增或者单调递减的数组(sorted array) 278. First Bad Version35. Search Insert Position34. Search for a Range74. Search a 2D Matrix旋转数组系列 Input的数组不再是单调递增或者单调递减 162. Find Peak Element153. Find Minimum in Rotated Sorted Array154. Find Minimum in Rotated Sorted Array II33. Search in Rotated Sorted Array81. Search in Rotated Sorted Array II倍增法 Input不再是数组 367. Valid Perfect Square69. Sqrt(x)29. Divide Two Integers综合拔高4. Median of Two Sorted Arrays658. Find K Closest Elements","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://kaihaoli.github.io/tags/Binary-Search/"}]},{"title":"Segment Tree 线段树","slug":"segment-tree","date":"2018-04-10T18:13:18.000Z","updated":"2018-04-10T21:36:39.075Z","comments":true,"path":"2018/04/10/segment-tree/","link":"","permalink":"http://kaihaoli.github.io/2018/04/10/segment-tree/","excerpt":"","text":"Segment Tree 线段树线段树参考整理自：九章算法线段树教程 1 线段树是什么？Google常考数据结构，国内也经常问这个。 线段树是一种高级数据结构，也是一种树结构，准确的说是二叉树，它能够高效的处理区间修改查询等问题。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 2 线段树的创建因为每次将区间的长度一分为二,所有创造的节点个数，即底层有n个节点，那么倒数第二次约n/2个节点，倒数第三次约n/4个节点，依次类推：123n + 1/2 * n + 1/4 * n + 1/8 * n + ...= (1 + 1/2 + 1/4 + 1/8 + ...) * n= 2n 所以构造线段树的时间复杂度和空间复杂度都为O(n) LintCode 201. Segment Tree Build线段树的创建，其实就是按照区间的index进行二分,然后Recursion的定义！ 12345678910111213141516\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end): self.start, self.end = start, end self.left, self.right = None, None\"\"\"class Solution: def build(self, start, end): if start &gt; end: return root = SegmentTreeNode(start, end) if start == end: return root mid = (start + end ) / 2 root.left = self.build(start, mid) root.right = self.build(mid + 1, end) return root LintCode 439. Segment Tree Build II每个节点node除了有区间index的信息外，还包括其他信息，比如区间内的最大值。Node(start, end, val) 12345678910111213141516171819202122232425\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end, max): self.start, self.end, self.max = start, end, max self.left, self.right = None, None\"\"\"class Solution: def build(self, A): if not A: return return self.buildTree(0, len(A)-1, A) def buildTree(self, start, end, A): if start &gt; end: return root = SegmentTreeNode(start, end, A[start]) if start == end: return root mid = (start + end) / 2 root.left = self.buildTree(start, mid, A) root.right = self.buildTree(mid+1, end, A) # Post Order update Max if root.left and root.left.max &gt; root.max: root.max = root.left.max if root.right and root.right.max &gt; root.max: root.max = root.right.max return root 如果需要区间的最小值:1root.min = Math.min(root.left.min, root.right.min); 如果需要区间的和:1root.sum = root.left.sum + root.right.sum; 3 线段树的更新更新是从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为log(n),所以更新序列中一个节点的复杂度为log(n)。 LintCode 203. Segment Tree Modify给一个Maximum Segment Tree, 更新某个index的value。1234567891011121314class Solution: def modify(self, root, index, value): if not root: return if root.start == root.end: root.val = value root.max = value return mid = (root.start + root.end) / 2 if index &lt;= mid: self.modify(root.left, index, value) else: self.modify(root.right, index, value) if root.right and root.left: root.max = max(root.right.max, root.left.max) 4 线段树的查询构造线段树的目的就是为了更快的查询。 给定一个区间，要求区间中最大的值。线段树的区间查询操作就是将当前区间分解为较小的子区间,然后由子区间的最大值就可以快速得到需要查询区间的最大值。 任意长度的线段，最多被拆分成logn条线段树上存在的线段，所以查询的时间复杂度为O(log(n)) LintCode 202. Segment Tree Query12345678910111213class Solution:def query(self, root, start, end): if not root: return if root.start == start and root.end == end: return root.max mid = (root.start + root.end) / 2 if start &gt; mid: return self.query(root.right, start, end) elif end &lt;= mid: return self.query(root.left, start, end) else: return max(self.query(root.left, start, mid), self.query(root.right, mid+1, end)) 5 线段树的应用线段树的基本应用 支持动态更改数组一个元素的值 O(logn) 求区间的和、最大值、最小值 O(logn) 创建，更新，求和或者求最大最小，只有这三个function！ 307. Range Sum Query - Mutable区间求和，如果原序列不变的话直接用preSum前缀和就可以了，但是如果序列可变的话update前缀和的复杂度就变成O(n) LintCode 249. Count of Smaller Number before itsel统计数组中每个元素后面比自己小的数。 初始化[0, max(nums)]的数组全部都是0 把数组中的数值当作index，统计数量就转化成了求区间和 其他解法：Binary Indexed Tree，Binary Search Tree 315. Count of Smaller Numbers After Self 值为负数或者最大值特别大的时候用Segment Tree，val无法作为index，导致 非常不合适！ 所以这个题得考虑别的解决方案","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://kaihaoli.github.io/tags/segment-tree/"},{"name":"binary indexed tree","slug":"binary-indexed-tree","permalink":"http://kaihaoli.github.io/tags/binary-indexed-tree/"}]}]}