{"meta":{"title":"kaihao","subtitle":"屠龙的少年仍在燃烧","description":null,"author":"Kaihao Li","url":"http://kaihaoli.github.io"},"pages":[{"title":"categories","date":"2018-04-10T20:18:48.000Z","updated":"2018-04-22T01:27:40.120Z","comments":true,"path":"categories/index.html","permalink":"http://kaihaoli.github.io/categories/index.html","excerpt":"","text":"Algorithms Full Stack System Design Big Data Machine Learning"},{"title":"tags","date":"2018-04-10T20:22:05.000Z","updated":"2018-04-10T20:22:32.914Z","comments":true,"path":"tags/index.html","permalink":"http://kaihaoli.github.io/tags/index.html","excerpt":"","text":""},{"title":"Data Structure and Algorithms","date":"2018-04-22T01:32:50.000Z","updated":"2018-04-22T01:40:16.065Z","comments":true,"path":"algorithms/index.html","permalink":"http://kaihaoli.github.io/algorithms/index.html","excerpt":"","text":"Algorithms Binary SearchTwo Pointer 1 同向双指针 2 相向双指针 K Sum Sort"},{"title":"Kaihao Li","date":"2018-04-10T21:03:53.000Z","updated":"2018-04-16T04:11:45.587Z","comments":true,"path":"about/index.html","permalink":"http://kaihaoli.github.io/about/index.html","excerpt":"","text":"Email: kaihaohust#gmail.com (replace # with @ please) Tel: (+1)631-428-7454 EDUCATION 2017.01 ~ 2018.12: M.S. in Computer Science, Stony Brook University 2011.09 ~ 2015.06: B.S. in Computer Science Engineering, Huazhong University of Science and Technology SKILLS Programming Languages: Python, Java, C. Go, Scala Full Stack:React, Express, Node.js Tools: Tensorflow,"}],"posts":[{"title":"Kafka Quick Start using Docker","slug":"docker-quick-start","date":"2018-04-26T01:20:22.000Z","updated":"2018-04-26T01:24:35.459Z","comments":true,"path":"2018/04/25/docker-quick-start/","link":"","permalink":"http://kaihaoli.github.io/2018/04/25/docker-quick-start/","excerpt":"","text":"Reference : Kafka Quick Start Guide Pre-RequisitesDocker 1 Create Virtual MachineGet the env for docker-machine, 2CPU, 2G1&gt; docker-machine create --driver virtualbox --virtualbox-cpu-count 2 --virtualbox-memory 2048 bigdata This command downloads a lightweight Linux distribution (boot2docker) with the Docker daemon installed, and creates and starts a VirtualBox VM with Docker running. docker-machine create 创建一个Docker主机 –driver virtualbox flag to indicate which provider (VirtualBox, DigitalOcean, AWS, etc.) the machine should be created on. ‘bigdata’ is an argument to indicate the name of the created machine. list available machines.1&gt; docker-machine ls Get the IP address of one or more machines.1&gt; docker-machine ip bigdata 2 Connect your shell to the machine Show the virtual machine environment variable 12345&gt; docker-machine env bigdataexport DOCKER_TLS_VERIFY=\"1\"export DOCKER_HOST=\"tcp://192.168.99.100:2376\"export DOCKER_CERT_PATH=\"/Users/yourhostname/.docker/machine/machines/bigdata\"export DOCKER_MACHINE_NAME=\"bigdata\" Run this command to configure your shell 12# Each time you want to use this virtual machine, you should run this command first!&gt; eval $(docker-machine env bigdata) 3 Pull Images12&gt; docker pull wurstmeister/zookeeper &gt; docker pull wurstmeister/kafka 4 Run Images Start zookeeper container 1234567&gt; docker run \\ -d \\ -p 2181:2181 \\ -p 2888:2888 \\ -p 3888:3888 \\ --name zookeeper \\ wurstmeister/zookeeper Start kafka container 12345678910&gt; docker run \\ -d \\ -p 9092:9092 \\ # IP=$(docker-machine ip $&#123;MACHINE_NAME&#125;) -e KAFKA_ADVERTISED_HOST_NAME=\"$&#123;IP&#125;\" \\ -e KAFKA_ADVERTISED_PORT=9092 \\ --name kafka \\ --link zookeeper:zookeeper \\ -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\ wurstmeister/kafka 5 Kafka Test Enter the Kafka container 12# here CONTAINER ID = kafka&gt; docker exec -it $&#123;CONTAINER ID&#125; /bin/bash Change to kafka default directory 1&gt; cd opt/kafka_2.xx-x.xx.x.x/ Create a Topic 1&gt; bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic mykafka Run a Producer 1&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka Run a Consumer(in another terminal!) 1&gt; bin/kafka-console-consumer.sh --zookeeper zookeeper:2181 --topic mykafka --from-beginning TESTWhen you type in some words in producer, it will appear in the consumer terminal. Kafka will replay the messages you have sent as a producer. All Done! :)","categories":[{"name":"Big Data","slug":"Big-Data","permalink":"http://kaihaoli.github.io/categories/Big-Data/"}],"tags":[]},{"title":"Docker","slug":"docker","date":"2018-04-22T00:31:44.000Z","updated":"2018-04-22T01:57:45.616Z","comments":true,"path":"2018/04/21/docker/","link":"","permalink":"http://kaihaoli.github.io/2018/04/21/docker/","excerpt":"","text":"参考资源: Docker — 从入门到实践 Docker 入门教程 阮一峰 History Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 Why use Docker? Docker - Build, Ship, and Run Any App, Anywhere 向服务器部署代码非常困难 复杂的技术栈, 不同技术栈的版本依赖与冲突 How to solve it?Docker vs VM What is Docker?Docker的三个概念 1 镜像(Image) 类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。 任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 2 容器(Container) 类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。 Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。 注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 3 仓库(Repository) 类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。 注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 Union File System Docker Components Docker daemon Runs on a host machine. It does the heavy lifting of building, running, and distributing Docker containers Docker client The primary user interface to Docker. It accepts commands from the user and communicates back and forth with a Docker daemon Docker images Docker image is a read-only template, which is used to create containers Docker registries Docker registries hold images, which are public or private stores from which you upload or download images. Docker containers Docker containers are similar to a directory. 性质 A Docker container holds everything that is needed for an application to run. Each container is created from a Docker image. Docker containers can be run, started, stopped, moved, and deleted. Each container is an isolated and secure application platform. ApplicationDocker 的主要用途，目前有三大类。 1 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 2 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 3 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 Docker on MacInstall1$ brew cask install docker","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Message Queue 消息队列","slug":"message-queue","date":"2018-04-18T22:21:34.000Z","updated":"2018-04-18T22:28:21.883Z","comments":true,"path":"2018/04/18/message-queue/","link":"","permalink":"http://kaihaoli.github.io/2018/04/18/message-queue/","excerpt":"","text":"参考资料: 大型网站架构系列：分布式消息队列 What is Message Queue A message queue is a queue of messages sent between applications. 中间人 Message queues provide an asynchronous communications protocol, meaning that the sender and receiver of the message do not need to interact with the message queue at the same time. An application framework for sending and receiving messages A way to communicate between applications / systems A way to decouple components A way to offload work (handle to another worker) Application Allow web servers to respond to requests quickly instead of being forced to perform resource-heavy procedures. Able to distribute a message to multiple recipients for consumption or for balancing loads between workers. 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。 目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。 Message Queue in Real Life对实时性要求不高的任务！ Image Resizing Video Processing Sending out Emails (Ad Campaigns) Log Analysis … AMPQ协议Message Queue Protocol AMQP - Advanced Message Queue Protocol (RabbitMQ) STOMP - Streaming Text Oriented Messaging Protocol (ActiveMQ) XMPP - Extensible Messaging and Presence Protocol Network wire-level protocol Defines how clients and brokers talk Data serialization, heartbeat AMQP Model Defines routing and storing of messages Defines rules how these are wired together Exported API RabbitMQ RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。Implements AMQP Easy to use, 支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 Open source and commercially supported RabiitMQ Solution Could-based Solution CloudAMQP CloudAMPQ in Python使用教程 Local1brew install rabbitmq # would take long","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Redis","slug":"redis","date":"2018-04-17T23:23:40.000Z","updated":"2018-04-18T22:32:23.103Z","comments":true,"path":"2018/04/17/redis/","link":"","permalink":"http://kaihaoli.github.io/2018/04/17/redis/","excerpt":"","text":"(参考资料:Redis学习教程Gitbook, RUNOOB Redis 教程) What is Redis Redis is an opensource(BSDlicensed), in-memory datas tructure store, used as database, cache and message broker. database只是Redis的一个应用， In-memory data structure store Data Structure Operations Strings - 字符串 SET, GET, APPEND Hashes - 哈希表 HSET, HGET List - 列表 LPUSH, LRANGE, LSET, LTRIM Set - 集合 SADD, SMEMBERS Sorted Set ZADD, ZRANGE, ZRANGEBYSCORE Why Redis Redis 有三个主要的特点, 有别于其它很多竞争对手 ： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以 再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Application (1) Cache Replacement - LRU LFU Pre-load (2) Message Broker MQ (3) Database Redis Install &amp; Config Install Redis with MAC 12345678910# Installbrew install redis# Startbrew services start redis# or redis-server /usr/local/etc/redis.conf# CMD~ % redis-cli127.0.0.1:6379&gt; Try CMD here : Redis Interactive Online Redis in PythonThe Python interface to the Redis key-value store. Install1sudo pip install redis ConnectionOpening a Connection to Redis Using redis-py123456#The following code creates a connection to Redis using redis-py:import redisredis_client = redis.Redis( host = 'hostname', port = port # redis default port 6379) redis提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。 redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。如果需要另一个Redis实例（or Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。同理，python的redis没有实现select命令。 12345# set, getr.set('name', 'junxi') # key是\"foo\" value是\"bar\" 将键值对存入redis缓存print(r['name'])print(r.get('name')) # 取出键name对应的值print(type(r.get('name')))","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Binary Search 二分查找","slug":"binary-search","date":"2018-04-16T03:31:10.000Z","updated":"2018-04-22T20:23:09.081Z","comments":true,"path":"2018/04/15/binary-search/","link":"","permalink":"http://kaihaoli.github.io/2018/04/15/binary-search/","excerpt":"","text":"Given a sorted array of n elements, write a function to search a given element x in array. Search算法里的入门算法，其实很多高级算法的思路都是以二分查找为基本思想引出的，特别是那些和logn相关的算法，比如说自平衡二叉树 经典二分查找 LintCode 457. \bClassical Binary Search 有序, 数组 Why 链表不可以？Why 无序不可以？ 1234567891011121314151617181920class Solution: def findPosition(self, nums, target): if not nums: return -1 # 1 Two Pointers 指向可行解的范围 start, end = 0, len(nums)-1 while start &lt;= end: # 2 Median Index mid = start + (end - start) // 2 # 3 Check Median Index Val if nums[mid] == target: return mid elif nums[mid] &gt; target: end = mid - 1 # Adjust end else: start = mid + 1 # Adjust start return -1 74. Search a 2D Matrix 一维Array和二维Matrix的转换 index =&gt; (x, y) x = index / col y = index % col 12345678910111213141516class Solution(object): def searchMatrix(self, matrix, target): if not matrix: return False m, n = len(matrix), len(matrix[0]) start, end = 0, m*n-1 while start &lt;= end: mid = start + (end - start) / 2 row, col = mid / n, mid % n if matrix[row][col] &lt; target: start = mid + 1 elif matrix[row][col] &gt; target: end = mid - 1 else: return True return False 九章算法二分查找模板 while 循环 ? while start + 1 &lt; end, 留两个值做post processing while start &lt; end, 留一个值做post processing while start &lt; = end, 不留值 缩小查找范围 ? start = mid 还是 start = mid + 1 end = mid 还是 end = mid + 1 1234567891011121314151617181920212223def findPosition(self, A, target): if(len(A) == 0): return -1 start = 0 end = len(A) - 1 while(start + 1 &lt; end): mid = start + (end - start) / 2 if(A[mid] == target): return mid if(A[mid] &lt; target): start = mid else: end = mid #post processing if (A[start] == target): return start elif (A[end] == target): return end else: return -1 Double Check 小技巧: 当前这个mid对应的值是不是可能是要找的结果，mid + 1 还是 mid ? start = mid 一定要用 while start + 1 &lt; end !!! 要找的结果是不是一定在数组当中！start &lt; end 还是 start &lt; = end 边界系列 Input是标准的 Sorted Array（单调增或者单调减） First or Last of Occrance! 大于等于，小于等于，大于，小于，等于 每次淘汰的空间要确定是不属于结果范围的！ 278. First Bad Version 000000011111111 Find The First Occrance of an Element 找的元素在不在数组里？while start &lt; end 还是 while start &lt; = end How about Last Good Version? 1234567891011121314151617181920212223242526272829303132# 写法1. 这种写法条件是target存在，且start = mid + 1class Solution(object): def firstBadVersion(self, n): start, end = 1, n while start &lt; end: mid = start + (end - start) / 2 ret = isBadVersion(mid) if ret: end = mid else: start = mid + 1 return start # 写法2. 九章算法模板 - 预留两位做post processingclass Solution(object): def firstBadVersion(self, n): start, end = 1, n # 预留两位最后处理 while start + 1 &lt; end: mid = start + (end - start) / 2 ret = isBadVersion(mid) if ret: end = mid else: start = mid + 1 # Post Processing if isBadVersion(start): return start else: return end 35. Search Insert Position 找 &gt; = target 的 first occrence 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): if not nums: return 0 if target &gt; nums[-1]: return len(nums) start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt;= target: end = mid else: start = mid + 1 # Post Precessing if nums[start] &gt;= target: return start else: return end 34. Search for a Range12345678910111213141516171819202122232425262728293031323334class Solution(object): def searchRange(self, nums, target): if not nums: return [-1, -1] # First Occurance start, end = 0 , len(nums) - 1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt;= target: end = mid else: start = mid + 1 if nums[start] == target: first = start elif nums[end] == target: first = end else: return [-1, -1] # Last Occurance start, end = 0, len(nums) - 1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt;= target: start = mid else: end = mid - 1 if nums[end] == target: return [first, end] else: return [first, start] 旋转数组系列 只有Sorted Array才能做Binary Search？ Input数组不再是单调递增或者单调递减 每次淘汰的空间要确定是不属于结果范围的！ 162. Find Peak Element 根据要找的Target条件缩小Search的范围！ 1234567891011121314151617# 模版解法class Solution(object): def findPeakElement(self, nums): if len(nums) &lt;= 1: return 0 start, end = 0 , len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[mid+1]: start = mid + 1 else: end = mid if nums[start] &gt; nums[end]: return start else: return end 12345678910111213class Solution(object): def findPeakElement(self, nums): if len(nums) &lt;= 1: return 0 start, end = 0 , len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[mid+1]: start = mid + 1 else: end = mid return start 153. Find Minimum in Rotated Sorted Array Why nums[mid] 和 nums[end]比较？ 1234567891011# 模版解法class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt; nums[end]: start = mid + 1 else: end = mid return min(nums[start], nums[end]) 12345678910class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt; nums[end]: start = mid + 1 else: end = mid return nums[start] 154. Find Minimum in Rotated Sorted Array II What if duplicates are allowed? Worst Case O(n) 123456789101112131415161718192021222324252627# nums[mid] == nums[end] ?class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return nums[start] # 套模板class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return min(nums[start], nums[end]) 33. Search in Rotated Sorted Array 1 把Array先根据nums[end]分成在前段还是后段 2 再根据nums[mid]的大小 12345678910111213141516171819class Solution(object): def search(self, nums, target): start, end = 0, len(nums)-1 while start &lt;= end: mid = start + (end - start) / 2 if nums[mid] == target: return mid # 前还是后，根据 num[end] 根据nums[start]也行 if nums[mid] &lt;= nums[end]: if nums[mid] &lt; target &lt;= nums[end]: start = mid + 1 else: end = mid - 1 else: if nums[start] &lt;= target &lt; nums[mid]: end = mid - 1 else: start = mid + 1 return -1 81. Search in Rotated Sorted Array II nums may contain duplicates nums[mid] == nums[start] 或者 nums[mid] == nums[end]的时候无法判断nums[mid]是在前段还是后段！ start += 1 缩减范围, Worst Case : O(n) 123456789101112131415161718192021class Solution(object): def search(self, nums, target): start, end = 0, len(nums)-1 while start &lt;= end: mid = (start + end) / 2 if nums[mid] == target: return True if nums[mid] &lt; nums[start]: if nums[mid] &lt; target &lt;= nums[end]: start = mid + 1 else: end = mid - 1 elif nums[mid] &gt; nums[start]: if nums[start] &lt;= target &lt; nums[mid]: end = mid - 1 else: start = mid + 1 else: start += 1 return False 数值二分型 典型的二分法: 输入是数组，双指针分别是数组的index Input不再是Array，不再以index，而是以value来做二分 374. Guess Number Higher or Lower367. Valid Perfect Square ret = mid * mid 来判断范围 12345678910111213class Solution(object): def isPerfectSquare(self, num): start, end = 1, num while start &lt;= end: mid = start + (end - start) / 2 ret = mid * mid if ret &gt; num: end = mid - 1 elif ret &lt; num: start = mid + 1 else: return True return False 69. Sqrt(x) 在0～x中找最大的数r，满足r * r &lt; = x Why start + 1 &lt; end ? 剩余的搜索范围都是满足搜索条件的！ 1234567891011121314151617class Solution(object): def mySqrt(self, x): start, end = 0, x while start + 1 &lt; end: mid = start + (end - start) / 2 ret = mid * mid if ret &gt; x: end = mid - 1 elif ret &lt; x: start = mid else: return mid if end * end &lt;= x: return end else: return start 综合题型 4. Median of Two Sorted Arrays 两个 Sorted Array 怎样做Binary Search? 123456789101112131415161718192021222324class Solution(object): def findMedianSortedArrays(self, nums1, nums2): m, n = len(nums1), len(nums2) if m &gt; n: return self.findMedianSortedArrays(nums2, nums1) start, end = 0, m k = (m+n) // 2 while start &lt;= end: cut1 = start + (end - start) // 2 cut2 = k - cut1 l1 = nums1[cut1-1] if cut1 &gt; 0 else -float('inf') l2 = nums2[cut2-1] if cut2 &gt; 0 else -float('inf') r1 = nums1[cut1] if cut1 &lt; m else float('inf') r2 = nums2[cut2] if cut2 &lt; n else float('inf') if l1 &gt; r2: end = cut1 - 1 elif l2 &gt; r1: start = cut1 + 1 else: if (m+n) % 2: return min(r1, r2) else: return (max(l1,l2) + min(r1,r2)) / 2.0 29. Divide Two Integers Division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative 倍增法 1, 2, 4, 8, 16, 32, 64 … 1234567891011121314151617class Solution(object): def divide(self, dividend, divisor): # 先用异或处理符号 np = (dividend &lt; 0) ^ (divisor &lt; 0) dividend = abs(dividend) divisor = abs(divisor) res = 0 while dividend &gt;= divisor: tmp, i = divisor, 1 while dividend &gt;= tmp: dividend -= tmp res += i i = i &lt;&lt; 1 tmp = tmp &lt;&lt; 1 if np: res = -res return min(max(-2147483648, res), 2147483647) 658. Find K Closest Elements 结合双指针 12345678910111213141516class Solution(object): def findClosestElements(self, arr, k, x): if x &lt;= arr[0]: return arr[:k] elif x &gt;= arr[-1]: return arr[-k:] else: index = bisect.bisect_left(arr, x) left = max(0, index-k) right = min(len(arr)-1, index+k-1) while right - left &gt; k-1: if arr[right] - x &gt;= x - arr[left]: right -= 1 else: left += 1 return arr[left:right+1] 300. Longest Increasing Subsequence 经典面试算法题“最长升序子序列“, 没做过的话, 很难想到O(nlogn)解法 1234567891011121314151617181920class Solution(object): def lengthOfLIS(self, nums): if not nums: return 0 n = len(nums) ends = [nums[0]] for i in xrange(1, n): if nums[i] &gt; ends[-1]: ends.append(nums[i]) continue start, end = 0, len(ends)-1 while start &lt; end: mid = start + (end - start) / 2 if ends[mid] &lt; nums[i]: start = mid + 1 else: end = mid ends[start] = nums[i] return len(ends)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://kaihaoli.github.io/tags/Binary-Search/"}]},{"title":"Segment Tree 线段树","slug":"segment-tree","date":"2018-04-10T18:13:18.000Z","updated":"2018-04-10T21:36:39.075Z","comments":true,"path":"2018/04/10/segment-tree/","link":"","permalink":"http://kaihaoli.github.io/2018/04/10/segment-tree/","excerpt":"","text":"Segment Tree 线段树线段树参考整理自：九章算法线段树教程 1 线段树是什么？Google常考数据结构，国内也经常问这个。 线段树是一种高级数据结构，也是一种树结构，准确的说是二叉树，它能够高效的处理区间修改查询等问题。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 2 线段树的创建因为每次将区间的长度一分为二,所有创造的节点个数，即底层有n个节点，那么倒数第二次约n/2个节点，倒数第三次约n/4个节点，依次类推：123n + 1/2 * n + 1/4 * n + 1/8 * n + ...= (1 + 1/2 + 1/4 + 1/8 + ...) * n= 2n 所以构造线段树的时间复杂度和空间复杂度都为O(n) LintCode 201. Segment Tree Build线段树的创建，其实就是按照区间的index进行二分,然后Recursion的定义！ 12345678910111213141516\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end): self.start, self.end = start, end self.left, self.right = None, None\"\"\"class Solution: def build(self, start, end): if start &gt; end: return root = SegmentTreeNode(start, end) if start == end: return root mid = (start + end ) / 2 root.left = self.build(start, mid) root.right = self.build(mid + 1, end) return root LintCode 439. Segment Tree Build II每个节点node除了有区间index的信息外，还包括其他信息，比如区间内的最大值。Node(start, end, val) 12345678910111213141516171819202122232425\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end, max): self.start, self.end, self.max = start, end, max self.left, self.right = None, None\"\"\"class Solution: def build(self, A): if not A: return return self.buildTree(0, len(A)-1, A) def buildTree(self, start, end, A): if start &gt; end: return root = SegmentTreeNode(start, end, A[start]) if start == end: return root mid = (start + end) / 2 root.left = self.buildTree(start, mid, A) root.right = self.buildTree(mid+1, end, A) # Post Order update Max if root.left and root.left.max &gt; root.max: root.max = root.left.max if root.right and root.right.max &gt; root.max: root.max = root.right.max return root 如果需要区间的最小值:1root.min = Math.min(root.left.min, root.right.min); 如果需要区间的和:1root.sum = root.left.sum + root.right.sum; 3 线段树的更新更新是从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为log(n),所以更新序列中一个节点的复杂度为log(n)。 LintCode 203. Segment Tree Modify给一个Maximum Segment Tree, 更新某个index的value。1234567891011121314class Solution: def modify(self, root, index, value): if not root: return if root.start == root.end: root.val = value root.max = value return mid = (root.start + root.end) / 2 if index &lt;= mid: self.modify(root.left, index, value) else: self.modify(root.right, index, value) if root.right and root.left: root.max = max(root.right.max, root.left.max) 4 线段树的查询构造线段树的目的就是为了更快的查询。 给定一个区间，要求区间中最大的值。线段树的区间查询操作就是将当前区间分解为较小的子区间,然后由子区间的最大值就可以快速得到需要查询区间的最大值。 任意长度的线段，最多被拆分成logn条线段树上存在的线段，所以查询的时间复杂度为O(log(n)) LintCode 202. Segment Tree Query12345678910111213class Solution:def query(self, root, start, end): if not root: return if root.start == start and root.end == end: return root.max mid = (root.start + root.end) / 2 if start &gt; mid: return self.query(root.right, start, end) elif end &lt;= mid: return self.query(root.left, start, end) else: return max(self.query(root.left, start, mid), self.query(root.right, mid+1, end)) 5 线段树的应用线段树的基本应用 支持动态更改数组一个元素的值 O(logn) 求区间的和、最大值、最小值 O(logn) 创建，更新，求和或者求最大最小，只有这三个function！ 307. Range Sum Query - Mutable区间求和，如果原序列不变的话直接用preSum前缀和就可以了，但是如果序列可变的话update前缀和的复杂度就变成O(n) LintCode 249. Count of Smaller Number before itsel统计数组中每个元素后面比自己小的数。 初始化[0, max(nums)]的数组全部都是0 把数组中的数值当作index，统计数量就转化成了求区间和 其他解法：Binary Indexed Tree，Binary Search Tree 315. Count of Smaller Numbers After Self 值为负数或者最大值特别大的时候用Segment Tree，val无法作为index，导致 非常不合适！ 所以这个题得考虑别的解决方案","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://kaihaoli.github.io/tags/segment-tree/"},{"name":"binary indexed tree","slug":"binary-indexed-tree","permalink":"http://kaihaoli.github.io/tags/binary-indexed-tree/"}]}]}