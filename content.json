{"meta":{"title":"kaihao","subtitle":"屠龙的少年仍在燃烧","description":null,"author":"Kaihao Li","url":"http://kaihaoli.github.io"},"pages":[{"title":"categories","date":"2018-04-10T20:18:48.000Z","updated":"2018-04-10T20:19:56.378Z","comments":true,"path":"categories/index.html","permalink":"http://kaihaoli.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-10T20:22:05.000Z","updated":"2018-04-10T20:22:32.914Z","comments":true,"path":"tags/index.html","permalink":"http://kaihaoli.github.io/tags/index.html","excerpt":"","text":""},{"title":"Kaihao Li","date":"2018-04-10T21:03:53.000Z","updated":"2018-04-16T04:11:45.587Z","comments":true,"path":"about/index.html","permalink":"http://kaihaoli.github.io/about/index.html","excerpt":"","text":"Email: kaihaohust#gmail.com (replace # with @ please) Tel: (+1)631-428-7454 EDUCATION 2017.01 ~ 2018.12: M.S. in Computer Science, Stony Brook University 2011.09 ~ 2015.06: B.S. in Computer Science Engineering, Huazhong University of Science and Technology SKILLS Programming Languages: Python, Java, C. Go, Scala Full Stack:React, Express, Node.js Tools: Tensorflow,"}],"posts":[{"title":"Message Queue 消息队列","slug":"message-queue","date":"2018-04-18T22:21:34.000Z","updated":"2018-04-18T22:28:21.883Z","comments":true,"path":"2018/04/18/message-queue/","link":"","permalink":"http://kaihaoli.github.io/2018/04/18/message-queue/","excerpt":"","text":"参考资料: 大型网站架构系列：分布式消息队列 What is Message Queue A message queue is a queue of messages sent between applications. 中间人 Message queues provide an asynchronous communications protocol, meaning that the sender and receiver of the message do not need to interact with the message queue at the same time. An application framework for sending and receiving messages A way to communicate between applications / systems A way to decouple components A way to offload work (handle to another worker) Application Allow web servers to respond to requests quickly instead of being forced to perform resource-heavy procedures. Able to distribute a message to multiple recipients for consumption or for balancing loads between workers. 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。 目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。 Message Queue in Real Life对实时性要求不高的任务！ Image Resizing Video Processing Sending out Emails (Ad Campaigns) Log Analysis … AMPQ协议Message Queue Protocol AMQP - Advanced Message Queue Protocol (RabbitMQ) STOMP - Streaming Text Oriented Messaging Protocol (ActiveMQ) XMPP - Extensible Messaging and Presence Protocol Network wire-level protocol Defines how clients and brokers talk Data serialization, heartbeat AMQP Model Defines routing and storing of messages Defines rules how these are wired together Exported API RabbitMQ RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。Implements AMQP Easy to use, 支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 Open source and commercially supported RabiitMQ Solution Could-based Solution CloudAMQP CloudAMPQ in Python使用教程 Local1brew install rabbitmq # would take long","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Redis","slug":"redis","date":"2018-04-17T23:23:40.000Z","updated":"2018-04-18T22:32:23.103Z","comments":true,"path":"2018/04/17/redis/","link":"","permalink":"http://kaihaoli.github.io/2018/04/17/redis/","excerpt":"","text":"(参考资料:Redis学习教程Gitbook, RUNOOB Redis 教程) What is Redis Redis is an opensource(BSDlicensed), in-memory datas tructure store, used as database, cache and message broker. database只是Redis的一个应用， In-memory data structure store Data Structure Operations Strings - 字符串 SET, GET, APPEND Hashes - 哈希表 HSET, HGET List - 列表 LPUSH, LRANGE, LSET, LTRIM Set - 集合 SADD, SMEMBERS Sorted Set ZADD, ZRANGE, ZRANGEBYSCORE Why Redis Redis 有三个主要的特点, 有别于其它很多竞争对手 ： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以 再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Application (1) Cache Replacement - LRU LFU Pre-load (2) Message Broker MQ (3) Database Redis Install &amp; Config Install Redis with MAC 12345678910# Installbrew install redis# Startbrew services start redis# or redis-server /usr/local/etc/redis.conf# CMD~ % redis-cli127.0.0.1:6379&gt; Try CMD here : Redis Interactive Online Redis in PythonThe Python interface to the Redis key-value store. Install1sudo pip install redis ConnectionOpening a Connection to Redis Using redis-py123456#The following code creates a connection to Redis using redis-py:import redisredis_client = redis.Redis( host = 'hostname', port = port # redis default port 6379) redis提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。 redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。如果需要另一个Redis实例（or Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。同理，python的redis没有实现select命令。 12345# set, getr.set('name', 'junxi') # key是\"foo\" value是\"bar\" 将键值对存入redis缓存print(r['name'])print(r.get('name')) # 取出键name对应的值print(type(r.get('name')))","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Binary Search 二分查找","slug":"binary-search","date":"2018-04-16T03:31:10.000Z","updated":"2018-04-20T22:54:42.427Z","comments":true,"path":"2018/04/15/binary-search/","link":"","permalink":"http://kaihaoli.github.io/2018/04/15/binary-search/","excerpt":"","text":"Given a sorted array of n elements, write a function to search a given element x in array. 经典二分查找LintCode 457. \bClassical Binary Search 有序, 数组 123456789101112131415161718class Solution: def findPosition(self, nums, target): if not nums: return -1 # 1 Two Pointers 指向可行解的范围 start, end = 0, len(nums)-1 while start &lt;= end: # 2 Median Index mid = start + (end - start) // 2 # 3 Check Median Index Val if nums[mid] == target: return mid elif nums[mid] &gt; target: end = mid - 1 # Adjust end else: start = mid + 1 # Adjust start return -1 74. Search a 2D Matrix index =&gt; (x, y) x = index / col y = index % col 12345678910111213141516class Solution(object): def searchMatrix(self, matrix, target): if not matrix: return False m, n = len(matrix), len(matrix[0]) start, end = 0, m*n-1 while start &lt;= end: mid = start + (end - start) / 2 row, col = mid / n, mid % n if matrix[row][col] &lt; target: start = mid + 1 elif matrix[row][col] &gt; target: end = mid - 1 else: return True return False 基础应用 Input是标准的 Sorted Array（单调增或者单调减） 存在 Duplicate 每次淘汰的空间要确定是不属于结果范围的！ 278. First Bad Version 000000011111111 Find The First Occrance of an Element 找的元素在不在数组里？while start &lt; end 还是 while start &lt; = end How about Last Good Version? 1234567891011121314151617181920212223242526272829303132# 写法1. 这种写法条件是target存在，且start = mid + 1class Solution(object): def firstBadVersion(self, n): start, end = 1, n while start &lt; end: mid = start + (end - start) / 2 ret = isBadVersion(mid) if ret: end = mid else: start = mid + 1 return start# 写法2. 九章算法模板 - 预留两位做post processingclass Solution(object): def firstBadVersion(self, n): start, end = 1, n # 预留两位最后处理 while start + 1 &lt; end: mid = start + (end - start) / 2 ret = isBadVersion(mid) if ret: end = mid else: start = mid + 1 # Post Processing if isBadVersion(start): return start else: return end 35. Search Insert Position 找 &gt; = target 的 first occrence 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): if not nums: return 0 if target &gt; nums[-1]: return len(nums) start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt;= target: end = mid else: start = mid + 1 # Post Precessing if nums[start] &gt;= target: return start else: return end 34. Search for a Range12345678910111213141516171819202122232425262728293031323334class Solution(object): def searchRange(self, nums, target): if not nums: return [-1, -1] # First Occurance start, end = 0 , len(nums) - 1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt;= target: end = mid else: start = mid + 1 if nums[start] == target: first = start elif nums[end] == target: first = end else: return [-1, -1] # Last Occurance start, end = 0, len(nums) - 1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt;= target: start = mid else: end = mid - 1 if nums[end] == target: return [first, end] else: return [first, start] 旋转数组系列 只有Sorted Array才能做Binary Search？ Input数组不再是单调递增或者单调递减 每次淘汰的空间要确定是不属于结果范围的！ 162. Find Peak Element 根据要找的Target条件缩小Search的范围！ 12345678910111213141516class Solution(object): def findPeakElement(self, nums): if len(nums) &lt;= 1: return 0 start, end = 0 , len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[mid+1]: start = mid + 1 else: end = mid if nums[start] &gt; nums[end]: return start else: return end 153. Find Minimum in Rotated Sorted Array Why nums[mid] 和 nums[end]比较？ 12345678910class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt; nums[end]: start = mid + 1 else: end = mid return min(nums[start], nums[end]) 154. Find Minimum in Rotated Sorted Array II What if duplicates are allowed? 1234567891011121314151617181920212223242526272829# 方法1. 用while start &lt; end, 可以这样的条件:# 1. 值一定存在 2. start 会mid+1# What if find the maximum value ?class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return nums[start]# 方法2. 套模板class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return min(nums[start], nums[end]) 33. Search in Rotated Sorted Array 1 把Array先根据nums[end]分成在前段还是后段 2 再根据nums[mid]的大小 12345678910111213141516171819class Solution(object): def search(self, nums, target): start, end = 0, len(nums)-1 while start &lt;= end: mid = start + (end - start) / 2 if nums[mid] == target: return mid # 前还是后，根据 num[end] 根据nums[start]也行 if nums[mid] &lt;= nums[end]: if nums[mid] &lt; target &lt;= nums[end]: start = mid + 1 else: end = mid - 1 else: if nums[start] &lt;= target &lt; nums[mid]: end = mid - 1 else: start = mid + 1 return -1 81. Search in Rotated Sorted Array II nums may contain duplicates nums[mid] == nums[start] 或者 nums[mid] == nums[end]的时候无法判断nums[mid]是在前段还是后段！ start += 1 缩减范围, Worst Case : O(n) 123456789101112131415161718192021class Solution(object): def search(self, nums, target): start, end = 0, len(nums)-1 while start &lt;= end: mid = (start + end) // 2 if nums[mid] == target: return True if nums[mid] &lt; nums[start]: if nums[mid] &lt; target &lt;= nums[end]: start = mid + 1 else: end = mid - 1 elif nums[mid] &gt; nums[start]: if nums[start] &lt;= target &lt; nums[mid]: end = mid - 1 else: start = mid + 1 else: start += 1 return False 数值二分型 典型的二分法: 输入是数组，双指针分别是数组的index Input不再是Array，不再以index，而是以value来做二分 374. Guess Number Higher or Lower367. Valid Perfect Square ret = mid * mid 来判断范围 12345678910111213class Solution(object): def isPerfectSquare(self, num): start, end = 1, num while start &lt;= end: mid = start + (end - start) / 2 ret = mid * mid if ret &gt; num: end = mid - 1 elif ret &lt; num: start = mid + 1 else: return True return False 69. Sqrt(x) 在0～x中找最大的数r，满足r * r &lt; = x Why start + 1 &lt; end ? 剩余的搜索范围都是满足搜索条件的！ 1234567891011121314151617class Solution(object): def mySqrt(self, x): start, end = 0, x while start + 1 &lt; end: mid = start + (end - start) / 2 ret = mid * mid if ret &gt; x: end = mid - 1 elif ret &lt; x: start = mid else: return mid if end * end &lt;= x: return end else: return start 综合题型29. Divide Two Integers Division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative 倍增法 1, 2, 4, 8, 16, 32, 64 … 1234567891011121314151617class Solution(object): def divide(self, dividend, divisor): # 先用异或处理符号 np = (dividend &lt; 0) ^ (divisor &lt; 0) dividend = abs(dividend) divisor = abs(divisor) res = 0 while dividend &gt;= divisor: tmp, i = divisor, 1 while dividend &gt;= tmp: dividend -= tmp res += i i = i &lt;&lt; 1 tmp = tmp &lt;&lt; 1 if np: res = -res return min(max(-2147483648, res), 2147483647) 4. Median of Two Sorted Arrays 两个 Sorted Array 658. Find K Closest Elements 结合双指针","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://kaihaoli.github.io/tags/Binary-Search/"}]},{"title":"Segment Tree 线段树","slug":"segment-tree","date":"2018-04-10T18:13:18.000Z","updated":"2018-04-10T21:36:39.075Z","comments":true,"path":"2018/04/10/segment-tree/","link":"","permalink":"http://kaihaoli.github.io/2018/04/10/segment-tree/","excerpt":"","text":"Segment Tree 线段树线段树参考整理自：九章算法线段树教程 1 线段树是什么？Google常考数据结构，国内也经常问这个。 线段树是一种高级数据结构，也是一种树结构，准确的说是二叉树，它能够高效的处理区间修改查询等问题。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 2 线段树的创建因为每次将区间的长度一分为二,所有创造的节点个数，即底层有n个节点，那么倒数第二次约n/2个节点，倒数第三次约n/4个节点，依次类推：123n + 1/2 * n + 1/4 * n + 1/8 * n + ...= (1 + 1/2 + 1/4 + 1/8 + ...) * n= 2n 所以构造线段树的时间复杂度和空间复杂度都为O(n) LintCode 201. Segment Tree Build线段树的创建，其实就是按照区间的index进行二分,然后Recursion的定义！ 12345678910111213141516\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end): self.start, self.end = start, end self.left, self.right = None, None\"\"\"class Solution: def build(self, start, end): if start &gt; end: return root = SegmentTreeNode(start, end) if start == end: return root mid = (start + end ) / 2 root.left = self.build(start, mid) root.right = self.build(mid + 1, end) return root LintCode 439. Segment Tree Build II每个节点node除了有区间index的信息外，还包括其他信息，比如区间内的最大值。Node(start, end, val) 12345678910111213141516171819202122232425\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end, max): self.start, self.end, self.max = start, end, max self.left, self.right = None, None\"\"\"class Solution: def build(self, A): if not A: return return self.buildTree(0, len(A)-1, A) def buildTree(self, start, end, A): if start &gt; end: return root = SegmentTreeNode(start, end, A[start]) if start == end: return root mid = (start + end) / 2 root.left = self.buildTree(start, mid, A) root.right = self.buildTree(mid+1, end, A) # Post Order update Max if root.left and root.left.max &gt; root.max: root.max = root.left.max if root.right and root.right.max &gt; root.max: root.max = root.right.max return root 如果需要区间的最小值:1root.min = Math.min(root.left.min, root.right.min); 如果需要区间的和:1root.sum = root.left.sum + root.right.sum; 3 线段树的更新更新是从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为log(n),所以更新序列中一个节点的复杂度为log(n)。 LintCode 203. Segment Tree Modify给一个Maximum Segment Tree, 更新某个index的value。1234567891011121314class Solution: def modify(self, root, index, value): if not root: return if root.start == root.end: root.val = value root.max = value return mid = (root.start + root.end) / 2 if index &lt;= mid: self.modify(root.left, index, value) else: self.modify(root.right, index, value) if root.right and root.left: root.max = max(root.right.max, root.left.max) 4 线段树的查询构造线段树的目的就是为了更快的查询。 给定一个区间，要求区间中最大的值。线段树的区间查询操作就是将当前区间分解为较小的子区间,然后由子区间的最大值就可以快速得到需要查询区间的最大值。 任意长度的线段，最多被拆分成logn条线段树上存在的线段，所以查询的时间复杂度为O(log(n)) LintCode 202. Segment Tree Query12345678910111213class Solution:def query(self, root, start, end): if not root: return if root.start == start and root.end == end: return root.max mid = (root.start + root.end) / 2 if start &gt; mid: return self.query(root.right, start, end) elif end &lt;= mid: return self.query(root.left, start, end) else: return max(self.query(root.left, start, mid), self.query(root.right, mid+1, end)) 5 线段树的应用线段树的基本应用 支持动态更改数组一个元素的值 O(logn) 求区间的和、最大值、最小值 O(logn) 创建，更新，求和或者求最大最小，只有这三个function！ 307. Range Sum Query - Mutable区间求和，如果原序列不变的话直接用preSum前缀和就可以了，但是如果序列可变的话update前缀和的复杂度就变成O(n) LintCode 249. Count of Smaller Number before itsel统计数组中每个元素后面比自己小的数。 初始化[0, max(nums)]的数组全部都是0 把数组中的数值当作index，统计数量就转化成了求区间和 其他解法：Binary Indexed Tree，Binary Search Tree 315. Count of Smaller Numbers After Self 值为负数或者最大值特别大的时候用Segment Tree，val无法作为index，导致 非常不合适！ 所以这个题得考虑别的解决方案","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://kaihaoli.github.io/tags/segment-tree/"},{"name":"binary indexed tree","slug":"binary-indexed-tree","permalink":"http://kaihaoli.github.io/tags/binary-indexed-tree/"}]}]}