{"meta":{"title":"kaihao","subtitle":"屠龙的少年仍在燃烧","description":null,"author":"Kaihao Li","url":"http://kaihaoli.github.io"},"pages":[{"title":"tags","date":"2018-04-10T20:22:05.000Z","updated":"2018-04-10T20:22:32.914Z","comments":true,"path":"tags/index.html","permalink":"http://kaihaoli.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-10T20:18:48.000Z","updated":"2018-09-27T03:38:16.874Z","comments":true,"path":"categories/index.html","permalink":"http://kaihaoli.github.io/categories/index.html","excerpt":"","text":"Algorithms DFS BFS Binary Search Dynamic Programming Data Structure Linked List Tree Graph Big Data Spark Kafka Cassandra Full Stack TODOMachine LearningSystem Design"},{"title":"Data Structure and Algorithms","date":"2018-04-22T01:32:50.000Z","updated":"2018-11-18T05:09:21.891Z","comments":true,"path":"algorithms/index.html","permalink":"http://kaihaoli.github.io/algorithms/index.html","excerpt":"","text":"knowing about the basic operations provided by the data structure, which operations are efficient, which are not? knowing about for what use case we can utilize the certain kind of data structure? Data Structure 1 String Substring, Subsequence, Pattern 2 Linked List Basic Operation (delete, remove, find middle, merge) Reverse Cycle 3 Stack Monotone Stack 4 Heap5 Tree Tree Traversal(DFS, BFS) Tree Lowest Common Ancestor Path, Recursion Tree Categories Complete Binary Tree, Full Binary Tree, Perfect Binary Tree Binary Search Tree Binary Indexed Tree Segmented Tree 5 Graph Detect Cycle, DFS, BFS Directed Graph, Topological Sort Advanced Data Structure 1 Union-Find2 Trie3 Segment Tree4 Binary Indexed TreeAlgorithms 1 Sort Selection Sort, Bubble Sort, Insertion Sort Merge Sort, Quick Sort, Heap Sort Sort Colors, Wiggle Sort External Sort 2 Binary Search Sorted Array, Duplicates Rotated Sorted Array, Peak Array 3 DFS DFS + Memorization =&gt; DP GAME 4 BFS5 Dynamic Programming Sequence Double Sequence Frequent Topic Data Stream &amp; Sliding Window Boyer-Moore Voting Algorithm Cache Interval Problem Serialization &amp; Deserialization"},{"title":"Kaihao Li","date":"2018-04-10T21:03:53.000Z","updated":"2018-09-26T00:06:17.050Z","comments":true,"path":"about/index.html","permalink":"http://kaihaoli.github.io/about/index.html","excerpt":"","text":"kaihaohust#gmail.com (replace # with @ please) | (+1)631-428-7454 EDUCATION Jan. 2017 - Dec. 2018Stony Brook University, StonyBrook, NYM.S. in Computer Science Sep. 2011 - Jun. 2015Huazhong University of Science and Technology, Wuhan, ChinaB.S. in Computer Science Engineering SKILLS Programming Language : Python, Java, C Web Development : Django, Flask, RabbitMQ, Redis, MongoDB, nodejs, React, D3.js Tools &amp; Frameworks : Docker, Kafka, Cassandra, Spark, Keras, Tensorflow, Linux"}],"posts":[{"title":"System Design - News Feed","slug":"system-design-news","date":"2018-12-25T15:26:08.000Z","updated":"2018-12-30T17:09:30.564Z","comments":true,"path":"2018/12/25/system-design-news/","link":"","permalink":"http://kaihaoli.github.io/2018/12/25/system-design-news/","excerpt":"","text":"4S Analysis, Take “Design a Twitter” for example! 1S - Scenario1 Enumerate Features Register, Login User Profile Display, Edit Upload Image, Video Search Post, Share a tweet Timeline, News Feed Follow, Unfollow a user 2 Key Features Post a Tweet Timeline News Feed Follow, Unfollow a User Register, Login QPS Analysis &amp; PredictQPS(Query Per Second) Concurrent User (Peak, Fast Growing) Read QPS Write QPS Range of QPS QPS = 100, one laptop enough QPS = 1k, one Web Server (Single Point Failure) QPS = 1m, 1000 Servers (Maintainance) NoSQL(10k QPS Cassandra, 1M QPS Memcached) 2S - ServiceSplit/ Application/ Module User Service Tweet Service Media Service Friendship Service 3S - Storage Schema/ Data/ SQL/ NoSQL/ File System System = Service + Storage 1 Select Database SQL DatabaseUser Table, User Service NoSQL DatabaseTweets, Social Graph, Tweet Service File SystemMedia 2 Design Schema id &amp; colums News Feed Facebook, Twitter, Wechat Moments, Byte Dance Everyone has different news feed!!! Follow and Unfollow Pull Model Merge K Sorted Arrays News Feed, N Database Reads + Merge N arrays(Memory) Post a tweet, 1 DB Write But it’s very slow to read N DB when you get your news feed!!! Push Model Fanout, When a user post a tweet, then push this tweet to every user who follow him or her News Feed, 1 Database Reads Post a tweet, N DB Writes(But user do not need to wait!!!) But when a user have toooo many followers, it take longer time to fanout! Trade Off Facebook - Pull Instagram - Push + Pull Twitter - Pull 4S - ScaleSharding/ Optimize/ Special Case OptimizePull Moedel Cache before DB Query Cache every user’s timeline Cache every user’s news feed Push Model Disk is cheap Inactive Users Followers much larger than FollowingFanout will take several hours!!! Seperate Star User and Normal User Maintenance(Explain it later!) Robust Scalability Seperated Services Follow and Unfollow Likes Thundering Herd","categories":[{"name":"System Design","slug":"System-Design","permalink":"http://kaihaoli.github.io/categories/System-Design/"}],"tags":[]},{"title":"BFS Matrix","slug":"bfs-matrix","date":"2018-12-03T13:33:40.000Z","updated":"2018-12-03T15:54:32.345Z","comments":true,"path":"2018/12/03/bfs-matrix/","link":"","permalink":"http://kaihaoli.github.io/2018/12/03/bfs-matrix/","excerpt":"","text":"490. The Maze Directions BFS123456789101112131415161718192021class Solution(object): def hasPath(self, maze, start, destination): m, n = len(maze), len(maze[0]) queue = collections.deque([(start)]) visited = set() visited.add(tuple(start)) dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)] while queue: x, y = queue.popleft() if (x, y) == tuple(destination): return True for dx, dy in dirs: nx, ny = x, y while 0 &lt;= nx + dx &lt;= m-1 and 0 &lt;= ny + dy &lt;= n-1 and maze[nx+dx][ny+dy] == 0: nx += dx ny += dy if (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False 296. Best Meeting PointSolution1. Sort Time : O(mn), Space : O(mn) Only for this case that we do not have any obstacle and distance is Manhattan Distance 1234567891011121314151617181920class Solution: def minTotalDistance(self, grid): xnums, ynums = [], [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: xnums.append(i) ynums.append(j) return self.minDistance(xnums) + self.minDistance(ynums) def minDistance(self, nums): nums = sorted(nums) res = 0 left, right = 0, len(nums)-1 while left &lt; right: res += nums[right] - nums[left] right -= 1 left += 1 return res Solution2. BFS - TLE Time : O($(mn)^2$), Space : O(mn) More General Solution, But have high time complexity!!1234567891011121314151617181920212223class Solution: def minTotalDistance(self, grid): m, n = len(grid), len(grid[0]) self.dis = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if grid[i][j] == 1: self.bfs(grid, i, j) return min([self.dis[i][j] for i in range(m) for j in range(n)]) def bfs(self, grid, i, j): queue = collections.deque([(i, j, 0)]) visited = set([(i, j)]) while queue: ni, nj, d = queue.popleft() self.dis[ni][nj] += d for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]: if (0 &lt;= ni+di &lt;= len(grid)-1 and 0 &lt;= nj+dj &lt;= len(grid[0])-1 and (ni+di, nj+dj) not in visited): queue.append((ni+di, nj+dj, d+1)) visited.add((ni+di, nj+dj)) 317. Shortest Distance from All Buildings Key idea : people to building or building to people ?1234567891011121314151617181920212223242526class Solution(object): def shortestDistance(self, grid): m, n = len(grid), len(grid[0]) sums = collections.defaultdict(int) bcnt = collections.defaultdict(int) total = 0 directions = [(-1,0), (0,-1), (0,1), (1,0)] for i in xrange(m): for j in xrange(n): if grid[i][j] == 1: # Run BFS total += 1 visited = set() queue = [(i,j,0)] while queue: x, y, val = queue.pop(0) for dx, dy in directions: if 0 &lt;= x+dx &lt;= m-1 and 0 &lt;= y+dy &lt;= n-1 and (x+dx, y+dy) not in visited and grid[x+dx][y+dy] == 0: visited.add((x+dx, y+dy)) queue.append((x+dx, y+dy, val+1)) sums[(x+dx, y+dy)] += val+1 bcnt[(x+dx, y+dy)] += 1 res = float('inf') for x, y in bcnt.keys(): if bcnt[(x, y)] == total: res = min(res, sums[(x, y)]) return -1 if res == float('inf') else res where to add visited in BFS? when pop out or push in? add visited hash set when you append an element in the queue!!! 12345678910111213141516171819202122232425262728293031323334class Solution(object): def shortestDistance(self, grid): if not grid: return -1 m, n = len(grid), len(grid[0]) matrix = [[[0, 0] for _ in range(n)] for _ in range(m)] cnt = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: self.bfs(matrix, i, j, grid) cnt += 1 res = float('inf') for i in range(m): for j in range(n): if grid[i][j] == 0 and matrix[i][j][1] == cnt: res = min(res, matrix[i][j][0]) return -1 if res == float('inf') else res def bfs(self, matrix, i, j, grid): m, n = len(grid), len(grid[0]) queue = collections.deque([(i, j, 0)]) visited = set() visited.add((i, j)) while queue: x, y, step = queue.popleft() matrix[x][y][0] += step matrix[x][y][1] += 1 for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]: nx, ny = x+dx, y+dy if 0 &lt;= nx &lt;= m-1 and 0 &lt;= ny &lt;= n-1 and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, step+1)) visited.add((nx, ny))","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://kaihaoli.github.io/tags/bfs/"},{"name":"matrix","slug":"matrix","permalink":"http://kaihaoli.github.io/tags/matrix/"}]},{"title":"BFS","slug":"bfs","date":"2018-12-03T03:29:29.000Z","updated":"2018-12-03T15:54:48.856Z","comments":true,"path":"2018/12/02/bfs/","link":"","permalink":"http://kaihaoli.github.io/2018/12/02/bfs/","excerpt":"","text":"Best First Search Init state expansion/generation rule termination 301. Remove Invalid Parentheses BFS - level order traversal remove the minimum number Solution1. BFS12345678910111213141516171819202122232425262728293031323334class Solution(object): def removeInvalidParentheses(self, s): visited = set([s]) queue = [s] res = [] found = False while queue: for st in queue: if self.isValid(st): found = True res.append(st) if found: break nqueue = [] for st in queue: for i, ch in enumerate(st): if ch in \"()\": nst = st[:i]+st[i+1:] if nst not in visited: nqueue.append(nst) visited.add(nst) queue = nqueue return res def isValid(self, s): left = 0 for ch in s: if ch == '(': left += 1 elif ch == ')': left -= 1 if left &lt; 0: return False return left == 0 We can also use dfs with pruning to solve this problem! Solution2. DFS + pruning Backtracking1234567891011121314151617181920212223242526272829303132class Solution(object): def removeInvalidParentheses(self, s): lp = rp = 0 for ch in s: if ch == '(': lp += 1 elif ch == ')': if lp &gt; 0: lp -= 1 else: rp += 1 res = set() self.dfs(lp, rp, 0, s, [], res) return list(res) def dfs(self, lp, rp, pairs, s, path, res): if lp &lt; 0 or rp &lt; 0 or pairs &lt; 0: return if len(s) == 0: if lp == 0 and rp == 0 and pairs == 0: res.add(''.join(path)) return if s[0] == '(': self.dfs(lp-1, rp, pairs, s[1:], path, res) self.dfs(lp, rp, pairs+1, s[1:], path + [s[0]], res) elif s[0] == ')': self.dfs(lp, rp-1, pairs, s[1:], path, res) self.dfs(lp, rp, pairs-1, s[1:], path + [s[0]], res) else: self.dfs(lp, rp, pairs, s[1:], path + [s[0]], res)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://kaihaoli.github.io/tags/bfs/"}]},{"title":"Graph Cycle","slug":"graph-cycle","date":"2018-12-01T15:35:11.000Z","updated":"2018-12-01T15:59:39.103Z","comments":true,"path":"2018/12/01/graph-cycle/","link":"","permalink":"http://kaihaoli.github.io/2018/12/01/graph-cycle/","excerpt":"","text":"Detect the CycleFind if a cycle exits in a graph 261. Graph Valid Tree Undirected Graph: Union Find, DFS, BFS Solution1. Union Find graph is represented by edges!!! signal to use union find!!! tree is connected graph without cycle, but graph can be seperate clusters!!!1234567891011121314151617181920212223class Solution(object): def validTree(self, n, edges): root = range(n) self.cnt = n def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] def union(x, y): rootx = find(x) rooty = find(y) if rootx != rooty: root[rootx] = rooty self.cnt -= 1 return True return False for i, j in edges: if not union(i, j): return False return self.cnt == 1 solution2. DFS for undirected graph, it’s better to use Union Find and BFS prev node !!!! 3 states for visited: 0-no visited，1-visiting，2-visited 1234567891011121314151617181920212223242526272829class Solution(object): def validTree(self, n, edges): graph = collections.defaultdict(set) for i, j in edges: graph[i].add(j) graph[j].add(i) visited = [0] * n if not self.dfs(-1, 0, visited, graph): return False return (0 not in visited) def dfs(self, prev, i, visited, graph): if visited[i] == 2: return True if visited[i] == 1: return False visited[i] = 1 for nei in graph[i]: if nei == prev: continue if not self.dfs(i, nei, visited, graph): return False visited[i] = 2 return True Solution3. BFS prev node to avoid edge(a, b) and (b, a) cycle !!!12345678910111213141516171819class Solution(object): def validTree(self, n, edges): graph = collections.defaultdict(set) for i, j in edges: graph[i].add(j) graph[j].add(i) visited = [0] * n queue = collections.deque([(0, -1)]) while queue: node, prev = queue.popleft() visited[node] = 1 for nei in graph[node]: if nei == prev: continue if visited[nei]: return False queue.append((nei, node)) return sum(visited) == n Directed graph207. Course Schedule Directed graph: DFS, BFS Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. Solution1. DFSvisited三种状态，-1正在visit, 0未visit, 1已经visit Why 三种状态？or 两种状态？ 两种状态，做DFS时间复杂度是O(n^2) 引入第三种状态，可以避免访问已经访问过不构成环的点，O(n) 1234567891011121314151617181920212223242526272829# Time : O(n)class Solution(object): def canFinish(self, numCourses, prerequisites): graph = collections.defaultdict(set) for c, p in prerequisites: graph[c].add(p) visited = [0] * numCourses for i in xrange(numCourses): if not self.dfs(i, visited, graph): return False return True def dfs(self, i, visited, graph): if visited[i] == 1: return True if visited[i] == -1: return False visited[i] = -1 for edge in graph[i]: if not self.dfs(edge, visited, graph): return False visited[i] = 1 return True Solution2. BFS 有向图的BFS算法还是比较有意思的，基于indegree的！ Indegree, 每次访问入度为0的节点，并删掉所在边，最后sum(indegree) == 0! 12345678910111213141516class Solution(object): def canFinish(self, numCourses, prerequisites): graph = [[] for _ in xrange(numCourses)] indegree = [0] * numCourses for i, j in prerequisites: graph[j].append(i) indegree[i] += 1 queue = [i for i in xrange(numCourses) if indegree[i] == 0] while queue: course = queue.pop(0) for n in graph[course]: indegree[n] -= 1 if indegree[n] == 0: queue.append(n) return sum(indegree) == 0 Graph =&gt; Tree684. Redundant Connection union find123456789101112131415161718class Solution(object): def findRedundantConnection(self, edges): n = len(edges) root = range(n+1) def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] for src, dst in edges: root1 = find(src) root2 = find(dst) if root1 != root2: root[root1] = root2 else: return [src, dst] 685. Redundant Connection II1234567891011121314151617181920212223242526272829303132class Solution(object): def findRedundantDirectedConnection(self, edges): candidates = [] n = len(edges) parent = &#123;&#125; for i, (p, c) in enumerate(edges): if c in parent: candidates = [(parent[c], c), (p, c)] edges[i][0] = 0 else: parent[c] = p # candiates is none =&gt; only cycle case # else =&gt; indegree &gt; 1 case root = range(n+1) def find(x): if x == root[x]: return x root[x] = find(root[x]) return root[x] for p, c in edges: root1 = find(c) root2 = find(p) if root1 == root2: if not candidates: return [p, c] else: return candidates[0] root[root1] = root2 return candidates[1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://kaihaoli.github.io/tags/graph/"}]},{"title":"DP - Sequence Adjacent Element","slug":"dp-sequence-adjacent","date":"2018-11-27T16:26:04.000Z","updated":"2018-11-28T05:07:28.489Z","comments":true,"path":"2018/11/27/dp-sequence-adjacent/","link":"","permalink":"http://kaihaoli.github.io/2018/11/27/dp-sequence-adjacent/","excerpt":"","text":"256. Paint House1234567891011121314class Solution(object): def minCost(self, costs): if not costs: return 0 n = len(costs) dp = [[0] * 3 for _ in range(n)] for j in range(3): dp[0][j] = costs[0][j] for i in range(1, n): for j in range(3): dp[i][j] = costs[i][j] + min(dp[i-1][j-1], dp[i-1][j-2]) return min(dp[-1]) 265. Paint House II1234567891011121314class Solution(object): def minCostII(self, costs): if not costs: return 0 n, k = len(costs), len(costs[0]) dp = [[0] * k for _ in range(n)] for j in range(k): dp[0][j] = costs[0][j] for i in range(1, n): for j in range(k): dp[i][j] = costs[i][j] + min(dp[i-1][:j] + dp[i-1][j+1:]) return min(dp[-1]) 276. Paint Fence123456789101112class Solution(object): def numWays(self, n, k): if n == 0 or k == 0: return 0 dp = [[0] * 2 for _ in range(n)] dp[0][0] = k dp[0][1] = 0 for i in range(1, n): dp[i][0] = (dp[i-1][0] + dp[i-1][1]) * (k-1) dp[i][1] = dp[i-1][0] return sum(dp[-1]) 198. House Robber12345678910111213class Solution(object): def rob(self, nums): if not nums: return 0 n = len(nums) dp1 = [0] * n # Stole dp2 = [0] * n # Not Stole dp1[0] = nums[0] for i in range(1, n): dp1[i] = dp2[i-1] + nums[i] dp2[i] = max(dp1[i-1], dp2[i-1]) return max(dp1[-1], dp2[-1]) 213. House Robber II12345678910111213141516171819class Solution(object): def rob(self, nums): n = len(nums) if n &lt;= 1: return sum(nums) prev = rob1 = 0 for num in nums[1:]: temp = rob1 rob1 = max(prev + num, rob1) prev = temp prev = rob2 = 0 for num in nums[:-1]: temp = rob2 rob2 = max(prev + num, rob2) prev = temp return max(rob1, rob2)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"Calculator","slug":"topic-calculator","date":"2018-11-23T22:46:58.000Z","updated":"2018-11-23T22:48:52.191Z","comments":true,"path":"2018/11/23/topic-calculator/","link":"","permalink":"http://kaihaoli.github.io/2018/11/23/topic-calculator/","excerpt":"","text":"150. Evaluate Reverse Polish Notation Stack, Reverse Polish Notation 123456789101112131415161718192021class Solution(object): def evalRPN(self, tokens): stack = [] for token in tokens: if token in \"+-*/\": n2 = stack.pop() n1 = stack.pop() if token == '+': temp = n1 + n2 elif token == '-': temp = n1 - n2 elif token == '*': temp = n1 * n2 else: temp = n1 / n2 if n1 * n2 &lt; 0 and n1 % n2 != 0: temp += 1 stack.append(temp) else: stack.append(int(token)) return stack.pop()","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"stack","slug":"stack","permalink":"http://kaihaoli.github.io/tags/stack/"},{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"Serialization","slug":"topic-serialization","date":"2018-11-17T21:32:56.000Z","updated":"2018-11-17T23:31:36.917Z","comments":true,"path":"2018/11/17/topic-serialization/","link":"","permalink":"http://kaihaoli.github.io/2018/11/17/topic-serialization/","excerpt":"","text":"Tree StringWhen you use network to transport a tree or a graph, you can not pass the momery. So usually you have to use a string to transport! Binary Search Tree Complete Tree Full Tree297. Serialize and Deserialize Binary Tree1234567891011121314151617181920212223242526272829class Codec: def serialize(self, root): res = [] def dfs(node): if not node: res.append(\"None\") return res.append(str(node.val)) dfs(node.left) dfs(node.right) dfs(root) return ','.join(res) def deserialize(self, data): def helper(q): if tokens[0] == \"None\": q.popleft() return None root = TreeNode(q.popleft()) root.left = helper(q) root.right = helper(q) return root tokens = collections.deque(data.split(',')) root = helper(tokens) return root Tree Serialization426. Convert Binary Search Tree to Sorted Doubly Linked List O(n) extra space 1234567891011121314151617181920# Time : O(n), Space : O(n)class Solution(object): def treeToDoublyList(self, root): if not root: return None res = [] self.inOrder(root, res) n = len(res) for i in xrange(n): res[i].right = res[i+1] if i &lt; n-1 else res[0] res[i].left = res[i-1] return res[0] def inOrder(self, root, res): if not root: return self.inOrder(root.left, res) res.append(root) self.inOrder(root.right, res) in-place 123456789101112131415161718192021222324# Time : O(n), Space : O(1)class Solution(object): def treeToDoublyList(self, root): if not root: return None self.prev = None self.head = None self.inOrder(root) self.prev.right = self.head self.head.left = self.prev return self.head def inOrder(self, root): if not root: return self.inOrder(root.left) if self.prev: root.left = self.prev self.prev.right = root else: self.head = root self.prev = root self.inOrder(root.right) Tree De-Serialization We can NOT construct a Binary Tree using postorder and preorder 106. Construct Binary Tree from Inorder and Postorder Traversal Global Question divide to sub problem 1234567891011class Solution(object): def buildTree(self, inorder, postorder): if not inorder or not postorder: return None root = TreeNode(postorder.pop()) inorderindex = inorder.index(root.val) root.right= self.buildTree(inorder[inorderindex+1:], postorder) root.left = self.buildTree(inorder[:inorderindex], postorder) return root 105. Construct Binary Tree from Preorder and Inorder Traversal123456789class Solution(object): def buildTree(self, preorder, inorder): if (not preorder) or (not inorder): return None root=TreeNode(preorder.pop(0)) ro=inorder.index(root.val) root.left=self.buildTree(preorder,inorder[:ro]) root.right=self.buildTree(preorder,inorder[ro+1:]) return root Construct Binary Tree from Inorder and level Order114. Flatten Binary Tree to Linked List123456789101112131415161718class Solution(object): def flatten(self, root): if not root: return if not root.left: self.flatten(root.right) return self.flatten(root.left) self.flatten(root.right) cur = root.left while cur.right: cur = cur.right cur.right = root.right root.right = root.left root.left = None","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"},{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"},{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"Monotone Stack","slug":"stack-monotone","date":"2018-11-16T03:52:01.000Z","updated":"2018-12-06T16:15:06.094Z","comments":true,"path":"2018/11/15/stack-monotone/","link":"","permalink":"http://kaihaoli.github.io/2018/11/15/stack-monotone/","excerpt":"","text":"Next Greater Element496. Next Greater Element I12345678910111213141516class Solution(object): def nextGreaterElement(self, findNums, nums): dic = &#123;&#125; stack = [] for num in nums: while stack and num &gt; stack[-1]: dic[stack.pop()] = num stack.append(num) res = [] for num in findNums: if num not in dic: res.append(-1) else: res.append(dic[num]) return res 503. Next Greater Element II1234567891011121314class Solution(object): def nextGreaterElements(self, nums): n = len(nums) res = [-1] * n stack = [] for i in range(n): while stack and nums[stack[-1]] &lt; nums[i]: res[stack.pop()] = nums[i] stack.append(i) for i in range(n): while stack and nums[stack[-1]] &lt; nums[i]: res[stack.pop()] = nums[i] return res 84. Largest Rectangle in HistogramSolution1. middle heart open flowerfor each index i, walk right to find the left border and right border.Time = O($n^2$) Solution2. Stack Use a Stack to store all the indices of the columns that form an ascending order stack that stores the indeices in ascending order. [1, 5, 6 When scanning the element with index = 4, M[4] = 2 &lt; M[3] = 6, so we keep checking left column of index 4, and calculate the area of index 3,2 and pop them out of the stack, after this step, the stack is [1, 5 Priciple, to maintain the stack to make sure the colums shose indices are stored in the stack from an sacending order. TimeO(n), because every single element can only be inserted and popped out of the stack once and only once. 1234567891011121314class Solution(object): def largestRectangleArea(self, heights): stack = [] hs = heights + [0] i = 0 res = 0 while i &lt;= len(hs)-1: if not stack or hs[stack[-1]] &lt; hs[i]: stack.append(i) i += 1 else: idx = stack.pop() res = max(res, hs[idx] * (i if not stack else (i-stack[-1]-1)) ) return res 42. Trapping Rain Water12345678910111213141516class Solution(object): def trap(self, height): n = len(height) stack = [] res = 0 i = 0 while i &lt;= n-1: if not stack or height[i] &lt;= height[stack[-1]]: stack.append(i) i += 1 else: t = stack.pop() if not stack: continue res += (min(height[stack[-1]], height[i]) - height[t]) * (i - stack[-1] - 1) return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"stack","slug":"stack","permalink":"http://kaihaoli.github.io/tags/stack/"}]},{"title":"Interval Problem","slug":"topic-interval","date":"2018-11-14T17:14:48.000Z","updated":"2018-12-05T03:23:27.283Z","comments":true,"path":"2018/11/14/topic-interval/","link":"","permalink":"http://kaihaoli.github.io/2018/11/14/topic-interval/","excerpt":"","text":"Range370. Range AdditionTrade off for Update and Query! O(1) for update and O(n) for Query O(n) for update and O(1) for Query We only care about the intervals start and end!!! 1234567891011class Solution(object): def getModifiedArray(self, length, updates): nums = [0] * length for start, end, diff in updates: nums[start] += diff if end &lt; length - 1: nums[end+1] -= diff for i in range(1, length): nums[i] += nums[i-1] return nums Overlap How to define two intervals overapped? A.end &gt; B.start B.end &gt; A.start Why we always sort by start or end at first?252. Meeting Rooms1234567class Solution: def canAttendMeetings(self, intervals): intervals.sort(key=lambda x:x.start) for i in range(1, len(intervals)): if intervals[i].start &lt; intervals[i-1].end: return False return True 253. Meeting Rooms II12345678910111213class Solution(object): def minMeetingRooms(self, intervals): times = [] for interval in intervals: times.append((interval.start, 1)) times.append((interval.end, 0)) times.sort() res = 0 cnt = 0 for time, fg in times: cnt += 1 if fg == 1 else -1 res = max(res, cnt) return res Follow Up : Return Max Overlapped Interval Operations56. Merge Intervals123456789101112131415161718192021# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): if not intervals: return [] intervals.sort(key = lambda x:x.start) n = len(intervals) stack = [intervals[0]] for i in range(1, n): start, end = intervals[i].start, intervals[i].end if start &lt;= stack[-1].end: stack[-1].end = max(stack[-1].end, end) else: stack.append(intervals[i]) return stack 57. Insert Interval O(n)1234567891011121314151617181920class Solution(object): def insert(self, intervals, newInterval): n = len(intervals) res = [] i = 0 while i &lt; n and newInterval.start &gt; intervals[i].end: res.append(intervals[i]) i += 1 while i &lt; n and intervals[i].start &lt;= newInterval.end: newInterval.start = min(intervals[i].start, newInterval.start) newInterval.end = max(intervals[i].end, newInterval.end) i += 1 res.append(newInterval) while i &lt; n: res.append(intervals[i]) i += 1 return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"System Design Introduction","slug":"system-design-intro","date":"2018-11-14T03:10:33.000Z","updated":"2018-11-14T14:17:25.923Z","comments":true,"path":"2018/11/13/system-design-intro/","link":"","permalink":"http://kaihaoli.github.io/2018/11/13/system-design-intro/","excerpt":"","text":"System/Solution/Product Design Design a Twitter? Design a Uber? Design a short URL service.Product -&gt; functionalities/use cases -&gt; Architecture TopicStorage Distributed file system Distributed databaseComputation Batch Processing Streaming ProcessingWeb Application Data Center Cluster Rack Node/Server(many computers)Distributed File System Use file system interfaces to manage your data (files and directions) Data is distributed in many machies Examples: GFS(Google File System), HDFS, Ceph FS, GlusterFS, MapR FS… When to use a DFS? Durability Hadoop Distributed File system Key features/assumptions Scale up to 100+ PB of storage and a single cluster of several thousand servers,supporting close to a billion files and blocks Designed to run on commodity hardware some components of HDFS is always non-functional Architecture","categories":[{"name":"System Design","slug":"System-Design","permalink":"http://kaihaoli.github.io/categories/System-Design/"}],"tags":[]},{"title":"String - Substring","slug":"string-substring","date":"2018-11-10T15:01:08.000Z","updated":"2018-11-15T15:54:09.557Z","comments":true,"path":"2018/11/10/string-substring/","link":"","permalink":"http://kaihaoli.github.io/2018/11/10/string-substring/","excerpt":"","text":"is Substring28. Implement strStr() input : 2 stringSolution1. Naive Time : O(m * n) try every possible start index in haystack 1234567class Solution(object): def strStr(self, haystack, needle): m, n = len(needle), len(haystack) for i in xrange(n-m+1): if haystack[i:i+m] == needle: return i return -1 Solution2. KMP Time : O(m + n) know the basic idea of KMP and can walk through some test cases123456789101112131415161718192021222324252627class Solution(object): def getNext(self, pattern): m = len(pattern) next = [0] * m k = 0 for i in xrange(1, m): while k &gt; 0 and pattern[k] != pattern[i]: k = next[k-1] if pattern[k] == pattern[i]: k += 1 next[i] = k return next def strStr(self, haystack, needle): if not needle: return 0 next = self.getNext(needle) n = len(haystack) p = 0 for i in xrange(n): while p &gt; 0 and needle[p] != haystack[i]: p = next[p-1] if needle[p] == haystack[i]: p += 1 if p == len(needle): return i-len(needle)+1 return -1 Solution3. Robin-Karp Time : O(m+n) Principle: if we can hash the short string to a hashed value (e.g. integer, which is unique). Then we can just compare each substring of s1’s hashed value and compare it with s2’s hash value. Assumption: only lower case letter (base = 26 a–z) Each time you slide the window, add right, delete left and times 26 in the middle!!! Sliding WindowA string has $n^2$ substrings! These type of question ask you to find a subtring meet some certain condition! Slinding Window + Hash Table!!!3. Longest Substring Without Repeating When to move the right pointer and when to move the left pointer use hashset 1234567891011121314class Solution(object): def lengthOfLongestSubstring(self, s): visited = set() left = right = 0 res = 0 while right &lt; len(s): if s[right] not in visited: visited.add(s[right]) res = max(res, right-left+1) right += 1 else: visited.remove(s[left]) left += 1 return res 159. Longest Substring with At Most Two Distinct Characters1234567891011121314151617181920212223class Solution(object): def lengthOfLongestSubstringTwoDistinct(self, s): dic = &#123;&#125; n = len(s) cnt = 0 left = right = 0 res = 0 while right &lt; n: if s[right] in dic: dic[s[right]] += 1 right += 1 else: while cnt &gt;= 2: dic[s[left]] -= 1 if dic[s[left]] == 0: cnt -= 1 del dic[s[left]] left += 1 dic[s[right]] = 1 cnt += 1 right += 1 res = max(res, right-left) return res 340. Longest Substring with At Most K Distinct Characters12345678910111213141516171819class Solution(object): def lengthOfLongestSubstringKDistinct(self, s, k): chars = [0] * 256 start = 0 res = cnt = 0 for i in xrange(len(s)): idx = ord(s[i]) if chars[idx] == 0: cnt += 1 chars[idx] += 1 while cnt &gt; k: idx = ord(s[start]) chars[idx] -= 1 if chars[idx] == 0: cnt -= 1 start += 1 res = max(res, i-start+1) return res 76. Minimum Window Substring it will be easy to let right pointer be the iteration pointer cnt is the flag to show whether it satisfies the condition1234567891011121314151617181920212223242526class Solution(object): def minWindow(self, s, t): tmap = &#123;&#125; for c in t: tmap[c] = tmap.get(c, 0) + 1 cnt = len(t) start = 0 res, ret = len(s)+1, \"\" for i in xrange(len(s)): if s[i] in tmap: tmap[s[i]] -= 1 if tmap[s[i]] &gt;= 0: cnt -= 1 while cnt == 0: win = i-start+1 if win &lt; res: res = win ret = s[start:i+1] if s[start] in tmap: if tmap[s[start]] &gt;= 0: cnt += 1 tmap[s[start]] += 1 start += 1 return ret 438. Find All Anagrams in a String1234567891011121314151617181920212223242526272829303132333435class Solution(object): def findAnagrams(self, s, p): if len(s) &lt; len(p): return [] dic = collections.defaultdict(int) for ch in p: dic[ch] += 1 cnt = len(dic.keys()) k = len(p) for i in range(k): if s[i] in dic: dic[s[i]] -= 1 if dic[s[i]] == 0: cnt -= 1 res = [] if cnt == 0: res.append(0) for i in range(k, len(s)): if s[i] in dic: dic[s[i]] -= 1 if dic[s[i]] == 0: cnt -= 1 if s[i-k] in dic: dic[s[i-k]] += 1 if dic[s[i-k]] == 1: cnt += 1 if cnt == 0: res.append(i-k+1) return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"}]},{"title":"Input are Points","slug":"topic-points","date":"2018-11-09T21:11:54.000Z","updated":"2018-11-16T03:53:41.323Z","comments":true,"path":"2018/11/09/topic-points/","link":"","permalink":"http://kaihaoli.github.io/2018/11/09/topic-points/","excerpt":"","text":"Lies inside or outsidePoint Lies inside or outside a polygon Draw a horizontal line to the right of each point and extend it to infinity Count the number of times the line intersects with polygon edges. A point is inside the polygon if either count of intersections is odd or point lies on an edge of polygon. If none of the conditions is true, then point lies outside. TODO939. Minimum Area RectangleGiven some points, please calculate the minimum Rectangle.Height and width must be parallel to axes12345678910111213141516171819class Solution(object): def minAreaRect(self, points): pset = set() for x, y in points: pset.add((x, y)) n = len(points) res = float('inf') for i in range(n): for j in range(i+1, n): x1, y1 = points[i] x2, y2 = points[j] if x1 == x2 or y1 == y2: continue if (x1, y2) not in pset or (x2, y1) not in pset: continue res = min(res, abs(x2-x1) * abs(y2-y1)) return 0 if res == float('inf') else res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"String Parenthesis","slug":"string-parenthesis","date":"2018-11-09T03:28:02.000Z","updated":"2018-11-10T03:31:59.163Z","comments":true,"path":"2018/11/08/string-parenthesis/","link":"","permalink":"http://kaihaoli.github.io/2018/11/08/string-parenthesis/","excerpt":"","text":"678. Valid Parenthesis String If you use stack to solve this question, it will be complex to handle different cases! If you use dfs to search if is valid, it will be time consuming! 12345678910111213141516class Solution(object): def checkValidString(self, s): low = high = 0 for ch in s: if ch == '(': low += 1 high += 1 elif ch == ')': low = max(0, low-1) high -= 1 if high &lt; 0: return False else: # \"*\" low = max(0, low-1) high += 1 return low == 0 22. Generate Parentheses12345678910111213141516class Solution(object): def generateParenthesis(self, n): res = [] self.dfs(0, 0, n, [], res) return res def dfs(self, left, right, n, path, res): if right == n: res.append(''.join(path)) return if left &lt; n: self.dfs(left + 1, right, n, path + ['('], res) if right &lt; left: self.dfs(left, right + 1, n, path + [')'], res) Follow up : 3 {}, 2(), 1[]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://kaihaoli.github.io/tags/dfs/"},{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"}]},{"title":"Tree Definition","slug":"tree-definition","date":"2018-11-06T14:23:54.000Z","updated":"2018-11-06T15:56:31.637Z","comments":true,"path":"2018/11/06/tree-definition/","link":"","permalink":"http://kaihaoli.github.io/2018/11/06/tree-definition/","excerpt":"","text":"Definition of Tree at most two children node 123456# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None Application Social networks analysis Information indexing Information compression 388. Longest Absolute File Path use Stack to simulate the traversal of file system 1234567891011121314151617181920212223class Solution: def lengthLongestPath(self, input): def countT(s): cnt = 0 for ch in s: if ch == '\\t': cnt += 1 else: return cnt return cnt dirs = input.split('\\n') res = 0 stack = [] for i in range(len(dirs)): path = dirs[i] n = countT(path) while n &lt; len(stack): stack.pop() stack.append(path[n:]) if '.' in stack[-1]: res = max(res, len('/'.join(stack))) return res Terms Balanced Binary TreeBalanced Binary Tree is commonly defined as a binary tree in which the depth of the left and right subtrees of every node differ by 1 or less Complete Binary TreeComplete Binary Tree is a banary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Binary Search TreeBinary Search Tree is for every sigle node in the tree, the values in its left subtree are all smaller than its value, and the values in its right subtree are all larger than its value. 919. Complete Binary Tree InserterSolution1. Array For Complete Binary Search Tree, we can use an array to save all the node index! Then we can find its parent using the index relation! 12345678910111213141516171819202122232425262728class CBTInserter: # Space : O(n) n is the number of the nodes def __init__(self, root): self.nodes = [] queue = collections.deque([root]) while queue: node = queue.popleft() self.nodes.append(node) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # Time : O(1) def insert(self, v): n = len(self.nodes) parent = self.nodes[(n - 1) // 2] node = TreeNode(v) self.nodes.append(node) if n % 2 == 1: parent.left = node else: parent.right = node return parent.val def get_root(self): return self.nodes[0] Solution2. Deque Have the Same time and space complexity, but actually use half spaces than sol1!!12345678910111213141516171819202122232425262728class CBTInserter: def __init__(self, root): self.root = root self.deque = collections.deque() queue = collections.deque([root]) while queue: node = queue.popleft() if not node.left or not node.right: self.deque.append(node) if node.left: queue.append(node.left) if node.right: queue.append(node.right) def insert(self, v): node = TreeNode(v) parent = self.deque[0] if not parent.left: parent.left = node else: parent.right = node self.deque.popleft() self.deque.append(node) return parent.val def get_root(self): return self.root 222. Count Complete Tree Nodes123456789101112131415161718192021class Solution: def countNodes(self, root): if not root: return 0 left = self.getDepth(root.left) right = self.getDepth(root.right) if left == right: return (2**left) + self.countNodes(root.right) else: return (2**right) + self.countNodes(root.left) def getDepth(self, root): if not root: return 0 cnt = 0 cur = root while cur: cur = cur.left cnt += 1 return cnt Follow Up Given the key n, binary tree key is [1, 2, 3, 4 …], how to check if the node with key n in the complete binary tree ?Time : O(log n) Can you count the number of nodes in complete binary tree, based on previous question?Binary Search + Previous Question. Time ($(logn)^2$)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"Two Pinters","slug":"topic-two-pointers","date":"2018-11-05T01:06:32.000Z","updated":"2018-11-07T17:11:27.045Z","comments":true,"path":"2018/11/04/topic-two-pointers/","link":"","permalink":"http://kaihaoli.github.io/2018/11/04/topic-two-pointers/","excerpt":"","text":"Same Direction27. Remove Element left pointer represents the postion that next valid result will be put in!!123456789# Time : O(n), Sapce : O(1)class Solution(object): def removeElement(self, nums, val): left = 0 for i in range(len(nums)): if nums[i] != val: nums[left] = nums[i] left += 1 return left 26. Remove Duplicates from Sorted Array first pointer represents the last position in the result!123456789101112# Time : O(n), Sapce : O(1)class Solution(object): def removeDuplicates(self, nums): if not nums: return 0 first = 0 for i in range(1, len(nums)): if nums[i] != nums[first]: first += 1 nums[first] = nums[i] return first+1 80. Remove Duplicates from Sorted Array II small trick: 1. start interation from index 2, 2. comprare with the element with only the second last element!12345678910111213# Time : O(n), Sapce : O(1)class Solution(object): def removeDuplicates(self, nums): n = len(nums) if n &lt;= 2: return n first = 1 for i in range(2, n): if nums[i] != nums[first-1]: first += 1 nums[first] = nums[i] return first + 1 Two Sequence88. Merge Sorted Array two pointers 1234567891011121314151617class Solution: def merge(self, nums1, m, nums2, n): p1, p2 = m - 1, n - 1 p = m + n - 1 while p1 &gt;= 0 and p2 &gt;= 0: if nums1[p1] &gt; nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 while p2 &gt;= 0: nums1[p] = nums2[p2] p -= 1 p2 -= 1","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"String Subsequence","slug":"string-subsequence","date":"2018-11-04T03:45:40.000Z","updated":"2018-12-10T02:12:20.780Z","comments":true,"path":"2018/11/03/string-subsequence/","link":"","permalink":"http://kaihaoli.github.io/2018/11/03/string-subsequence/","excerpt":"","text":"For a string with length n, it has $2^n$ Subsequences Check a string is or not a subsequence of another string (a litte greedy)392. Is Subsequence Time : O(|t|) Solution1. Recursion123456789class Solution: def isSubsequence(self, s, t): if not s: return True for i in range(len(t)): if t[i] == s[0]: return self.isSubsequence(s[1:], t[i+1:]) return False Solution2. Iteration Two Pointer and Greedy123456789class Solution: def isSubsequence(self, s, t): p = 0 for i in range(len(t)): if p &gt;= len(s): break if s[p] == t[i]: p += 1 return p == len(s) Follow up : multiple stringsIf there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. intuitive way is to precalculate something in T to speed up the query Precalculate : O(n), Query : (mlogn) 123456789101112131415161718192021222324252627282930class Solution: def isSubsequence(self, s, t): indices = collections.defaultdict(list) for i, ch in enumerate(t): indices[ch].append(i) prev = -1 for i in range(len(s)): if s[i] not in indices: return False idx = self.bSearch(prev, indices[s[i]]) if idx == -1: return False prev = idx return True def bSearch(self, prev, nums): if prev &gt;= nums[-1]: return -1 start, end = 0, len(nums) - 1 while start &lt; end: mid = start + (end - start) // 2 if nums[mid] &gt; prev: # Mistake2 : we should find greater than previous index CANNOT equal end = mid else: start = mid + 1 return nums[start] if nums[start] &gt; prev else -1 # Mistake1 : forget to consider the index may not in the nums!!! 792. Number of Matching SubsequencesSolution1. Binary Search + Hash Table Online Algorithms, Precalculate String Data Structure : Hash Table &lt;charater, indices&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def numMatchingSubseq(self, S, words): # Time O(n) indices = [[] for _ in range(26)] for i, ch in enumerate(S): indices[ord(ch)-ord('a')].append(i) cnt = 0 mdic = &#123;&#125; for word in words: if word in mdic: cnt += mdic[word] continue if self.isMatch(indices, word): mdic[word] = 1 cnt += 1 else: mdic[word] = 0 return cnt # Time : O(mlog n) n is the length of S, m is the length of word def isMatch(self, indices, word): prev = -1 for ch in word: idx = self.bSearch(prev, indices[ord(ch)-ord('a')]) if idx == -1: return False prev = idx return True def bSearch(self, prev, nums): if not nums or prev &gt;= nums[-1]: return -1 start, end = 0, len(nums) - 1 while start &lt; end: mid = start + (end - start) // 2 if nums[mid] &gt; prev: end = mid else: start = mid + 1 return nums[start] if nums[start] &gt; prev else -1 Solution2. Next Letter Pointer Offline Algorithms, Precalculate words 1234567891011121314151617181920class Solution: def numMatchingSubseq(self, S, words): indices = [[] for _ in range(26)] for word in words: indices[ord(word[0]) - ord('a')].append(word[1:]) cnt = 0 for ch in S: cans = indices[ord(ch)-ord('a')] newCans = [] for can in cans: if len(can) == 0: cnt += 1 continue if can[0] == ch: newCans.append(can[1:]) else: indices[ord(can[0])-ord('a')].append(can[1:]) indices[ord(ch)-ord('a')] = newCans return cnt 727. Minimum Window Subsequence123456789101112131415161718192021class Solution(object): def minWindow(self, S, T): n = len(S) # Must be the start index of the results!!! cur = [i if S[i] == T[0] else -1 for i in range(n)] for j in xrange(1, len(T)): last = -1 new = [-1] * n for i, ch in enumerate(S): if last &gt;= 0 and ch == T[j]: new[i] = last if cur[i] &gt;= 0: last = cur[i] cur = new start, end = 0, n for e, s in enumerate(cur): if s &gt;= 0 and e - s &lt; end - start: start, end = s, e return S[start:end+1] if end != n else \"\"","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"}]},{"title":"DP Bag","slug":"dp-bag","date":"2018-11-02T14:52:18.000Z","updated":"2018-11-29T03:32:01.546Z","comments":true,"path":"2018/11/02/dp-bag/","link":"","permalink":"http://kaihaoli.github.io/2018/11/02/dp-bag/","excerpt":"","text":"279. Perfect SquaresSolution1. DP - TLE Time O($n\\sqrt{n}$), Space: O(n) have no idea why works in python2, but TLE in python3 1234567891011class Solution: def numSquares(self, n): dp = [float('inf')] * (n+1) dp[0] = 0 for i in range(1, n+1): j = 1 while (j * j &lt;= i): if dp[i-j*j] + 1 &lt; dp[i]: dp[i] = dp[i-j*j] + 1 j += 1 return dp[-1] Solution2. BFS Consider a graph which consists of number 0, 1,…,n as its nodes. Node j is connected to node i via an edge if and only if either j = i + (a perfect square number) or i = j + (a perfect square number). Starting from node 0, do the breadth-first search. If we reach node n at step m, then the least number of perfect square numbers which sum to n is m. Here since we have already obtained the perfect square numbers, we have actually finished the search at step 1.123456789101112131415161718192021class Solution: def numSquares(self, n): cans = [] i = 1 while i * i &lt;= n: cans.append(i * i) i += 1 queue = [n] level = 0 while queue: level += 1 nqueue = set() for remain in queue: for can in cans: if can == remain: return level if can &gt; remain: break nqueue.add(remain-can) queue = list(nqueue) 322. Coin Change1234567891011121314class Solution(object): def coinChange(self, coins, amount): if amount == 0: return 0 dp = [float('inf')] * (amount+1) dp[0] = 0 for i in xrange(1, amount+1): for coin in coins: if i-coin &gt;= 0: dp[i] = min(dp[i], dp[i-coin]+1) return -1 if dp[-1] == float('inf') else dp[-1] Count518. Coin Change 2 Why use for loop in this order??? coin first, then amount?12345678class Solution(object): def change(self, amount, coins): dp = [0] * (amount+1) dp[0] = 1 for coin in coins: for i in range(coin, amount+1): dp[i] += dp[i-coin] return dp[-1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"},{"name":"TODO","slug":"TODO","permalink":"http://kaihaoli.github.io/tags/TODO/"}]},{"title":"String Pattern","slug":"string-pattern","date":"2018-10-31T22:08:33.000Z","updated":"2018-11-11T21:56:59.002Z","comments":true,"path":"2018/10/31/string-pattern/","link":"","permalink":"http://kaihaoli.github.io/2018/10/31/string-pattern/","excerpt":"","text":"290. Word Pattern Why we need Two HashTable? 123456789101112131415161718class Solution: def wordPattern(self, pattern, str): words = str.split() m, n = len(pattern), len(words) if m != n: return False dic = &#123;&#125; used = set() for i in range(m): if pattern[i] not in dic: if words[i] in used: return False dic[pattern[i]] = words[i] used.add(words[i]) else: if dic[pattern[i]] != words[i]: return False return True 291. Word Pattern II1234567891011121314151617181920212223242526272829class Solution: def wordPatternMatch(self, pattern, str): return self.isMatch(pattern, str, &#123;&#125;, set()) def isMatch(self, pattern, s, dic, used): if not pattern and not s: return True elif not pattern or not s: return False ch = pattern[0] if ch in dic: word = dic[ch] n = len(word) if word == s[:n]: return self.isMatch(pattern[1:], s[n:], dic, used) else: return False else: for i in range(len(s)): if s[:i+1] in used: continue dic[ch] = s[:i+1] used.add(s[:i+1]) if self.isMatch(pattern[1:], s[i+1:], dic, used): return True used.remove(s[:i+1]) del dic[ch] return False 809. Expressive Words pairs &lt;character, counter&gt; 12345678910111213141516171819202122232425262728293031323334class Solution: def expressiveWords(self, S, words): pairs = [] for i in range(len(S)): if not pairs or S[i] != pairs[-1][0]: pairs.append([S[i], 1]) else: pairs[-1][1] += 1 cnt = 0 for word in words: if self.isExtended(pairs, word): cnt += 1 return cnt def isExtended(self, pairs, word): i = 0 for j in range(len(pairs)): ch, cnt = pairs[j] if cnt &lt; 3: while cnt: if i &gt;= len(word) or ch != word[i]: return False cnt -= 1 i += 1 else: ncnt = 0 while i &lt; len(word) and word[i] == ch: i += 1 ncnt += 1 if ncnt == 0 or ncnt &gt; cnt: return False return i == len(word) 890. Find and Replace Pattern123456789101112131415161718192021222324class Solution(object): def findAndReplacePattern(self, words, pattern): res = [] for word in words: if self.isMatched(word, pattern): res.append(word) return res def isMatched(self, word, pattern): mapw = &#123;&#125; mapp = &#123;&#125; for ch1, ch2 in zip(word, pattern): if ch1 not in mapw: mapw[ch1] = ch2 else: if mapw[ch1] != ch2: return False if ch2 not in mapp: mapp[ch2] = ch1 else: if mapp[ch2] != ch1: return False return True","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"}]},{"title":"DP - Matrix","slug":"dp-matrix","date":"2018-10-30T21:10:18.000Z","updated":"2018-11-27T22:16:32.041Z","comments":true,"path":"2018/10/30/dp-matrix/","link":"","permalink":"http://kaihaoli.github.io/2018/10/30/dp-matrix/","excerpt":"","text":"Count62. Unique Paths12345678910111213# Time : O(mn), Space : O(mn)class Solution: def uniquePaths(self, m, n): dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 123456789# Time : O(mn), Space : O(n)class Solution: def uniquePaths(self, m, n): dp = [1] * n for i in range(1, m): for j in range(1, n): dp[j] += dp[j-1] return dp[-1] Follow Up Given three points in the matrix, find the path number that traverse these 3 points do it seperated three matrix, then add together How to validate the three points? If give you a “H”, ask your path have to cross “H” 63. Unique Paths II12345678910111213141516171819class Solution: def uniquePathsWithObstacles(self, obstacleGrid): if not obstacleGrid: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [0] * (n + 1) dp[0] = 1 for i in range(n): dp[i+1] = 0 if obstacleGrid[0][i] else dp[i] for i in range(1, m): if obstacleGrid[i][0] == 1: dp[1] = 0 for j in range(1, n): if obstacleGrid[i][j] == 1: dp[j+1] = 0 else: dp[j+1] += dp[j] return dp[-1] 118. Pascal’s Triangle12345678910111213class Solution(object): def generate(self, numRows): if numRows == 0: return [] res = [[1]] for i in range(1, numRows): cur = [1] for j in range(1, i): cur.append(res[-1][j-1] + res[-1][j]) cur.append(1) res.append(cur) return res 119. Pascal’s Triangle II12345678910111213class Solution(object): def getRow(self, rowIndex): if rowIndex == 0: return [1] prev = [1] for i in range(1, rowIndex+1): cur = [1] for j in range(1, i): cur.append(prev[j-1]+prev[j]) cur += [1] prev = cur return cur Minimum64. Minimum Path Sum Time : O(mn), Space : O(min(m, n))123456789101112131415161718class Solution(object): def minPathSum(self, grid): if not grid: return 0 m, n = len(grid), len(grid[0]) dp = [0] * n for i in range(n): dp[i] = grid[0][i] + (dp[i-1] if i &gt;0 else 0) for i in range(1, m): for j in range(n): if j == 0: dp[j] += grid[i][j] continue dp[j] = min(dp[j], dp[j-1]) + grid[i][j] return dp[-1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"DFS - Matrix","slug":"dfs-matrix","date":"2018-10-29T19:57:53.000Z","updated":"2018-11-30T03:11:51.438Z","comments":true,"path":"2018/10/29/dfs-matrix/","link":"","permalink":"http://kaihaoli.github.io/2018/10/29/dfs-matrix/","excerpt":"","text":"329. Longest Increasing Path in a Matrix DFS search + Memorization in Matrix!!! 1234567891011121314151617181920212223242526272829303132333435# Time : O(mn), Space : O(mn)class Solution: def longestIncreasingPath(self, matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) self.visited = &#123;&#125; res = 0 for i in range(m): for j in range(n): ans = self.dfs(matrix, -float('inf'), i, j) res = max(res, ans) return res def dfs(self, matrix, prev, i, j): m, n = len(matrix), len(matrix[0]) if i &lt; 0 or j &lt; 0 or i &gt; m-1 or j &gt; n-1: return 0 val = matrix[i][j] if val &lt;= prev: return 0 if (i, j) in self.visited: return self.visited[(i, j)] d1 = self.dfs(matrix, val, i+1, j) d2 = self.dfs(matrix, val, i, j+1) d3 = self.dfs(matrix, val, i-1, j) d4 = self.dfs(matrix, val, i, j-1) d = max(d1, d2, d3, d4) + 1 self.visited[(i, j)] = d return d 36. Valid Sudoku but only meet the condition showed below can Not make sure the sudoku is valid!!!12345678910111213141516171819class Solution: def isValidSudoku(self, board): rows = [set() for _ in range(9)] cols = [set() for _ in range(9)] cubs = [set() for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] == '.': continue num = board[i][j] c = i // 3 * 3 + j // 3 if num in rows[i] or num in cols[j] or num in cubs[c]: return False rows[i].add(num) cols[j].add(num) cubs[c].add(num) return True 37. Sudoku Solver123456789101112131415161718192021222324252627282930313233343536class Solution: def solveSudoku(self, board): self.solve(board) def solve(self, board): for i in range(9): for j in range(9): if board[i][j] != '.': continue for ch in list(\"123456789\"): if self.isValid(board, i, j, ch): board[i][j] = ch if self.solve(board): return True else: board[i][j] = '.' return False return True def isValid(self, board, i, j, ch): # row &amp; col for k in range(9): if board[i][k] == ch: return False if board[k][j] == ch: return False # cubes row, col = (i // 3) * 3, (j // 3) * 3 for r in range(3): for c in range(3): if board[row + r][col + c] == ch: return False return True 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def solveSudoku(self, board): self.solve(board) def solve(self, board): for i in range(9): for j in range(9): if board[i][j] != '.': continue candidates = self.getCandidates(board, i, j) for ch in candidates: board[i][j] = ch if self.solve(board): return True else: board[i][j] = '.' return False return True def getCandidates(self, board, i, j): cans = set(list(\"123456789\")) for k in range(9): ch = board[i][k] if ch != '.' and ch in cans: cans.remove(board[i][k]) ch = board[k][j] if ch != '.' and ch in cans: cans.remove(board[k][j]) row, col = (i // 3) * 3, (j // 3) * 3 for r in range(3): for c in range(3): ch = board[row + r][col + c] if ch != '.' and ch in cans: cans.remove(ch) return list(cans) 489. Robot Room Cleaner The main different thing between this dfs and others is that you have to Maintain the Direction!!! Backtrack: turn 2 times to revert, move 1 step, and turn 2 times to revert back.12345678910111213141516171819202122class Solution(object): def cleanRoom(self, robot): visited = set() self.dfs(robot, 0, 0, 0, visited) def dfs(self, robot, i, j, k, visited): robot.clean() visited.add((i, j)) dirs = [(-1, 0), (0, -1), (1, 0), (0, 1)] for _ in range(4): di, dj = dirs[k] ni, nj = i + di, j + dj if (ni, nj) not in visited and robot.move(): self.dfs(robot, ni, nj, k, visited) robot.turnLeft() robot.turnLeft() robot.move() robot.turnLeft() robot.turnLeft() robot.turnLeft() k = (k + 1) % 4","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://kaihaoli.github.io/tags/dfs/"}]},{"title":"Trie","slug":"trie","date":"2018-10-28T15:21:34.000Z","updated":"2018-10-28T21:16:34.287Z","comments":true,"path":"2018/10/28/trie/","link":"","permalink":"http://kaihaoli.github.io/2018/10/28/trie/","excerpt":"","text":"Trie from the word Retrieve A data structure, it is a tree and a search tree. IntroductionSearch Trees Usually ordered data structure search for some kind of “keys” Example of Search Tree we are already very familiar: Binary Search Tree the keys are associsated with each node in the tree the keys can be any comparable type main the order of the keys by topological property(leftsubtree &lt; root &lt; rightsubtree) Design a Dictionaryn - # of wordsm - length of the string/word What is the requirement of this dictionary? search(word) delete add find all words with give prefix Options of data structures Hash Map Balanced BST ArrayList(sorted) Time Looking up data in a trie is faster in the worst case, O(m) time (where m is the length of a search string) hashmap, remember we may need to calculate the hashCode() and compare eaquals, that is O(m). Array List (sorted) - O(logn) * O(m) Binary Search Tree - O(logn) * O(m) DrawBack: if stored on disk, more random disk accesses (very expensive) Space if the tire is not too sparse, since reusing the common prefix as many as possible, less space required. worst case O(nm), but usually much better than this. DrawBack: Every TrieNode has extra space comsumption -&gt; extra space usage memory allocation fragmentation, especially when the trie is sparse. Use Case String or sequence typed elements fast worst search/add/delete grouping common prefix, both for time/space efficency problems related to prefix/matching 208. Implement Trie (Prefix Tree) Node &lt;val, children&gt;TODO: delete!!!! 1234567891011121314151617181920212223242526272829303132333435class Node(object): def __init__(self, val): self.val = val self.children = &#123;&#125; # self.parent = None ? # self.isWord = False ?class Trie: def __init__(self): self.root = Node(-1) def insert(self, word): cur = self.root for ch in word: if ch not in cur.children: cur.children[ch] = Node(ch) cur = cur.children[ch] cur.children['#'] = True def search(self, word): cur = self.root for ch in word: if ch not in cur.children: return False cur = cur.children[ch] return '#' in cur.children def startsWith(self, prefix): cur = self.root for ch in prefix: if ch not in cur.children: return False cur = cur.children[ch] return True 211. Add and Search Word - Data structure design12345678910111213141516171819202122232425262728293031323334353637class TrieNode(object): def __init__(self, val): self.val = val self.children = &#123;&#125; self.isWord = Falseclass WordDictionary: def __init__(self): self.root = TrieNode(-1) def addWord(self, word): cur = self.root for ch in word: if ch not in cur.children: cur.children[ch] = TrieNode(ch) cur = cur.children[ch] cur.isWord = True def search(self, word): return self.exist(word, self.root) def exist(self, word, root): if len(word) == 0: return root.isWord cur = root ch = word[0] if ch == '.': for nxt in cur.children.keys(): if self.exist(word[1:], cur.children[nxt]): return True return False else: if ch not in cur.children: return False return self.exist(word[1:], cur.children[ch])","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"DP - Game","slug":"dp-game","date":"2018-10-27T21:32:26.000Z","updated":"2018-11-25T18:22:24.384Z","comments":true,"path":"2018/10/27/dp-game/","link":"","permalink":"http://kaihaoli.github.io/2018/10/27/dp-game/","excerpt":"","text":"DFS + Memorization464. Can I Win DFS + Memorization + Pruning If there exist one way that the other one will NOT win, then I win! 12345678910111213141516171819202122class Solution: def canIWin(self, maxChoosableInteger, desiredTotal): if maxChoosableInteger * (maxChoosableInteger + 1) / 2 &lt; desiredTotal: return False self.memo = &#123;&#125; return self.helper(list(range(1, maxChoosableInteger + 1)), desiredTotal) def helper(self, nums, desiredTotal): key = tuple(nums) if key in self.memo: return self.memo[key] if nums[-1] &gt;= desiredTotal: return True for i in range(len(nums)): if not self.helper(nums[:i]+nums[i+1:], desiredTotal-nums[i]): self.memo[key] = True return True self.memo[key] = False return False 293. Flip Game1234567class Solution: def generatePossibleNextMoves(self, s): res = [] for i in range(len(s)-1): if s[i] == '+' and s[i+1] == '+': res.append(s[:i] + \"-\" + \"-\" + s[i+2:]) return res 294. Flip Game II123456789101112131415161718class Solution: def canWin(self, s): self.memo = &#123;&#125; return self.win(s) def win(self, s): if s in self.memo: return self.memo[s] for i in range(len(s)-1): if s[i] == '+' and s[i+1] == '+': news = s[:i] + \"-\" + \"-\" + s[i+2:] if not self.win(news): self.memo[s] = True return True self.memo[s] = False return False DPLintCode 394. Coins in a LineSolution1. DFS + Memorization TLE123456789101112131415161718class Solution: def firstWillWin(self, n): self.memo = &#123;&#125; return self.helper(n) def helper(self, n): if n &lt;= 2: return True if n in self.memo: return self.memo[n] if not self.firstWillWin(n-1) or not self.firstWillWin(n-2): self.memo[n] = True return True self.memo[n] = False return False Solution2. DP Time : O(n), Space : O(n) 12345678910111213class Solution: def firstWillWin(self, n): if n == 0: return False if n &lt;= 2: return True dp = [False] * (n+1) dp[1] = dp[2] = True for i in range(3, n+1): dp[i] = not dp[i-1] or not dp[i-2] return dp[n] Solution3. Math123class Solution: def firstWillWin(self, n): return bool(n % 3) LintCode 395. Coins in a Line II dp[i], preSum[i]-dp[i] represent how many i get and how many other one get!!! 123456789101112131415161718192021class Solution: def firstWillWin(self, values): n = len(values) if n &lt;= 2: return True values.reverse() psum = self.preSum(values) dp = [0] * n dp[0] = psum[0] dp[1] = psum[1] for i in range(2, n): dp[i] = max(psum[i] - dp[i-1], psum[i] - dp[i-2]) return dp[n-1] &gt; psum[n-1] - dp[n-1] def preSum(self, values): psum = [values[0]] for i in range(1, len(values)): psum.append(psum[-1] + values[i]) return psum LintCode 396. Coins in a Line IIITODO!!! Follow upDP[i][j] represents from i-th coin to the j-th coin, the largest sum of pizza that i can pick. case1 : if i take the left coin, if input[i+1] &lt; input[j], input[i] + DP[i+1][j-1] if input[i+1] &gt; input[j], input[i] + DP[i+2][j] case2 : if i take the right coin, if input[i] &lt; input[j-1], input[j] + DP[i][j-2] if input[i] &gt; input[j-1], input[j] + DP[i+1][j-1] Base Case: 2 coins, DP[i][i+1] = max(input[i], input[i+1]) 1 coin, DP[i][i] = input[i] Coin GameLet us understand the problem with few examples: 5, 3, 7, 10 : The user collects maximum value as 15(10 + 5) 8, 15, 3, 7 : The user collects maximum value as 22(7 + 15)Does choosing the best at each move give an optimal solution? F(i, j) represents the maximum value the user can collect from i’th coin to j’th coin. If I take Ai, Vi + min(F(i+2, j), F(i+1, j-1) If I take Ak, Vj + min(F(i+1, j-1), F(i, j-2)$$F(i, j) = Max(Vi + min(F(i+2, j), F(i+1, j-1) ), Vj + min(F(i+1, j-1), F(i, j-2) ))$$ Base Cases F(i, j) = Vi If j == i F(i, j) = max(Vi, Vj) If j == i+1","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://kaihaoli.github.io/tags/dfs/"},{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"Data Stream","slug":"topic-data-stream","date":"2018-10-26T20:42:38.000Z","updated":"2018-12-10T02:12:16.940Z","comments":true,"path":"2018/10/26/topic-data-stream/","link":"","permalink":"http://kaihaoli.github.io/2018/10/26/topic-data-stream/","excerpt":"","text":"Data Stream703. Kth Largest Element in a Stream heap 123456789101112131415class KthLargest(object): def __init__(self, k, nums): self.size = k heapq.heapify(nums) self.heap = nums while len(self.heap) &gt; k: heapq.heappop(self.heap) # Time : O(log k), Space : O(k) def add(self, val): heapq.heappush(self.heap, val) if len(self.heap) &gt; self.size: heapq.heappop(self.heap) return self.heap[0] 346. Moving Average from Data Stream sliding window : deque - double queue 12345678910111213class MovingAverage(object): def __init__(self, size): self.sum = 0 self.size = size self.queue = collections.deque() def next(self, val): self.queue.append(val) self.sum += val if len(self.queue) &gt; self.size: self.sum -= self.queue.popleft() return self.sum / (1.0 * len(self.queue)) 295. Find Median from Data Stream min Heap, max Heap 12345678910111213141516171819class MedianFinder(object): def __init__(self): self.maxHeap = [] self.minHeap = [] def addNum(self, num): heapq.heappush(self.maxHeap, -num) heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap)) m1, m2 = len(self.maxHeap), len(self.minHeap) if m1 &lt; m2: heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap)) def findMedian(self): m1, m2 = len(self.maxHeap), len(self.minHeap) if m1 == m2: return (self.minHeap[0] - self.maxHeap[0]) / 2.0 else: return -self.maxHeap[0] * 1.0 follow up : what if the number of element is toooo large to be stored into the memory? Find the first non-repeating character from a StreamUse Case: We need to somehow record which one is the First (order)When a new element comes in we found that previous solution is now not the solution any more, we need to update the solution to the next one.(Use a doubl linked list) We also need to record what kind of letters that have appeared (non-repeating) Hash Map &lt;key:character, val:Node&gt; (Same with LRU!!!) Sliding WindowSlinding Window Average Time : O(1), Space :(window size) Queue to maintain the window variable sum to record sum , update O(1) 239. Sliding Window Maximumtotal data - n, window size - k Solution1. NaiveTime : O((n-k)k), (O(k) for online data stream) Solution2. HeapTime : O((n-k)logk) Initialization:insert all first k elements into the max-heap. Then: when the sliding window moves to the right side step by step1 new element comes in.1 left-most element should be removed from the sliding window. bu we can temoporarily keep it in the heap, until it becomes the top element in the heap. lazy deletion(value, index) 12345678910111213141516class Solution(object): def maxSlidingWindow(self, nums, k): if not nums or k == 0: return [] maxHeap = [] for i in xrange(k-1): heapq.heappush(maxHeap, (-nums[i], i)) res = [] for i in xrange(k-1, len(nums)): heapq.heappush(maxHeap, (-nums[i], i)) while maxHeap[0][1] &lt;= i-k: heapq.heappop(maxHeap) res.append(-maxHeap[0][0]) return res When we want to call max_heap.top(), the only thing we should be careful about is to check, whether this top elemtns’s index is &lt; left border of the sliding window. If so, keep poping it out. Solution3. DequeTime : O(n) We must maintain all the values in the dequeue to keep them in a descending order. because when a new element X comes in, if it is bigger and newer than the right most element r, then r cannot be the solution. whatsoever, we can just delete r 123456789101112131415class Solution(object): def maxSlidingWindow(self, nums, k): queue = collections.deque() res = [] for i, num in enumerate(nums): if queue and queue[0] &lt;= i-k: queue.popleft() while queue and num &gt; nums[queue[-1]]: queue.pop() queue.append(i) if i &gt;= k - 1: res.append(nums[queue[0]]) return res So the dequeue[left-most] is the final result to return whenever the window slides one step to the right. 480. Sliding Window Median double heap + lazy clear 12345678910111213141516171819202122232425262728293031323334class Solution(object): def medianSlidingWindow(self, nums, k): if k == 1: return map(float, nums) minHeap, maxHeap = [], [] for i in xrange(k): heapq.heappush(maxHeap, (-nums[i], i)) for _ in xrange(k/2): val, idx = heapq.heappop(maxHeap) heapq.heappush(minHeap, (-val, idx)) res = [] for i in xrange(k, len(nums)): res.append(-maxHeap[0][0]*1.0 if k % 2 else (minHeap[0][0]-maxHeap[0][0])/2.0) if nums[i] &gt;= minHeap[0][0]: heapq.heappush(minHeap, (nums[i], i)) if nums[i-k] &lt;= -maxHeap[0][0]: val, idx = heapq.heappop(minHeap) heapq.heappush(maxHeap, (-val, idx)) else: heapq.heappush(maxHeap, (-nums[i], i)) if nums[i-k] &gt;= minHeap[0][0]: val, idx = heapq.heappop(maxHeap) heapq.heappush(minHeap, (-val, idx)) while maxHeap[0][1] &lt;= i-k: heapq.heappop(maxHeap) while minHeap[0][1] &lt;= i-k: heapq.heappop(minHeap) res.append(-maxHeap[0][0]*1.0 if k % 2 else (minHeap[0][0]-maxHeap[0][0])/2.0) return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://kaihaoli.github.io/tags/heap/"},{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"},{"name":"queue","slug":"queue","permalink":"http://kaihaoli.github.io/tags/queue/"}]},{"title":"Math","slug":"math","date":"2018-10-24T13:45:51.000Z","updated":"2018-11-13T00:54:28.434Z","comments":true,"path":"2018/10/24/math/","link":"","permalink":"http://kaihaoli.github.io/2018/10/24/math/","excerpt":"","text":"750. Number Of Corner Rectangles123456789101112class Solution(object): def countCornerRectangles(self, grid): m, n = len(grid), len(grid[0]) res = 0 corner = [] for i in range(m): layer = &#123;j for j in range(n) if grid[i][j] == 1&#125; for prev in corner: cnt = len(layer &amp; prev) res += cnt * (cnt - 1) // 2 corner.append(layer) return res 836. Rectangle Overlap12345class Solution(object): def isRectangleOverlap(self, rec1, rec2): x1, y1, x2, y2 = rec1 x3, y3, x4, y4 = rec2 return x2 &gt; x3 and x1 &lt; x4 and y2 &gt; y3 and y1 &lt; y4 Prime NumberA prime number (or a prime) is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. is Prime1234567def isPrime(m): i = 2 while(i*i &lt;= m): if m % i == 0: return False i += 1 return True 204. Count Primes Time : O(n)123456789101112131415class Solution: def countPrimes(self, n): if n &lt;= 2: return 0 primes = [True] * n primes[0] = primes[1] = False for i in range(2, int(n**0.5)+1): if not primes[i]: continue k = 2 while i * k &lt; n: primes[i * k] = False k += 1 return sum(primes)","categories":[],"tags":[]},{"title":"Boyer-Moore Voting Algorithm","slug":"topic-voting-algorithm","date":"2018-10-24T00:03:49.000Z","updated":"2018-11-10T16:28:13.461Z","comments":true,"path":"2018/10/23/topic-voting-algorithm/","link":"","permalink":"http://kaihaoli.github.io/2018/10/23/topic-voting-algorithm/","excerpt":"","text":"169. Majority ElementSolution1. Hash Table Time : O(n), Space : O(n)12345678class Solution(object): def majorityElement(self, nums): n = len(nums) dic = collections.defaultdict(int) for num in nums: dic[num] += 1 if dic[num] &gt; n/2: return num Solution2. Voting Algorithm Time : O(n), Space :O(1) Maintain a pair candidate, counter When a new element x comes in, if counter == 0, just set candidate = x, counter = 1 else if x == candidate, counter ++ else counter –123456789101112class Solution(object): def majorityElement(self, nums): candidate = None counter = 0 for num in nums: if counter == 0: candidate = num counter = 1 else: counter += 1 if candidate == num else -1 return candidate 229. Majority Element IISolution1. Hash tableTime : O(n), Space : O(n)12345678910class Solution(object): def majorityElement(self, nums): n = len(nums) dic = collections.defaultdict(int) res = set() for num in nums: dic[num] += 1 if dic[num] &gt; n / 3: res.add(num) return list(res) Solution2. Voting Algorithm Time : O(n), Space : O(1) 12345678910111213141516171819202122class Solution(object): def majorityElement(self, nums): if not nums: return [] n = len(nums) can1, can2 = 0, 1 cnt1, cnt2 = 0, 0 for num in nums: if can1 == num: cnt1 += 1 elif can2 == num: cnt2 += 1 else: if cnt1 == 0: cnt1, can1 = 1, num elif cnt2 == 0: cnt2, can2 = 1, num else: cnt1 -= 1 cnt2 -= 1 return [can for can in [can1,can2] if nums.count(can) &gt; n // 3] Majority Element IIIduplicates &gt; [1/k], we need k-1 candidates, so the space complexity is O(k) Majority Element IV what if the input in sorted, you wanna find the majority number appears n / 4 times! 277. Find the CelebritySolution1. Divede and Conquer O(nlogn)1234567891011121314151617181920212223242526272829303132class Solution(object): def findCelebrity(self, n): if n &lt;= 1: return n cand = self.find_cands(range(n)) for i in range(n): if i == cand: continue if knows(cand, i): return -1 if not knows(i, cand): return -1 return cand def find_cands(self, nums): n = len(nums) # Base Case if n == 1: return nums[0] if n == 2: if knows(nums[0], nums[1]): return nums[1] else: return nums[0] p1 = self.find_cands(nums[:n//2+1]) p2 = self.find_cands(nums[n//2+1:]) return p2 if knows(p1, p2) else p1 Solution2. Voting O(n) Something like the Voting algorithm 1234567891011121314151617class Solution(object): def findCelebrity(self, n): if n &lt;= 1: return n cand = 0 for i in range(1, n): if knows(cand, i): cand = i if any(knows(cand, i) for i in range(cand)): return -1 if any(not knows(i, cand) for i in range(n)): return -1 return cand","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"Cache","slug":"topic-cache","date":"2018-10-22T13:41:19.000Z","updated":"2018-10-29T00:12:18.259Z","comments":true,"path":"2018/10/22/topic-cache/","link":"","permalink":"http://kaihaoli.github.io/2018/10/22/topic-cache/","excerpt":"","text":"Design + Operatin System + Data Structure OrderedDictAn OrderedDict is a dict that remembers the order that keys were first inserted.1234cache = collections.OrderedDict()cache.popitem(last=True)# The popitem() method for ordered dictionaries returns and removes a (key, value) pair.# The pairs are returned in LIFO order if last is true or FIFO order if false. 146. LRU CacheDesign and implement a data structure for Least Recently Used (LRU) cache. we need to be able to add an entry to the cache and delete the oldest entry from the cache.(including when the cache is full) we need to find out quickly whether an entry is in the cache or not. hash map : we need to adjust the priority efficiently of each entry in the cache. double linked list or singly linked list node Solution1. Built-In python built-in datastructure OrderedDict!!! record the order when they put in the dictionary 12345678910111213141516171819202122class LRUCache(object): def __init__(self, capacity): self.cap = capacity self.cache = collections.OrderedDict() def get(self, key): if key not in self.cache: return -1 val = self.cache.pop(key) self.cache[key] = val return val def put(self, key, value): if key in self.cache: self.cache.pop(key) self.cache[key] = value else: if len(self.cache) &gt;= self.cap: self.cache.popitem(last=False) self.cache[key] = value Solution2. Doublely Linked List + Hash map Key Point DummyNode, head and tail helper function, remove and addHead 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Node(object): def __init__(self, key, val): self.key = key self.val = val self.prev = None self.next = Noneclass LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" self.cap = capacity self.cache = &#123;&#125; self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _addHead(self, node): nxt = self.head.next self.head.next = node node.prev = self.head node.next = nxt nxt.prev = node def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def get(self, key): if key not in self.cache: return -1 node = self.cache[key] self._remove(node) self._addHead(node) self.cache[key] = node return node.val def put(self, key, value): if key in self.cache: node = self.cache[key] node.val = value self._remove(node) self._addHead(node) else: if len(self.cache) &gt;= self.cap: lastKey = self.tail.prev.key self._remove(self.tail.prev) del self.cache[lastKey] node = Node(key, value) self.cache[key] = node self._addHead(node) 460. LFU CacheTODO!!!","categories":[{"name":"Design","slug":"Design","permalink":"http://kaihaoli.github.io/categories/Design/"}],"tags":[{"name":"hash table","slug":"hash-table","permalink":"http://kaihaoli.github.io/tags/hash-table/"},{"name":"linked list","slug":"linked-list","permalink":"http://kaihaoli.github.io/tags/linked-list/"},{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"K Sum","slug":"k-sum","date":"2018-10-20T14:02:10.000Z","updated":"2018-10-20T15:28:19.729Z","comments":true,"path":"2018/10/20/k-sum/","link":"","permalink":"http://kaihaoli.github.io/2018/10/20/k-sum/","excerpt":"","text":"Assumption unsorted or sorted return index ? or value ? duplicate ? size, data type, data range ? optimize time or space ? How many time are we going to call this function? 2 Sum$O(n^2)$ ###1.Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. HashTable123456789# Time : O(n), Space : O(n)class Solution(object): def twoSum(self, nums, target): coml = &#123;&#125; for i in xrange(len(nums)): c = target-nums[i] if c in coml: return [coml[c], i] coml[nums[i]] = i Why not Sort + Two Pointers ? after sort, lost the information of indices return indice instead of values 167. Two Sum II - Input array is sorted Not Zero-Based Index123456789101112class Solution(object): def twoSum(self, nums, target): l = 0 r = len(nums) - 1 while l &lt; r: s = nums[l] + nums[r] if s &gt; target: r -= 1 elif s &lt; target: l += 1 else: return [l+1, r+1] 170. Two Sum III - Data structure design HashTable, consider duplicates Trade Off, quick add or quick find ? 12345678910111213class TwoSum(object): def __init__(self): self.nums = collections.defaultdict(int) def add(self, number): self.nums[number] += 1 def find(self, value): for num in self.nums.keys(): if value - num in self.nums and (value - num != num or self.nums[num] &gt; 1): return True return False 653. Two Sum IV - Input is a BST This is a general idea for binary tree instead of BST!!! 1234567891011121314151617181920class Solution(object): def findTarget(self, root, k): self.visited = set() return self.dfs(root, k) def dfs(self, root, k): if not root: return False if self.dfs(root.left, k): return True if k - root.val in self.visited: return True self.visited.add(root.val) if self.dfs(root.right, k): return True return False 3 Sum$O(n^3)$ 15. 3Sum only one results ? no duplicates ? yes The solution set must not contain duplicate triplets. 123456789101112131415161718192021222324252627class Solution(object): def threeSum(self, nums): nums.sort() res = [] for i in xrange(len(nums)-2): # Skip Duplicate nums at 1st place if i &gt; 0 and nums[i] == nums[i-1]: continue l = i + 1 r = len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &gt; 0: r -= 1 elif s &lt; 0: l += 1 else: res.append([nums[i], nums[l], nums[r]]) # Remove Dupilcate Results while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 # Forget to add following 2 lines =.= l += 1 r -= 1 return res 16. 3Sum Closest12345678910111213141516171819class Solution(object): def threeSumClosest(self, nums, target): res = float('inf') nums.sort() for i in xrange(len(nums)-2): l = i + 1 r = len(nums) - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] # only append this line if abs(s - target) &lt; abs(res - target): res = s if s &gt; target: r -= 1 elif s &lt; target: l += 1 else: return target return res 4 Sum$O(n^4)$","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"sort","slug":"sort","permalink":"http://kaihaoli.github.io/tags/sort/"}]},{"title":"Directed Graph","slug":"graph-directed","date":"2018-10-19T15:25:41.000Z","updated":"2018-11-19T22:31:30.094Z","comments":true,"path":"2018/10/19/graph-directed/","link":"","permalink":"http://kaihaoli.github.io/2018/10/19/graph-directed/","excerpt":"","text":"399. Evaluate Division12345678910111213141516171819202122232425262728class Solution: def calcEquation(self, equations, values, queries): graph = collections.defaultdict(dict) n = len(equations) for i in range(n): src, dst = equations[i] graph[src][dst] = values[i] graph[dst][src] = 1.0 / values[i] ans = [] for start, end in queries: self.res = -1.0 self.dfs(start, end, set(), 1.0, graph) ans.append(self.res) return ans def dfs(self, start, end, visited, path, graph): if start == end and start in graph: self.res = path return if start in visited: return visited.add(start) for nei in graph[start].keys(): self.dfs(nei, end, visited, path*graph[start][nei], graph) Time Analysis Construct the Graph O(Edges), numbers of equations Query, O(Edges) Follow up Follow up1: if there are different path from start node to end node ? calcaulate the lowest and highest exchange rate Follow up2: if we have many queries, how to speed up queries? use hash table to save the results add connected line in the graph! 332. Reconstruct Itinerary DFS post order traversal! a little like topological sort, but different dependency!!! 12345678910111213class Solution(object): def findItinerary(self, tickets): graph = collections.defaultdict(list) for f, t in sorted(tickets, reverse = True): graph[f].append(t) res = [] def dfs(node): while graph[node]: dfs(graph[node].pop()) res.append(node) dfs('JFK') return res[::-1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://kaihaoli.github.io/tags/graph/"}]},{"title":"DP - Cut Sequence","slug":"dp-sequence-cut","date":"2018-10-18T21:27:03.000Z","updated":"2018-11-29T03:30:12.806Z","comments":true,"path":"2018/10/18/dp-sequence-cut/","link":"","permalink":"http://kaihaoli.github.io/2018/10/18/dp-sequence-cut/","excerpt":"","text":"AnalysisQuestion Type Seperate an sequence to several nonoverlapping subarray no limit or limited k on the number of the subarray Each subarray meet or meet some requirement! Solution Type Normally, dp[i][j]represents previous i elements seperate k subarray Split Array410. Split Array Largest SumSolution1. DP DP[i][j] represents that the largest sum for previous i elements seperated to j group DP[i][j] = min{max{dp[k][j-1], sum(k+1, i)}} ($0&lt;= k &lt;i$) Time : O($mn^2$), Space : O(mn)1234567891011121314151617181920212223class Solution: def splitArray(self, nums, m): n = len(nums) # Prefix Sum preSum = [0] for i in range(n): preSum.append(preSum[-1] + nums[i]) dp = [[float('inf')] * m for _ in range(n+1)] # Init dp[0][0] = 0 for i in range(n+1): dp[i][0] = preSum[i] for j in range(m): dp[0][j] = 0 # DP for i in range(1, n+1): for j in range(i): for k in range(1, m): dp[i][k] = min(dp[i][k], max(dp[j][k-1], preSum[i]-preSum[j])) return dp[-1][-1] Solution2. Binary Search12345678910111213141516171819202122class Solution: def splitArray(self, nums, m): start, end = max(nums), sum(nums) while start &lt; end: mid = start + (end - start) // 2 if self.isValid(mid, nums, m): end = mid else: start = mid + 1 return start def isValid(self, mid, nums, m): cur = 0 cnt = 0 for num in nums: cur += num if cur &gt; mid: cur = num cnt += 1 if cnt &gt;= m: return False return True Split String139. Word BreakSolution1. DFS TLE123456789101112131415# Worst Case : Time O(n!)class Solution(object): def wordBreak(self, s, wordDict): wset = set(wordDict) return self.isWordBreak(s, wset) def isWordBreak(self, s, wset): if len(s) == 0: return True for i in xrange(len(s)): if s[i:] in wset: if self.isWordBreak(s[:i], wset): return True return False Solution2. DP1234567891011121314# Time : O(n^2)class Solution(object): def wordBreak(self, s, wordDict): wset = set(wordDict) n = len(s) dp = [False] * (n+1) dp[0] = True for i in xrange(n): for j in xrange(i+1): if s[j:i+1] in wset and dp[j]: dp[i+1] = True break return dp[-1] 140. Word Break II DFS + Memorization 1234567891011121314151617181920212223class Solution(object): def wordBreak(self, s, wordDict): words = set(wordDict) return self.dfs(s, words, &#123;&#125;) def dfs(self, s, words, dic): if len(s) == 0: return [''] if s in dic: return dic[s] res = [] for i in xrange(len(s)): if s[:i+1] in words: ans = self.dfs(s[i+1:], words, dic) for item in ans: if item == '': res.append(s[:i+1]) else: res.append(s[:i+1] + ' ' + item) dic[s] = res return res 91. Decode Ways care about edge cases1234567891011121314class Solution(object): def numDecodings(self, s): n = len(s) dp = [0] * n dp[0] = 1 if s[0] != '0' else 0 for i in range(1, n): # case1 : 1 letter if s[i] != '0': dp[i] += dp[i-1] # case2 : 2 letter if 10 &lt;= int(s[i-1:i+1]) &lt;= 26: dp[i] += dp[i-2] if i &gt;= 2 else 1 return dp[-1] 639. Decode Ways II123456789101112131415class Solution(object): def numDecodings(self, s): MOD = 10**9 + 7 e0, e1, e2 = 1, 0, 0 for c in s:#xrange(len(s)): if c == '*': f0 = 9*e0 + 9*e1 + 6*e2 f1 = e0 f2 = e0 else: f0 = (c!='0')*e0 + e1 + (c&lt;='6')*e2 f1 = (c=='1')*e0 f2 = (c=='2')*e0 e0, e1, e2 = f0 % MOD, f1, f2 return e0 132. Palindrome Partitioning II isPalindrome can also use the DP way to solve!!! 12345678910111213141516171819202122class Solution(object): def minCut(self, s): if len(s) == 0: return 0 n = len(s) isPalin = [[False] * n for _ in range(n)] for j in range(n): for i in range(j, -1, -1): if s[i] == s[j] and (j-i &lt;= 2 or isPalin[i+1][j-1]): isPalin[i][j] = True dp = [n-1] * (n+1) dp[0] = 0 for i in range(1, n+1): for j in range(i): if isPalin[j][i-1]: if j == 0: dp[i] = 0 else: dp[i] = min(dp[i], dp[j] + 1) return dp[-1] 410. Split Array Largest Sum1234567891011121314151617181920212223class Solution(object): def splitArray(self, nums, m): n = len(nums) if m &gt;= n: return max(nums) dp = [[float('inf')] * m for _ in range(n)] for k in range(m): dp[0][k] = nums[0] pre_sum = [0] cur = 0 for i in range(n): cur += nums[i] pre_sum.append(cur) dp[i][0] = cur for i in range(1, n): for j in range(i): for k in range(1, m): dp[i][k] = min(dp[i][k], max(dp[j][k-1], pre_sum[i+1]-pre_sum[j+1])) return dp[-1][-1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"Google High Frequency Summary","slug":"company-google","date":"2018-10-16T22:31:53.000Z","updated":"2018-11-23T22:48:57.290Z","comments":true,"path":"2018/10/16/company-google/","link":"","permalink":"http://kaihaoli.github.io/2018/10/16/company-google/","excerpt":"","text":"DPMatrix Pathfrom (0, 0) to (0, n-1), traverse to right, right bottom and right top! Follow Up1 : Must go through some points Follow Up2 : Must go through a certain height Graph -&gt; TreeRedundant Connection 684. Redundant ConnectionUndirected Graph! Union Find when the inputs are edges, you do not need to construct the graph path compression, but how about the balanced part? DFS 12345678910111213141516class Solution(object): def findRedundantConnection(self, edges): root = range(1001) def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] for i, j in edges: rooti = find(i) rootj = find(j) if rooti == rootj: return [i, j] root[rooti] = rootj 685. Redundant Connection IIDirected Graph Case1: There is a loop in the graph, and no vertex has more than 1 parent. =&gt; Union Find Case2: A vertex has more than 1 parent, but there isn’t a loop in the graph. =&gt; last node (indegree &gt; 1) Case3: A vertex has more than 1 parent, and is part of a loop. Delete the second edge! 1234567891011121314151617181920212223242526272829303132class Solution(object): def findRedundantDirectedConnection(self, edges): n = len(edges) parent = [0] * (n+1) ans = None # Step1 : find the node with indegree &gt; 1 for i in xrange(n): u, v = edges[i] if parent[v] == 0: parent[v] = u else: ans = [[parent[v], v], [u, v]] # !!! Delete the second Edge edges[i][1] = 0 # Step2 : Union Find detect cycle root = range(n+1) def find(x): if root[x] == x: return x return find(root[x]) for u, v in edges: rootu = find(u) rootv = find(v) if rootu == rootv: # Detect Cycle if not ans: return [u, v] else: return ans[0] root[rootu] = rootv return ans[1] Other843. Guess the Word12345678910111213141516171819class Solution: def match(self, s1, s2): matches = 0 for i in range(len(s1)): if s1[i] == s2[i]: matches += 1 return matches def findSecretWord(self, wordlist, master): cnt = 10 while cnt: guessWord = random.choice(wordlist) matches = master.guess(guessWord) newList = [] for word in wordlist: if self.match(guessWord, word) == matches: newList.append(word) wordlist = newList cnt -= 1 DFSRemove Marble123456789101112131415161718192021222324252627282930313233343536373839404142def dfs(board, x, y, row_visited, col_visited): m, n = len(board), len(board[0]) if x in row_visited and y in col_visited: return False if x not in row_visited: row_visited.add(x) for j in range(n): if board[x][j] == 1: dfs(board, x, j, row_visited, col_visited) if y not in col_visited: col_visited.add(y) for i in range(m): if board[i][y] == 1: dfs(board, i, y, row_visited, col_visited) return Truedef remove_number(board): cnt = 0 # Count the number of marble m, n = len(board), len(board[0]) # Count the number of cluster row_visited = set() col_visited = set() cluster = 0 for i in range(m): for j in range(n): if board[i][j] == 1: cnt += 1 if dfs(board, i, j, row_visited, col_visited): cluster += 1 return cnt - clusterboard = [[1, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [0, 0, 1, 0]]print(remove_number(board))","categories":[],"tags":[]},{"title":"Tree - Lowest Common Ancestor","slug":"tree-lca","date":"2018-10-15T15:04:12.000Z","updated":"2018-10-15T15:48:23.333Z","comments":true,"path":"2018/10/15/tree-lca/","link":"","permalink":"http://kaihaoli.github.io/2018/10/15/tree-lca/","excerpt":"","text":"235. Lowest Common Ancestor of a Binary Search Tree Use the Definition of BST !!! 123456789101112# Time : O(h)class Solution(object): def lowestCommonAncestor(self, root, p, q): if not root or root == p or root == q: return root if root.val &gt; p.val and root.val &gt; q.val: return self.lowestCommonAncestor(root.left, p, q) elif root.val &lt; p.val and root.val &lt; q.val: return self.lowestCommonAncestor(root.right, p, q) else: return root 236. Lowest Common Ancestor of a Binary Tree“The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” Case1 if a is NOT the ancestor of b if left subtree returns None and right subtree returns None, return None if left subtree AND right subtree return NOT NULL, return c either left or right returns NOT null, return not null Case2 if a is the ancestor of b (same thing) 123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): # 1 Base case : root is q or p if not root or root is q or root is p: return root # 2 Recursion : ask value from left and right subtree left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # Case: return c if left and right: return root return left if left else right Follow up 1 Not Exist What if the node p or q is NOT in the tree ? case1: if return c, no worries! a and b are in the tree case2: if return None, both a and b not in the tree case3: if sol == p or sol == q FindNode in B or A 1234567sol = LowestCommonAncestor(root, p, q)if sol is None: return Noneelif sol != p and sol != q: return solelse: return LowestCommonAncestor(sol, q, q) if sol == p else LowestCommonAncestor(sol, p, p) Follow up 2 Parent PointerWhat if we have parent pointers ? Method1: step1. keep looking up from a and b, to find height(a) and height(b) step2. move the one with larger height value by abs(height(a)-height(b)) step3. move a and b together one step by one step until a == b Method2: HashSet=&gt; interaction of two linked list Follow up 3 k Nodes (No parent pointers)General Idea to solve k-something … Method1: Binary Reduction eg. Merge Sort Call how many times of LCA(nodea, nodeb)? O(kn) Method2: Iterative 12 -&gt; 3, 13 -&gt; 4, 14 -&gt; 5 … Call how many times of LCA(nodea, nodeb)? O(kn) Method3: k way all together O(n) 123456789101112class Solution(object): def lowestCommonAncestor(self, root, nodes): if not root or root in nodes: return root left = self.lowestCommonAncestor(root.left, nodes) right = self.lowestCommonAncestor(root.right, nodes) if left and right: return root return left if left else right Follow up 4 k-nary Tree12345# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.children = [] Follow up 5 k node in k-nary treeCombine 3 &amp; 4 Follow up 6 very large treeLCA for two nodes a and b in a very large tree that contains billions of nodes, given 10000 machies.(32 machines) Mapper : 1 job -&gt; distribute to 10000 machines. Reducer : collect results from each mapper (machines) to do aggregation/post-processing Solution Map-reduceAssume we hace 32 machines 2 ^ 5 = 32, so we have 32 nodes in level 5. Case 1: both nodes a and b are within top 5 layers (we can run BFS1 within top 5 layers) Call LCA(root, a, b, level_limit = 5) Case 2: either node a or node b is within top 5 layers. Assume a is on top 5 layers, Call Find(M1, b), Find(M2, b), …, Find(M32, b) Say, M7 return s that I found b in my sub-tree. Call LCA(root, a, M7, level_limit = 5) Case 3: neither node a nor node b is within top 5 layers. Call LCA(M1, a, b), LCA(M2, a, b), …, LCA(M32, a, b) Case3.1 a and b are in different machines. In this case, there must be exactly two machines that find non-null Say they’re M3, M7, Call LCA(root, M3, M7, level_limit=5) Case3.2 a and b are in the same machine. In this case, ONLY ONE machine returns non null Case3.2.1 if it returns a or b: one node is the ancestor of the other node Case3.2.2 if it returns c: a and b are both in the tree and c is the LCA","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"Sampling & Randomization","slug":"sampling-randomization","date":"2018-10-14T15:35:31.000Z","updated":"2018-12-05T21:28:02.578Z","comments":true,"path":"2018/10/14/sampling-randomization/","link":"","permalink":"http://kaihaoli.github.io/2018/10/14/sampling-randomization/","excerpt":"","text":"Reservoir SamplingShuffling Algorithmpokers(spades, hearts, diamonds, clubs) Iteration 1Call random(0-51), lets say, random_numbers1 = 5P(every card can showup in position 51) = 1/52 Iteration 2Call random(0-50), lets say, random_numbers2 = 8Every card was NOT selected during previous iteration = 1 - 1/52P(every card showup in position 50) = (1-1/52) * 1/51 = 1/52 Iteration 3Every card was NOT selected during previous iteration = 1 - 1/52Every card was NOT selected during previous iteration = 1 - 1/51P(every card showup in position 50) = (1-1/52) (1-1/51) 1/50 = 1/52 ….. Select random k elements in an array of size n Sampling for an unlimited data flowHow to do sampling for an unlimited data flow and when reading the n-th element we are required to return one random number among all numbers read so far, such that the probability of returning any element read so far is 1/n. O(1) sapce complexity t = 0 call random[0-0] = random_num1, if random_num1 == 0 -&gt; solu = input[0]P(input[0] will be returned as the solu) = 100% t = 1 call random[0-1] = random_num2, if random_num2 == 0 -&gt; solu = input[1]P(input[0] will be returned as the solu) = 1 - 50%P(input[1] will be returned as the solu) = 50% t = 2 call random[0-2] = random_num3, if random_num3 == 0 -&gt; solu = input[2]P(input[0] will be returned as the solu) = 1/2 (1 - 1/3) = 1/3P(input[1] will be returned as the solu) = 1/2 (1 - 1/3) = 1/3P(input[2] will be returned as the solu) = 1/3…. Return k out of n log same thing as above! first k element put into the reservoir when new element comes in, generate a random number from 0 to its index if index &lt; k, replace the new element with the k postion element 398. Random Pick Index123456789101112131415class Solution(object): def __init__(self, nums): self.nums = nums def pick(self, target): cnt = 0 res = 0 for i in xrange(len(self.nums)): if self.nums[i] != target: continue if random.randint(0, cnt) == 0: res = i cnt += 1 return res Return a random largest number’s indexRandomizationRandom(5) -&gt; Random(25) -&gt; Random(7)0 1 2 3 45 6 7 8 910 11 12 13 1415 16 17 18 1920 21 22 23 24 call Random(5) for the 1st time = random_num1[0—4] = row number call Random(5) for the 2nd time = random_num2[0—4] = col numbergenerated_number = r1 * 5 + r2 470. Implement Rand10() Using Rand7()123456789class Solution(object): def rand10(self): r1 = rand7() r2 = rand7() num = (r1-1) * 7 + (r2-1) if num &lt;= 39: return (num % 10) + 1 else: return self.rand10() Design Random(1,000,000) with Random(5) $log_5(1000000)$ 528. Random Pick with Weight PreSum + Binary Search123456789101112131415161718192021class Solution(object): def __init__(self, w): if not w: return s = [w[0]] for weight in w[1:]: s.append(s[-1] + weight) self.sum = s print(self.sum) def pickIndex(self): num = random.randint(1, self.sum[-1]) start, end = 0, len(self.sum)-1 while start &lt; end: mid = (start + end) / 2 if self.sum[mid] &lt; num: start = mid + 1 else: end = mid return start Random380. Insert Delete GetRandom O(1)12345678910111213141516171819202122232425262728class RandomizedSet(object): def __init__(self): self.nums = [] self.dic = &#123;&#125; def insert(self, val): if val in self.dic: return False self.nums.append(val) idx = len(self.nums) - 1 self.dic[val] = idx return True def remove(self, val): if val not in self.dic: return False last = len(self.nums) - 1 idx = self.dic[val] if last != idx: self.nums[last], self.nums[idx] = self.nums[idx], self.nums[last] self.dic[self.nums[idx]] = idx del self.dic[val] self.nums.pop() return True def getRandom(self): return random.choice(self.nums)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[]},{"title":"String Advanced","slug":"string-advanced","date":"2018-10-11T23:31:29.000Z","updated":"2018-11-16T01:28:23.792Z","comments":true,"path":"2018/10/11/string-advanced/","link":"","permalink":"http://kaihaoli.github.io/2018/10/11/string-advanced/","excerpt":"","text":"Sliding Window in a String Hash table 3. Longest Substring Without Repeating Characters123456789101112131415class Solution(object): def lengthOfLongestSubstring(self, s): visited = set() left = right = 0 cnt = 0 n = len(s) while right &lt; n: if s[right] not in visited: visited.add(s[right]) right += 1 cnt = max(cnt, right-left) else: visited.remove(s[left]) left += 1 return cnt ###159. Longest Substring with At Most Two Distinct Characters Two pointers: i - traversal, start - shrink to meet the condition! 12345678910111213141516171819class Solution(object): def lengthOfLongestSubstringTwoDistinct(self, s): chars = [0] * 256 start = 0 res = cnt = 0 for i in xrange(len(s)): idx = ord(s[i]) if chars[idx] == 0: cnt += 1 chars[idx] += 1 while cnt &gt; 2: # shrink idx = ord(s[start]) chars[idx] -= 1 if chars[idx] == 0: cnt -= 1 start += 1 res = max(res, i-start+1) return res 340. Longest Substring with At Most K Distinct Characters care about variables!!! always miss some statements 12345678910111213141516171819class Solution(object): def lengthOfLongestSubstringKDistinct(self, s, k): chars = [0] * 256 start = 0 res = cnt = 0 for i in xrange(len(s)): idx = ord(s[i]) if chars[idx] == 0: cnt += 1 chars[idx] += 1 while cnt &gt; k: idx = ord(s[start]) chars[idx] -= 1 if chars[idx] == 0: cnt -= 1 start += 1 res = max(res, i-start+1) return res 438. Find All Anagrams in a StringSol1. SortTime : O(n m logm) Sol2.Sliding Window12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findAnagrams(self, s, p): m, n = len(s), len(p) char_dic = collections.defaultdict(int) cnt = 0 # Init p : count char in p for ch in p: char_dic[ch] += 1 if char_dic[ch] == 1: cnt += 1 # Init sliding window for ch in s[:n]: if ch not in char_dic: continue char_dic[ch] -= 1 if char_dic[ch] == 0: cnt -= 1 res = [] if cnt == 0: res.append(0) # move the Fixed size sliding window for i in xrange(m-n): if s[i] in char_dic: char_dic[s[i]] += 1 if char_dic[s[i]] == 1: cnt += 1 if s[i+n] in char_dic: char_dic[s[i+n]] -= 1 if char_dic[s[i+n]] == 0: cnt -= 1 if cnt == 0: res.append(i+1) return res Flip 0 to 1Given a 0-1 array, you can flip at most k ‘0’s to ‘1’s.Please find the longest subarray that consists of all ‘1’s. Solution : Find a slinding window that contains at most k zeros. When to move the right border: when the counter of zeros &lt;=k When to move the left border: when the counter of zeros &gt;k Clarify the information contains in the sliding window when to move the pointer/border Read4157. Read N Characters Given Read4 fixed size 4 temp 1234567891011121314class Solution(object): def read(self, buf, n): cnt = 0 while cnt &lt; n: temp = [''] * 4 rd = read4(temp) to_copy = min(rd, n-cnt) for i in range(to_copy): buf[cnt] = temp[i] cnt += 1 if to_copy == 0: return cnt return cnt 158. Read N Characters Given Read4 II - Call multiple times123456789101112131415161718192021222324class Solution(object): def __init__(self): self.queue = collections.deque() def read(self, buf, n): cnt = 0 queue = self.queue while queue and cnt &lt; n: buf[cnt] = queue.popleft() cnt += 1 while cnt &lt; n: temp = [''] * 4 rd = read4(temp) for i in range(rd): queue.append(temp[i]) k = min(rd, n-cnt) for _ in range(k): buf[cnt] = self.queue.popleft() cnt += 1 if k == 0: return cnt return cnt","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"},{"name":"sliding window","slug":"sliding-window","permalink":"http://kaihaoli.github.io/tags/sliding-window/"}]},{"title":"Binary Search Advanced","slug":"binary-search-advanced","date":"2018-10-10T19:40:49.000Z","updated":"2018-12-04T14:34:51.378Z","comments":true,"path":"2018/10/10/binary-search-advanced/","link":"","permalink":"http://kaihaoli.github.io/2018/10/10/binary-search-advanced/","excerpt":"","text":"Advanced Topic 162. Find Peak Element12345678910111213class Solution(object): def findPeakElement(self, nums): nums = [-float('inf')] + nums + [-float('inf')] start, end = 1, len(nums) - 2 while start &lt;= end: mid = start + (end - start) / 2 if nums[mid] &lt;= nums[mid-1]: end = mid - 1 elif nums[mid] &lt;= nums[mid+1]: start = mid + 1 else: return mid-1 return -1 4. Median of Two Sorted Arrays Input Two Sorted Array. How to do Binary Search? Stick with the edge case, like len(nums) &lt;= 1 and len is odd or even!!! 1234567891011121314151617181920212223242526class Solution(object): def findMedianSortedArrays(self, nums1, nums2): m, n = len(nums1), len(nums2) if m &gt; n: return self.findMedianSortedArrays(nums2, nums1) start, end = 0, m k = (m + n) // 2 while start &lt;= end: cut1 = start + (end - start) // 2 cut2 = k - cut1 # Deal with edge case 1 : length l1 = nums1[cut1-1] if cut1 &gt; 0 else -float('inf') l2 = nums2[cut2-1] if cut2 &gt; 0 else -float('inf') r1 = nums1[cut1] if cut1 &lt; m else float('inf') r2 = nums2[cut2] if cut2 &lt; n else float('inf') if l1 &gt; r2: end = cut1 - 1 elif l2 &gt; r1: start = cut1 + 1 else: # Deal with the edge case 2 : odd or even! if (m+n) % 2: return min(r1, r2) else: return (max(l1,l2) + min(r1,r2)) / 2.0 29. Divide Two Integers Division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative i 1, 2, 4, 8, 16, 32, 64 … i 1, 2, 4, 8, … i … i 1 1234567891011121314151617# Same Thoughtclass Solution(object): def divide(self, dividend, divisor): np = (dividend &lt; 0) ^ (divisor &lt; 0) dividend = abs(dividend) divisor = abs(divisor) res = 0 while dividend &gt;= divisor: tmp, i = divisor, 1 while dividend &gt;= tmp: dividend -= tmp res += i i = i &lt;&lt; 1 tmp = tmp &lt;&lt; 1 if np: res = -res return min(max(-2147483648, res), 2147483647) clean 123456789101112131415161718class Solution(object): def divide(self, dividend, divisor): sign = (dividend &gt; 0) ^ (divisor &gt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 i = 1 div = divisor while dividend &gt;= div: dividend -= div res += i i = i &lt;&lt; 1 div = div &lt;&lt; 1 if dividend &lt; div: # when div bigger enough that dividend can not minus it i = 1 div = divisor if sign: res = -res return min(max(-2147483648, res), 2147483647) 658. Find K Closest Elements two pointers + binary search 12345678910111213141516class Solution(object): def findClosestElements(self, arr, k, x): if x &lt;= arr[0]: return arr[:k] elif x &gt;= arr[-1]: return arr[-k:] else: index = bisect.bisect_left(arr, x) left = max(0, index-k) right = min(len(arr)-1, index+k-1) while right - left &gt; k-1: if arr[right] - x &gt;= x - arr[left]: right -= 1 else: left += 1 return arr[left:right+1] 300. Longest Increasing Subsequence Use DP, we can have the O(n^2). It is hard to give the O(nlogn) solution 1234567891011121314151617181920class Solution(object): def lengthOfLIS(self, nums): if not nums: return 0 n = len(nums) ends = [nums[0]] for i in xrange(1, n): if nums[i] &gt; ends[-1]: ends.append(nums[i]) continue start, end = 0, len(ends)-1 while start &lt; end: mid = start + (end - start) / 2 if ends[mid] &lt; nums[i]: start = mid + 1 else: end = mid ends[start] = nums[i] return len(ends) 275. H-Index II1234567891011121314151617class Solution(object): def hIndex(self, citations): if not citations: return 0 n = len(citations) if citations[-1] &lt; 1: return 0 start, end = 0, n-1 while start &lt; end: mid = start + (end - start) // 2 if citations[mid] &gt;= n - mid: end = mid else: start = mid + 1 return n-start 774. Minimize Max Distance to Gas Station use valid function =&gt; Binary Search the results!!!12345678910111213class Solution(object): def minmaxGasDist(self, stations, K): def valid(D): return sum([int((p2-p1) / D) for p1, p2 in zip(stations, stations[1:])]) &lt;= K start, end = 0, stations[-1]-stations[0] while end - start &gt; 1e-6: mid = (start + end) / 2.0 if valid(mid): end = mid else: start = mid return start","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"binary search","slug":"binary-search","permalink":"http://kaihaoli.github.io/tags/binary-search/"}]},{"title":"Greedy Schedule","slug":"greedy-schedule","date":"2018-10-09T12:44:13.000Z","updated":"2018-11-07T20:18:27.264Z","comments":true,"path":"2018/10/09/greedy-schedule/","link":"","permalink":"http://kaihaoli.github.io/2018/10/09/greedy-schedule/","excerpt":"","text":"Interval Schedule435. Non-overlapping Intervals minimum number of removed intervels, maximum number of compatible intervals sort by end time !!! Why? 1234567891011121314class Solution(object): def eraseOverlapIntervals(self, intervals): if not intervals: return 0 intervals.sort(key = lambda x: x.end) cnt = 0 prev_end = -float('inf') for inter in intervals: start, end = inter.start, inter.end if start &gt;= prev_end: prev_end = end else: cnt += 1 return cnt 252. Meeting Rooms12345678class Solution: def canAttendMeetings(self, intervals): intervals.sort(key = lambda x:x.end) for i in range(1, len(intervals)): if intervals[i].start &lt; intervals[i-1].end: return False return True 253. Meeting Rooms II1234567891011121314151617class Solution(object): def minMeetingRooms(self, intervals): times = [] for inter in intervals: times.append((inter.start, 1)) times.append((inter.end, 0)) times.sort() cnt = 0 res = 0 for t, f in times: if f: cnt += 1 else: cnt -= 1 res = max(res, cnt) return res Deadline Schedule630. Course Schedule III12345678910class Solution(object): def scheduleCourse(self, courses): start = 0 heap = [] for t, d in sorted(courses, key = lambda (t,d):d): start += t heapq.heappush(heap, -t) while start &gt; d: start += heapq.heappop(heap) return len(heap) Arrive55. Jump Game Use reach array will cause TLE12345678910class Solution(object): def canJump(self, nums): n = len(nums) reach = 0 for i in xrange(n): if i &gt; reach: return False else: reach = max(reach, i+nums[i]) return reach &gt;= n-1 134. Gas Station1234567891011121314class Solution(object): def canCompleteCircuit(self, gas, cost): if sum(cost) &gt; sum(gas): return -1 n = len(gas) balance = 0 start = 0 for i in range(n): balance += gas[i] - cost[i] if balance &lt; 0: start = i + 1 balance = 0 return start","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"greedy","slug":"greedy","permalink":"http://kaihaoli.github.io/tags/greedy/"}]},{"title":"Hash Table","slug":"hash-table","date":"2018-10-08T14:48:07.000Z","updated":"2018-11-15T17:14:36.366Z","comments":true,"path":"2018/10/08/hash-table/","link":"","permalink":"http://kaihaoli.github.io/2018/10/08/hash-table/","excerpt":"","text":"A hash table (hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Hash Fucntion Hash Collision Separate chaining Open addressing Implement a Hash TableTODO 347. Top K Frequent Elements123456789101112class Solution(object): def topKFrequent(self, nums, k): cnt = collections.defaultdict(int) for n in nums: cnt[n] += 1 heap = [] for key in cnt.keys(): heapq.heappush(heap, (cnt[key], key)) if len(heap) == k+1: heapq.heappop(heap) return [key for c, key in heap] 268. Missing Number1234567class Solution(object): def missingNumber(self, nums): nset = set(nums) n = len(nums) for i in xrange(n+1): if i not in nset: return i 349. Intersection of Two ArraysTime : O(m + n), Space : O(m + n) 123class Solution(object): def intersection(self, nums1, nums2): return list(set(nums1)&amp;set(nums2)) Follow up : two sorted array Binary Search, Time : O(mlogn), Space : O(1) Two pointers, Time : O(m + n), Space : O(1) Find common elements in 3 sorted Arrays Solution1: three PointersHow to move each pointer Solution2: find common elements a1,a2 then a3 Counter299. Bulls and CowsWe usually use hash table to do things like counter!1234567891011121314151617class Solution(object): def getHint(self, secret, guess): bulls = 0 for ch1, ch2 in zip(secret, guess): if ch1 == ch2: bulls += 1 cnt = [0] * 10 for ch in secret: cnt[ord(ch)-ord('0')] += 1 common = 0 for ch in guess: if cnt[ord(ch)-ord('0')] != 0: common += 1 cnt[ord(ch)-ord('0')] -= 1 cows = common - bulls return str(bulls) + \"A\" + str(cows) + \"B\"","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"TODO","slug":"TODO","permalink":"http://kaihaoli.github.io/tags/TODO/"},{"name":"hash table","slug":"hash-table","permalink":"http://kaihaoli.github.io/tags/hash-table/"}]},{"title":"Depth First Search","slug":"dfs","date":"2018-10-07T18:35:05.000Z","updated":"2018-11-18T02:16:53.574Z","comments":true,"path":"2018/10/07/dfs/","link":"","permalink":"http://kaihaoli.github.io/2018/10/07/dfs/","excerpt":"","text":"BasicWe use DFS a lot in Tree or Graph. DFS can only be implemented by using recursion? No. It can be implemented by using either iterative way, or in a recursive way. it is easier to use recursion to implement. (pre,in,post order traversal iteration in tree) Method What dose it store on each level? How many different states should we try to put on the level? SubsetO(2^n) 78. SubsetsDifferent recursion ways with different recursion Tree! Sol1. Exist or notEach node has two braching subtree! 123456789101112131415161718# Time : O(2^n)class Solution(object): def subsets(self, nums): if not nums: return [] res = [] self.dfs(nums, 0, [], res) return res def dfs(self, nums, idx, path, res): if idx == len(nums): res.append(path) return # Other programming language, we have to append,than pop in the path # But in python, we just add it as parameter! self.dfs(nums, idx + 1, path + [nums[idx]], res) self.dfs(nums, idx + 1, path, res) Sol2. PositionEach level nodes have different number subtree 1234567891011121314# Time : Hard to Analyze!class Solution(object): def subsets(self, nums): if not nums: return [] res = [] self.dfs(nums, 0, [], res) return res def dfs(self, nums, idx, path, res): res.append(path) for i in xrange(idx, len(nums)): self.dfs(nums, i+1, path+[nums[i]], res) Sol3. Iteration123456class Solution(object): def subsets(self, nums): res = [[]] for num in nums: res += [item+[num] for item in res] return res 90. Subsets IISol1. 2 Branching12345678910111213141516171819class Solution(object): def subsetsWithDup(self, nums): res = [] nums.sort() self.dfs(nums, 0, [], res) return res def dfs(self, nums, idx, path, res): if idx == len(nums): res.append(path) return self.dfs(nums, idx + 1, path + [nums[idx]], res) while idx &lt; len(nums)-1 and nums[idx] == nums[idx+1]: idx += 1 self.dfs(nums, idx + 1, path, res) 123456789101112131415161718192021class Solution(object): def subsetsWithDup(self, nums): nums.sort() pairs = [] for num in nums: if not pairs or num != pairs[-1][0]: pairs.append([num, 1]) else: pairs[-1][1] += 1 self.res = [] self.dfs(pairs, 0, []) return self.res def dfs(self, pairs, idx, path): if idx == len(pairs): self.res.append(path) return num, cnt = pairs[idx] for k in range(cnt+1): self.dfs(pairs, idx+1, path + ([num] * k)) Sol2. Position Position recursion can remove duplicates by removing same brachings! 12345678910111213141516171819202122232425262728class Solution(object): def subsetsWithDup(self, nums): if not nums: return [] res = [] self.dfs(sorted(nums), 0, [], res) return res def dfs(self, nums, idx, path, res): res.append(path) for i in xrange(idx, len(nums)): if i &gt; idx and nums[i] == nums[i-1]: continue self.dfs(nums, i+1, path+[nums[i]], res) # Why we can not just append and pop new elements? # we should deep copy the results!!! def dfs1(self, nums, idx, path, res): res.append(copy.deepcopy(path)) for i in xrange(idx, len(nums)): if i &gt; idx and nums[i] == nums[i-1]: continue path.append(nums[i]) # python not suggested this way! self.dfs1(nums, i+1, path, res) path.pop() PermutationO(n!) 46. Permutations123456789101112class Solution(object): def permute(self, nums): res = [] self.dfs(res, nums, []) return res def dfs(self, res, nums, path): if not nums: res.append(path) for i in xrange(len(nums)): self.dfs(res, nums[:i]+nums[i+1:], path+[nums[i]]) TODO : Space Consuming 47. Permutations II123456789101112131415class Solution(object): def permuteUnique(self, nums): res = [] self.dfs(sorted(nums), res, []) return res def dfs(self, nums, res, path): if not nums: res.append(path) return for i in xrange(len(nums)): if i &gt; 0 and nums[i] == nums[i-1]: continue self.dfs(nums[:i]+nums[i+1:], res, path+[nums[i]]) 22. Generate Parentheses12345678910111213141516class Solution(object): def generateParenthesis(self, n): self.res = [] self.dfs( n, n, []) return self.res def dfs(self, left, right, path): if left == right == 0: self.res.append(''.join(path)) return if left &gt; 0: self.dfs(left - 1, right, path + ['(']) if right &gt; left: self.dfs(left, right - 1, path + [')'])","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://kaihaoli.github.io/tags/dfs/"}]},{"title":"Heap","slug":"heap","date":"2018-10-07T00:23:25.000Z","updated":"2018-11-16T02:21:23.894Z","comments":true,"path":"2018/10/06/heap/","link":"","permalink":"http://kaihaoli.github.io/2018/10/06/heap/","excerpt":"","text":"Heap, also called “Priority Queue” BasicDefinition value in any node is less than its decendent and root is the least element complete binary tree Max Heap means root is maximum element, Min Heap means root is minimum element unsorted bu follow rules above Operation insert, put the element in the last and swap up, O(logn) update, O(logn) get/top, get the root element, O(1) pop, delete the root element, O(logn) put the last element to the root heapify: transform unsorted array to a heap, O(n) Python Lib min heap heapq.heapify(iterable), O(c * n)This function is used to convert the iterable into a heap data structure. i.e. in heap order. heapq.heappush(heap, ele), O(logn)This function is used to insert the element mentioned in its arguments into heap. The order is adjusted, so as heap structure is maintained. heapq.heappop(heap), O(logn)This function is used to remove and return the smallest element from heap. The order is adjusted, so as heap structure is maintained. heapq.heappushpop(heap, ele)This function combines the functioning of both push and pop operations in one statement, increasing efficiency. Heap order is maintained after this operation. heapq.heapreplace(heap, ele)This function also inserts and pops element in one statement, but it is different from above function. In this, element is first popped, then element is pushed.i.e, the value larger than the pushed value can be returned. heapq.nlargest(k, iterable, key = fun)This function is used to return the k largest elements from the iterable specified and satisfying the key if mentioned. heapq.nsmallest(k, iterable, key = fun)This function is used to return the k smallest elements from the iterable specified and satisfying the key if mentioned. 1import heapq LintCode 544. Top k Largest NumbersSol1. Sort Time : O(nlogn)123class Solution: def topk(self, nums, k): return sorted(nums)[-k:][::-1] Sol2. Min heap Time : O(k + (n-k)logk) 1234567891011121314151617import heapqclass Solution: def topk(self, nums, k): heap = [] # Heapify k elements, O(k) heap = heapq.heapify(nums[:k]) #for i in xrange(k): # heapq.heappush(heap, nums[i]) # Keep pop out n-k elements, O((n-k)logk) n = len(nums) for i in xrange(k, n): heapq.heappush(heap, nums[i]) heapq.heappop(heap) return sorted(heap, reverse=True) Sol3. Max heap Time : O(n + klog(n)) Step1. Heapify, O(n) Step2. pop k elements, O(klogn) Sol4. Quick Partition Time : Amortized O(n), Worst Case : O(n^2) 218. The Skyline Problem1234567891011121314151617181920class Solution: def getSkyline(self, buildings): positions = set([b[0] for b in buildings] + [b[1] for b in buildings]) res = [[0, 0]] live = [] i = 0 for p in sorted(positions): # Keep all the position before p to the heap \"live\" while i &lt; len(buildings) and buildings[i][0] &lt;= p: heapq.heappush(live, (-buildings[i][2], buildings[i][1])) i += 1 # Keep the maximum height's position &gt; p while live and live[0][1] &lt;= p: heapq.heappop(live) h = -live[0][0] if live else 0 if h != res[-1][1]: res.append([p, h]) return res[1:] 857. Minimum Cost to Hire K Workers12345678910111213141516class Solution(object): def mincostToHireWorkers(self, quality, wage, K): workers = sorted([(float(w)/q, q) for q, w in zip(quality, wage)]) pool = [] qsum = 0 res = float('inf') for r, q in workers: heapq.heappush(pool, -q) qsum += q if len(pool) &gt; K: qsum += heapq.heappop(pool) if len(pool) == K: res = min(res, r * qsum) return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://kaihaoli.github.io/tags/heap/"}]},{"title":"String Basic","slug":"string-basic","date":"2018-10-05T15:26:11.000Z","updated":"2018-11-10T14:29:48.007Z","comments":true,"path":"2018/10/05/string-basic/","link":"","permalink":"http://kaihaoli.github.io/2018/10/05/string-basic/","excerpt":"","text":"Popular representation of characters: ASCII representation of a letter: A==65, a==97 Unicode : the latest version of Unicode contains a repertoire of more than 110,000 charaters covering 100 scripts and various symbols. RemovolChar RemovalRemove a/some particular chars from a String. Example: string input = “student”, remove “u and n” -&gt; output:”stdet” Attention : String and Array erase API!!! 123456789class Solution: def charRemoval(self, s, ch): chs = list(s) start = 0 for i in xrange(len(chs)): if chs[i] not in ch: chs[start] = chs[i] start += 1 retrun ''.join(chs[:start]) 27. Remove Element12345678class Solution(object): def removeElement(self, nums, val): start = 0 for i in xrange(len(nums)): if nums[i] != val: nums[start] = nums[i] start += 1 return start Char Removal IIRemove all leading/trailing and duplicate empty spaces(only leave one empty space if duplicated spaces happen) from the input string. De-duplication26. Remove Duplicates from Sorted ArrayWhat’s the phisical definition of the two pointers??? slow: all elements to the left hand side of slow pointer(excluding slow) are the final results to return fast: current index 1234567891011class Solution(object): def removeDuplicates(self, nums): if not nums: return 0 start = 1 for i in xrange(1, len(nums)): if nums[i] != nums[start-1]: nums[start] = nums[i] start += 1 return start follow up : what if we want to reserve 2 duplicate elements? 80. Remove Duplicates from Sorted Array II you can just compare the current pointer with slow - 2 position 1234567891011class Solution(object): def removeDuplicates(self, nums): if len(nums) &lt;= 2: return len(nums) slow = 2 for i in xrange(2, len(nums)): if nums[i] != nums[slow-2]: nums[slow] = nums[i] slow += 1 return slow follow up : what if we want to reserve k duplicate elements? Remove adjacent letters repeatedly Stack or Two pointers Reversal344. Reverse String two pointers : left, right or start, end123456789class Solution(object): def reverseString(self, s): chs = list(s) s, e = 0, len(s)-1 while s &lt; e: chs[s], chs[e] = chs[e], chs[s] s += 1 e -= 1 return ''.join(chs) 557. Reverse Words in a String III123456class Solution(object): def reverseWords(self, s): words = s.split() for i in xrange(len(words)): words[i] = words[i][::-1] return ' '.join(words) 186. Reverse Words in a String IIe.g. “I love Google” - “Google love I” sol1. split and reversebut not in-place in thie way! sol2. reverse twice(trick) reverse each words “I love Google” - “I evol elgooG” reverse the string “Google love I” 1234567891011121314151617181920class Solution(object): def reverseWords(self, str): n = len(str) # Step 1. reverse each word start = 0 for i in xrange(n+1): if i == n or str[i] == \" \": end = i-1 while start &lt; end: str[start], str[end] = str[end], str[start] start += 1 end -= 1 start = i + 1 # Step 2. reverse all the sentences start, end = 0, n-1 while start &lt; end: str[start], str[end] = str[end], str[start] start += 1 end -= 1 Dicussion The idea for “I LOVE GOOGLE” can be combined to form more complex prblem. e.g., if we have empty/leading/trailing spaces in the input. The idea can be extended to other probem as well! “abcdef” sift to the left by two steps “cdefab” step1. seperate reverse “bafedc” step2. reverse the word “cdefab” 189. Rotate Array use the same trick as we used in the reverse words in sentence!12345678910111213class Solution(object): def rotate(self, nums, k): n = len(nums) k = k % n self._reverse(nums, 0, n-k-1) self._reverse(nums, n-k, n-1) self._reverse(nums, 0, n-1) def _reverse(self, nums, start, end): while start &lt; end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 Char ReplaceWord Replacement“student” -&gt; “stuXXt”(den -&gt; XX) Two Pointers slow: all letters to the left hand side of slow are the results to return fast: fast index to scan the whole string follow ups1 = “_“, s2 = “20%” 833. Find And Replace in String Replaced String part is longer than original part, How do you deal with that? 1234567891011121314151617class Solution: def findReplaceString(self, S, indexes, sources, targets): n = len(indexes) res = [] prev = 0 for idx, src, target in sorted(zip(indexes, sources, targets)): if idx &gt; prev: res.append(S[prev:idx]) prev = idx if S[idx:idx+len(src)] != src: continue res.append(target) prev = idx + len(src) res.append(S[prev:]) return ''.join(res) 844. Backspace String Compare Traverse Backwards!!!1234567891011121314151617181920212223242526class Solution(object): def backspaceCompare(self, S, T): m, n = len(S), len(T) ps, pt = m-1, n-1 while ps &gt;= 0 or pt &gt;= 0: # S backS = 0 while ps &gt;= 0 and (backS &gt; 0 or S[ps] == '#'): backS += 1 if S[ps] == '#' else -1 ps -= 1 # T backT = 0 while pt &gt;= 0 and (backT &gt; 0 or T[pt] == '#'): backT += 1 if T[pt] == '#' else -1 pt -= 1 if (pt &lt; 0) ^ (ps &lt; 0): return False if pt &gt;= 0 and ps &gt;= 0 and S[ps] != T[pt]: return False pt -= 1 ps -= 1 return True String to Number8. String to Integer (atoi) Take Care of Edge Cases!!! 123456789101112131415161718192021222324class Solution: def myAtoi(self, str): n = len(str) p = 0 # filter the space while p &lt; n and str[p] == ' ': p += 1 # positive or negtive neg = False if p &lt; n and str[p] in \"+-\": if str[p] == '-': neg = True p += 1 num = 0 while p &lt; n and str[p].isnumeric(): num = num * 10 + int(str[p]) p += 1 if neg: num = -num return min(2**31-1, max(-2**31, num)) 65. Valid Number Define the state, Keep in mind : different states!!!12345678910111213141516171819202122232425class Solution: def isNumber(self, s): s = s.strip() states = [&#123;'+-': 2, '0-9': 1, '.': 3&#125;, &#123;'0-9': 1, 'e': 5, '.': 4&#125;, &#123;'0-9': 1, '.': 3&#125;, &#123;'0-9': 4&#125;, &#123;'0-9': 4, 'e': 5&#125;, &#123;'0-9': 7, '+-': 6&#125;, &#123;'0-9': 7&#125;, &#123;'0-9': 7&#125;] cur = 0 for ch in s: if ch.isdigit(): flag = \"0-9\" elif ch in \"+-\": flag = \"+-\" else: flag = ch if flag not in states[cur]: return False cur = states[cur][flag] return cur in [1, 4, 7] 504. Base 7123456789101112131415class Solution: def convertToBase7(self, num): if num == 0: return \"0\" sign = True if num &lt; 0 else False num = abs(num) base7 = [] while num &gt; 0: base7.append(str(num%7)) num = num // 7 if sign: base7.append(\"-\") res = ''.join(base7[::-1]) return res 12. Integer to Roman1234567891011121314151617181920class Solution: def intToRoman(self, num): roman = &#123;1000:'M', 500:'D', 100:'C', 50:'L', 10:'X', 5:'V', 1:'I'&#125; res = [] ns = [1000, 500, 100, 50, 10, 5, 1] for k in range(7): t = num // ns[k] if t == 0: continue num = num % ns[k] if t == 4: if len(res) == 0 or res[-1] != roman[ns[k-1]]: res.append(roman[ns[k]] + roman[ns[k-1]]) else: res.pop() res.append(roman[ns[k]] + roman[ns[k-2]]) else: res.append(roman[ns[k]] * t) return ''.join(res) Encode and Decode394. Decode String12345678910111213141516class Solution: def decodeString(self, s): stack = [[[], 1]] # repeat string array, times of repeat num = 0 for ch in s: if ch.isdigit(): num = num * 10 + (ord(ch) - ord('0')) elif ch == '[': stack.append([[], num]) num = 0 elif ch == ']': chs, k = stack.pop() stack[-1][0] += (chs * k) else: stack[-1][0].append(ch) return ''.join(stack[0][0]) Strobogrammatic Number246. Strobogrammatic Number123456789101112131415class Solution(object): def isStrobogrammatic(self, num): dic = &#123;0:0, 1:1, 6:9, 8:8, 9:6&#125; left, right = 0, len(num)-1 while left &lt;= right: l, r = int(num[left]), int(num[right]) if l not in dic or r not in dic: return False if dic[l] != r: return False left += 1 right -= 1 return True 247. Strobogrammatic Number II123456789101112131415161718192021class Solution(object): def findStrobogrammatic(self, n): self.n = n return self.helper(n) def helper(self, m): if m == 0: return [\"\"] if m == 1: return [\"0\", \"1\", \"8\"] sub = self.helper(m - 2) res = [] for s in sub: if m != self.n: res.append(\"0\" + s + \"0\") for can in [\"11\", \"88\", \"69\", \"96\"]: res.append(can[0] + s + can[1]) return res 248. Strobogrammatic Number III12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def strobogrammaticInRange(self, low, high): m, n = len(low), len(high) self.temp = &#123;0:[\"\"], 1:[\"1\", \"0\", \"8\"]&#125; self.memo = &#123;1:[\"1\", \"0\", \"8\"]&#125; res = [] for i in range(m, n+1): self.helper(i) cnt = 0 blow, bhigh = int(low), int(high) for i in range(n, m-1, -1): temp = self.memo[i] for item in temp: if blow &lt;= int(item) &lt;= bhigh: cnt += 1 return cnt def helper(self, k): if k in self.temp: return self.temp[k] sub = self.helper(k-2) res = [] for s in sub: for can in (\"11\", \"88\", \"69\", \"96\"): res.append(can[0] + s + can[1]) self.memo[k] = res ans = [] for s in sub: ans.append(\"0\" + s + \"0\") self.temp[k] = res + ans return res + ans String continuous count38. Count and Say123456789101112131415161718class Solution(object): def countAndSay(self, n): if n == 1: return \"1\" prev = self.countAndSay(n-1) ans = [] for ch in prev: if not ans or ch != ans[-1][0]: ans.append([ch, 1]) else: ans[-1][1] += 1 res = [] for ch, cnt in ans: res.append(str(cnt) + ch) return ''.join(res)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"string","slug":"string","permalink":"http://kaihaoli.github.io/tags/string/"}]},{"title":"Stack","slug":"stack","date":"2018-10-05T01:57:24.000Z","updated":"2018-11-22T23:31:31.542Z","comments":true,"path":"2018/10/04/stack/","link":"","permalink":"http://kaihaoli.github.io/2018/10/04/stack/","excerpt":"","text":"Logic Data Structure Queue FIFO == First In First Out, e.g. waith in a line Usages BFS related problems, Tree printout by levels Sliding Window problems(Deque) 225. Implement Stack using Queues Only use one Queue, O(n)push, O(1)pop Two Queues, O(1)push, O(n)pop12345queue = collections.deque()queue.append(1)queue.appendleft(2)queue.pop()queue.popleft() What is Stack? LIFO == Last in First Out, e.g. like a box All operation available: push(), pop(), top() Iterative DFS Discussion When do we consider “stack” in our algorithm? Answer: when we linear scan an array/a string from left to right, and we need to look back the top element! Find the biggest Rectangle in Histogram Reverse Polish notation, a (b + c) -&gt; abc+ String repeatedly deduplication. cabba -&gt; caa -&gt; c Design Data Structure232.Implement Queue using StacksImplement a Queue by using two stacks Key Point : When we pop all the elements from stack1 to stack2, we do not need to pop all the elements to stack1 again! Just put them to stack2 waiting for pop() function! Time : pop(),amortized O(1); push(),O(1) Space : O(n) 12345678910111213141516171819202122232425class MyQueue(object): def __init__(self): self.stack1 = [] # Buffer all the new elements self.stack2 = [] # Pop out the 1st element def push(self, x): self.stack1.append(x) def pop(self): if len(self.stack2) == 0: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): if len(self.stack2) == 0: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def empty(self): return len(self.stack1) == 0 and len(self.stack2) == 0 155. Min Stack Two Stack: original stack &amp; min stack 123456789101112131415161718192021# Keep the push and pop function in sync between two stacksclass MinStack(object): def __init__(self): self.stack = [] self.minstack = [] def push(self, x): self.stack.append(x) cmin = min(x, self.minstack[-1]) if self.minstack else x self.minstack.append(cmin) def pop(self): self.stack.pop() self.minstack.pop() def top(self): return self.stack[-1] def getMin(self): return self.minstack[-1] Min Stack Follow Up How to optimize the space usage of minstack? (Assume there are a lot of duplicates)Try to make the elements in stack2 a descending order and store an element in stack2 &lt;value, size of the stack1 when elements add to stack2&gt;1234567891011121314151617181920212223class MinStack: def __init__(self): self.stack = [] self.minStack = [] def push(self, x): self.stack.append(x) if not self.minStack or x &lt; self.minStack[-1][0]: self.minStack.append((x, len(self.stack))) def pop(self): self.stack.pop() if len(self.stack) &lt; self.minStack[-1][1]: self.minStack.pop() def top(self): return self.stack[-1] def getMin(self): return self.minStack[-1][0] 716. Max Stack popMax() – Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one. TreeMap in Java!!! 12345678910111213141516171819202122232425class MaxStack(object): def __init__(self): self.stack = [] def push(self, x): self.stack.append((x, max(x, self.stack[-1][1] if self.stack else None))) def pop(self): return self.stack.pop()[0] def top(self): return self.stack[-1][0] def peekMax(self): return self.stack[-1][1] def popMax(self): m = self.stack[-1][1] temp = [] while self.stack[-1][0] != m: temp.append(self.pop()) # temp.insert(0, self.stack.pop()) self.stack.pop() map(self.push, reversed(temp)) return m TODO : Using Stack for Selection Sort; Implement Deque using stacks 20. Valid Parentheses123456789101112class Solution(object): def isValid(self, s): stack = [] pdic = &#123;'(':')', '&#123;':'&#125;', '[':']'&#125; for ch in s: if ch in \"(&#123;[\": stack.append(pdic[ch]) else: if len(stack) == 0 or stack[-1] != ch: return False stack.pop() return len(stack) == 0 O(1) StackRemove 3 or more duplicates repeatedly Stack + traversal pointer 1234567891011121314151617181920def removeDuplicates(s): stack = [] i = 0 print(s) while i &lt; len(s): if len(stack) &gt; 1 and s[i] == stack[-1] == stack[-2]: while i &lt; len(s) and s[i] == stack[-1]: i += 1 stack.pop() stack.pop() else: stack.append(s[i]) i += 1 return stack# TESTif __name__ == \"__main__\": string = raw_input() res = removeDuplicates(string) print(res) Use Two pointers to imitate the stack!12345678910111213141516171819def removeDuplicates(s): i = 0 slow = -1 while i &lt; len(s): if slow &gt; 0 and s[i] == s[slow] == s[slow-1]: while i &lt; len(s) and s[i] == s[slow]: i += 1 slow -= 2 else: slow += 1 s[i], s[slow] = s[slow], s[i] i += 1 return s[:slow+1]# TESTif __name__ == \"__main__\": string = raw_input() res = removeDuplicates(list(string)) print(res) 844. Backspace String Compare Stack, Space : O(m + n) Two Pointers, Space : O(1) 12345678910111213141516171819202122232425class Solution(object): def backspaceCompare(self, S, T): p1, p2 = len(S)-1, len(T)-1 while p1 &gt;= 0 or p2 &gt;= 0: back1 = 0 while (p1 &gt;= 0 and S[p1] == '#') or back1 &gt; 0: back1 += 1 if S[p1] == '#' else -1 p1 -= 1 back2 = 0 while (p2 &gt;= 0 and T[p2] == '#') or back2 &gt; 0: back2 += 1 if T[p2] == '#' else -1 p2 -= 1 if p1 &lt; 0 and p2 &lt; 0: return True elif p1 &lt; 0 or p2 &lt; 0: return False else: if S[p1] != T[p2]: return False else: p1 -= 1 p2 -= 1 return p1 == p2","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"stack","slug":"stack","permalink":"http://kaihaoli.github.io/tags/stack/"}]},{"title":"Sort","slug":"array-sort","date":"2018-10-02T20:01:03.000Z","updated":"2018-11-12T21:09:39.482Z","comments":true,"path":"2018/10/02/array-sort/","link":"","permalink":"http://kaihaoli.github.io/2018/10/02/array-sort/","excerpt":"","text":"Selection SortThe selection sort algorithm sorts an array by repeatedly finding the minimum element from unsorted part and putting it at the beginning. Time : O(n^2), as there are two nested loops Space : O(1) (In-place) 12345678def selectionSort(nums): n = len(nums) for i in xrange(n): minIndex = i for j in xrange(i, n): if nums[j] &lt; nums[minIndex]: minIndex = j nums[i], nums[minIndex] = nums[minIndex], nums[i] Bubble SortBubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order. Time : O(n^2), Best Case : O(n) Space : O(1)123456def bubbleSort(nums): for i in xrange(len(nums)): for j in xrange(len(nums)-i-1): if nums[j] &gt; nums[j+1]: nums[j+1], nums[j] = nums[j], nums[j+1] return nums Insertion Sort Time : O(n^2), Best Case : O(n) when the elements are already sorted! Space : O(1) 12345678def insertionSort(nums): for i, num in enumerate(nums): j = i while j &gt; 0 and nums[j-1] &gt; num: nums[j] = nums[j-1] j -= 1 nums[j] = num return nums Merge sortIt divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. Time : O(nlogn) Space : O(n) 88. Merge Sorted ArrayMerge Two Sorted Array in Merge Sort Algorithms Three Pointers: nums1, nums2 and results 1234567891011121314151617class Solution(object): def merge(self, nums1, m, nums2, n): p1, p2 = m-1, n-1 idx = m+n-1 while p1 &gt;= 0 and p2 &gt;= 0: if nums2[p2] &gt; nums1[p1]: nums1[idx] = nums2[p2] p2 -= 1 else: nums1[idx] = nums1[p1] p1 -= 1 idx -= 1 while p2 &gt;= 0: nums1[idx] = nums2[p2] p2 -= 1 idx -= 1 Merge k sorted array Time : O(nlogk) sol1: Iterative way (Brute Force) sol2: Binary Reduction (Divide and Conquer) if very large,so data in disk : read and write logk times sol3: k pointers smallest element(Heap) if very large,so data in disk : read and write only 1 time Counting Inversions based on merge sort, count all the inversion paris! Quick SortIt picks an element as pivot and partitions the given array around the picked pivot. The key process in quickSort is partition().Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time. 1234567891011121314151617def partition(nums, l, r): pivot = nums[r] # pick last element as pivot low = l for i in xrange(l, r): if nums[i] &lt; pivot: nums[i], nums[low] = nums[low], nums[i] low += 1 nums[low], nums[r] = nums[r], nums[low] return lowdef quickSort(nums, l, r): if l &gt;= r: return pivot = partition(nums, l, r) quickSort(nums, l, pivot-1) quickSort(nums, pivot+1, r) 215. Kth Largest Element in an Array123456789101112131415161718192021222324class Solution(object): def findKthLargest(self, nums, k): l, r = 0, len(nums)-1 while l &lt;= r: idx = self.partition(nums, l, r) if idx &gt; k-1: r = idx - 1 elif idx &lt; k-1: l = idx + 1 else: return nums[idx] # Similar to Move Zeros! def partition(self, nums, l, r): if l &gt;= r: return l pivot = nums[r] low = l for i in xrange(l, r): if nums[i] &gt; pivot: nums[i], nums[low] = nums[low], nums[i] low += 1 nums[low], nums[r] = nums[r], nums[low] return low LintCode 80. Median1234567891011121314151617181920212223242526272829class Solution: \"\"\" @param nums: A list of integers @return: An integer denotes the middle number of the array \"\"\" def median(self, nums): n = len(nums) k = (n + 1) // 2 - 1 # index we want to find left, right = 0, len(nums)-1 while left &lt;= right: idx = self.partition(nums, left, right) if idx == k: break elif idx &lt; k: left = idx + 1 else: right = idx - 1 return nums[k] def partition(self, nums, left, right): pivot = nums[right] low = left for i in range(left, right): if nums[i] &lt; pivot: nums[i], nums[low] = nums[low], nums[i] low += 1 nums[low], nums[right] = nums[right], nums[low] return low 283. Move ZeroesMaintaining the relative order of the non-zero elements. 12345678910class Solution(object): def moveZeroes(self, nums): non0 = 0 n = len(nums) for i in xrange(n): if nums[i] != 0: nums[non0] = nums[i] non0 += 1 for i in xrange(non0, n): nums[i] = 0 12345678class Solution(object): def moveZeroes(self, nums): non0 = 0 n = len(nums) for i in xrange(n): if nums[i] != 0: nums[non0], nums[i] = nums[i], nums[non0] non0 += 1 Follow up : order can be changedThe order of all other elments can be changed. left and right pointer swap each number, it could change the order, but it reduces the operation number! this method actually is similar to the partition function in Quick Sort!!! 1234567891011121314151617181920212223242526class Solution(object): def moveZeroes(self, nums): left, right = 0, len(nums)-1 while left &lt; right: while left &lt; right and nums[left] != 0: left += 1 while left &lt; right and nums[right] == 0: right -= 1 nums[left], nums[right] = nums[right], nums[left] print(\"operation\") left += 1 right -= 1# Simplified Versionclass Solution(object): def moveZeroes(self, nums): left, right = 0, len(nums)-1 while left &lt; right: if nums[left] != 0: left += 1 elif nums[right] == 0: right -= 1 else: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 Rainbow Sort75. Sort ColorsSol1. Counting Sorttwo-pass algorithm12345678910111213# Time : O(n)# Space : O(n)class Solution(object): def sortColors(self, nums): cnt = collections.defaultdict(int) for num in nums: cnt[num] += 1 p = 0 for i in xrange(3): for _ in xrange(cnt[i]): nums[p] = i p += 1 Sol2. Dutch Partitioning Problemone-pass algorithm1234567891011121314class Solution(object): def sortColors(self, nums): l, r = 0, len(nums)-1 i = 0 while i &lt;= r: if nums[i] == 0: nums[l], nums[i] = nums[i], nums[l] l += 1 i += 1 # missing part elif nums[i] == 1: i += 1 else: nums[i], nums[r] = nums[r], nums[i] r -= 1 Wiggle Sort280. Wiggle SortSolution1. Sort Time : O(nlogn)12345class Solution(object): def wiggleSort(self, nums): nums.sort() for i in range(2, len(nums), 2): nums[i], nums[i-1] = nums[i-1], nums[i] Solution2. One Pass Time : O(n)12345class Solution(object): def wiggleSort(self, nums): for i in range(1, len(nums)): if (i % 2 == 0 and nums[i] &gt; nums[i-1]) or (i % 2 == 1 and nums[i] &lt; nums[i-1]): nums[i], nums[i-1] = nums[i-1], nums[i] 324. Wiggle Sort II12345678class Solution(object): def wiggleSort(self, nums): temp = sorted(nums) n = len(nums) for i in range(1, n, 2): nums[i] = temp.pop() for i in range(0, n, 2): nums[i] = temp.pop() Big dataSort with small memoryGiven a single computer with a single CPU and a single core, which has 2GB of memory and 1GB available for use, it also has two 100GB hard drives. How to sort 80GB integers of 64bits.? External Sort 400 chunks. Use 1GB memory to sort each 0.2GB. =&gt; write to disk 400-way mergechunk1 xxxxxx xxxxxxxxxxxxxxxchunk2 yyyyyy yyyyyyyyyyyyyyy…chunk400 zzzzzz zzzzzzzzzzzzzzzread from each chunk, block by block, insert into a min Heap. result block Why read one block by block instead of one by one? File IO!!!","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"array","slug":"array","permalink":"http://kaihaoli.github.io/tags/array/"}]},{"title":"pramp","slug":"pramp","date":"2018-09-30T19:57:10.000Z","updated":"2018-11-10T03:30:22.536Z","comments":true,"path":"2018/09/30/pramp/","link":"","permalink":"http://kaihaoli.github.io/2018/09/30/pramp/","excerpt":"","text":"Communication diagram small talk How are you? Im doing great! Thank you for the interview! Have a good night! / Have a nice day! interviewer can you hear me? can i assume that … ? walk through a small example / some test cases It looks good for me / Sounds good! Im not sure why you … ? in the line … can you analyze the time and space complexity? the question said that … there are some typo in your code clarify your idea I will be the interviewer fist make sense / make no sense on the right track you get the point! you can use either BFS or DFS Go ahead! interviewee Let me give you a small example double check my code write some test cases to test my funciton as we can see analyze different cases first Lets say … variable … Can you share a small example for me? make sure that i understand the question! Tree can we assume that class node has parent pointer? Sales Path Find the minimal sum cost from root to leaf in a Tree (Not necessarily binary) 123456789# Time : O(n), Space : O(n)def get_cheapest_cost(rootNode): if not rootNode.children: return rootNode.cost minCost = float('inf') for child in rootNode.children: minCost = min(minCost, get_cheapest_cost(child)) return minCost + rootNode.cost follow up:TODO BST Successor SearchIn a Binary Search Tree (BST), an Inorder Successor of a node is defined as the node with the smallest key greater than the key of the input node (see examples below). Given a node inputNode in a BST, you’re asked to write a function findInOrderSuccessor that returns the Inorder Successor of inputNode. If inputNode has no Inorder Successor, return null. 123456789101112131415161718def find_in_order_successor(self, inputNode): if not inputNode: return None if not inputNode.right: # dose not have right subtree parent = inputNode.parent if not parent: # root node return None while parent: if parent.key &gt; inputNode.key: return parent parent = parent.parent return None else:# have right subree cur = inputNode.right while cur.left: cur = cur.left return cur Case1 : inputNode has a right child. In this case successorNode would be the node with the minimum key in inputNode’s right subtree. Case2: inputNode doesn’t have a right child. In this case successorNode would be one of inputNode’s ancestors. More specifically, within inputNode’s ancestor chain (starting from inputNode all the way up to the root), successorNode is the first parent that has a left child in that chain. OtherH-Tree ConstructionWrite a function drawHTree that constructs an H-tree, given its center (x and y coordinates), a starting length, and depth. Assume that the starting line is parallel to the X-axis. Use the function drawLine provided to implement your algorithm. In a production code, a drawLine function would render a real line between two points. However, this is not a real production environment, so to make things easier, implement drawLine such that it simply prints its arguments (the print format is left to your discretion). Analyze the time and space complexity of your algorithm. In your analysis, assume that drawLine’s time and space complexities are constant, i.e. O(1). 12345678910111213141516171819202122232425262728293031 1 1 1 1 11 1 1 1 import mathdef drawLine(p1, p2): # draw line# Time : O(4^depth)# Space : O(depth) def drawHTree(x, y, length, depth): if depth == 0: return # horizontal segment \"-\" x1 = x - length / 2 x2 = x + length / 2 drawLine((x1, y), (x2, y)) # left &amp; right vertical segment '|' y1 = y - length / 2 y2 = y + length / 2 drawLine((x1, y1), (x1, y2)) drawLine((x2, y1), (x2, y2)) # Recursion new_len = length / math.sqrt(2) drawHTree((x1, y1), new_length, depth - 1) drawHTree((x1, y2), new_length, depth - 1) drawHTree((x2, y1), new_length, depth - 1) drawHTree((x2, y2), new_length, depth - 1) Getting a Different NumberGiven an array arr of unique nonnegative integers, implement a function getDifferentNumber that finds the smallest nonnegative integer that is NOT in the array.12345678# Time : O(n)# Space : O(n)def get_different_number(arr): n = len(arr) arr_set = set(arr) for i in xrange(n+1): if i not in arr_set: return i Array Index &amp; Element EqualityGiven a sorted array arr of distinct integers, write a function indexEqualsValueSearch that returns the lowest index i for which arr[i] == i. Return -1 if there is no such index. Binary Search Edge case 123456789101112131415161718192021# Time : O(logn)# Space : O(1)def index_equals_value_search(arr): if not arr: return -1 start, end = 0, len(arr)-1 while start &lt; end: mid = start + (end - start) // 2 if arr[mid] == mid: end = mid elif arr[mid] &gt; mid: end = mid - 1 else: start = mid + 1 # post processing if arr[start] == start: return start else: return -1 Number of PathsGiven n, the size of the grid’s axes, write a function numOfPathsToDest that returns the number of the possible paths the driverless car can take. 12345678910111213141516171819def num_of_paths_to_dest(n): # Init dp #dp = [[0] * n for _ in xrange(n)] dp = [1] * n # calculate the number for i in xrange(1, n): for j in xrange(i+1, n): dp[j] += dp[j-1] return dp[-1]def test(): print(num_of_paths_to_dest(4))test()# Time : O(n^2) Space : O(n^2)# Improved Space : O(n) ExplanationSince the car can only move up and move down, when it arrives at a point, there are two possibilities: It arrives at the point from below cell (move up to the point) It arrives at the point from left cell (move right to the point) Sentence Reverse Solution1. python built-in function 123456# Time : O(n), Spacce : O(n)def reverse_words1(arr): string = ''.join(arr) chs = string.split() res = ' '.join(chs[::-1]) return list(res) Solution2. Reverse Twice First: reverse all the word!I love google -&gt; I evol elgoog Second: reverse the string character by charaterI evol elgoog -&gt; google love I 123456789101112131415161718192021# Space O(n) -&gt; O(1)def reverse_words(arr): # First Reverse start = 0 for i in xrange(len(arr)+1): if i == len(arr) or arr[i] == ' ': # condition end = i - 1 while start &lt; end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 start = i + 1 # Second Reverse start, end = 0, len(arr)-1 while start &lt; end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 return arr Matrix Spiral CopyGiven a 2D array (matrix) inputMatrix of integers, create a function spiralCopy that copies inputMatrix’s values into a 1D array in a spiral order, clockwise. Your function then should return that array. Analyze the time and space complexities of your solution. 123456789101112131415161718192021222324class Solution: def spiralOrder(self, matrix): if not matrix: return [] m, n = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] k = 0 visited = set() x = y = 0 res = [] while len(res) &lt; m * n: res.append(matrix[x][y]) visited.add((x, y)) dx, dy = directions[k] nx, ny = x+dx, y+dy if (nx, ny) not in visited and 0 &lt;= nx &lt;= m-1 and 0 &lt;= ny &lt;= n-1: x, y = nx, ny else: # need to change direction k = (k + 1) % 4 dx, dy = directions[k] x, y = x+dx, y+dy return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[]},{"title":"Buy and Sell Stock","slug":"topic-buy-and-sell-stock","date":"2018-09-30T00:08:40.000Z","updated":"2018-10-29T13:50:37.500Z","comments":true,"path":"2018/09/29/topic-buy-and-sell-stock/","link":"","permalink":"http://kaihaoli.github.io/2018/09/29/topic-buy-and-sell-stock/","excerpt":"","text":"121. Best Time to Buy and Sell Stock Complete at most one transaction We can get max profit when we buy on the lowest price and sell on the highest price! we need to find $max(prices[j] - prices[i])$, for every i and j such that j &gt; ij&gt;i.1234567891011class Solution(object): def maxProfit(self, prices): if not prices: return 0 minp = prices[0] maxProfit = 0 for i in xrange(1, len(prices)): minp = min(minp, prices[i]) maxProfit = max(maxProfit, prices[i] - minp) return maxProfit 122. Best Time to Buy and Sell Stock II Complete as many transactions as you like Greedy Algorithms 1234567class Solution(object): def maxProfit(self, prices): res = 0 for i in xrange(1, len(prices)): if prices[i] &gt; prices[i-1]: res += prices[i]-prices[i-1] return res 122. Best Time to Buy and Sell Stock III Complete at most two transactions 12345678910111213141516171819class Solution(object): def maxProfit(self, prices): n = len(prices) if n &lt;= 0: return 0 left = [0] * n minp = prices[0] for i in xrange(1, len(prices)): minp = min(minp, prices[i]) left[i] = max(left[i-1], prices[i] - minp) maxp = prices[-1] right = [0] * (n) res = 0 for i in xrange(len(prices)-2, -1, -1): maxp = max(maxp, prices[i]) right[i] = max(maxp - prices[i], right[i+1]) res = max(res, right[i] + (left[i-1] if i &gt; 1 else 0)) return res 188. Best Time to Buy and Sell Stock IV Complete at most k transactions Watch Out: when k &gt; n/2, you can use greedy algorithm from II 123456789101112131415161718192021222324class Solution: def maxProfit(self, k, prices): if not prices or k == 0: return 0 n = len(prices) if k &gt; n // 2: return self.helper(prices) glob = [[0] * (k+1) for _ in range(n)] local = [[0] * (k+1) for _ in range(n)] for i in range(1, n): diff = prices[i] - prices[i-1] for j in range(1, k+1): local[i][j] = max(glob[i-1][j-1], local[i-1][j]) + diff glob[i][j] = max(glob[i-1][j], local[i][j]) return glob[-1][-1] def helper(self, prices): res = 0 for i in range(1, len(prices)): res += max(0, prices[i] - prices[i-1]) return res Why do we need local and global two dp states? 123456789101112131415161718192021222324class Solution: def maxProfit(self, k, prices): if not prices or k == 0: return 0 n = len(prices) if k &gt; n // 2: return self.helper(prices) hold = [[0] * (k+1) for _ in range(n)] unhold = [[0] * (k+1) for _ in range(n)] hold[0][0] = -prices[0] for i in range(1, n): hold[i][0] = max(hold[i-1][0], -prices[i]) for i in range(k+1): hold[0][i] = -prices[0] for i in range(1, n): for j in range(1, k+1): hold[i][j] = max(hold[i-1][j], unhold[i-1][j]-prices[i]) unhold[i][j] = max(unhold[i-1][j], hold[i-1][j-1]+prices[i]) return unhold[-1][-1] 309. Best Time to Buy and Sell Stock with Cooldown The natural states for this problem is the 3 possible transactions : buy, sell, rest. Here rest means no transaction on that day (aka cooldown). 12345678910111213class Solution: def maxProfit(self, prices): if not prices: return 0 n = len(prices) buy = [0] * n sell = [0] * n buy[0] = -prices[0] for i in range(1, n): buy[i] = max(buy[i-1], (sell[i-2] if i &gt; 1 else 0) - prices[i]) sell[i] = max(sell[i-1], buy[i-1] + prices[i]) return sell[-1] 1234567891011121314class Solution: def maxProfit(self, prices): if not prices: return 0 n = len(prices) buy = -prices[0] prev_sell = sell = 0 for i in range(1, n): prev_buy = buy buy = max(buy, prev_sell - prices[i]) prev_sell = sell sell = max(sell, buy + prices[i]) return sell 714. Best Time to Buy and Sell Stock with Transaction Fee12345678910111213class Solution: def maxProfit(self, prices, fee): if not prices: return 0 n = len(prices) sell = [0] * n buy = [0] * n buy[0] = -prices[0] for i in range(1, n): buy[i] = max(buy[i-1], sell[i-1]-prices[i]) sell[i] = max(sell[i-1], buy[i-1]+prices[i]-fee) return sell[-1] SummaryStates Definition Then the transaction sequences can end with any of these three states.For each of them we make an array, buy[n], sell[n] and rest[n]. buy[i] means before day i what is the maxProfit for any sequence end with buy. sell[i] means before day i what is the maxProfit for any sequence end with sell. rest[i] means before day i what is the maxProfit for any sequence end with rest. Hold and Unhold hold[i] means before day i what is the maxProfit for any sequence end with holding stock. unhold[i] means before day i what is the matProfit for any sequence end with unholding stock. Induction RuleTODO Space ImprovingTODO","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"},{"name":"topic","slug":"topic","permalink":"http://kaihaoli.github.io/tags/topic/"}]},{"title":"Binary Search Tree","slug":"binary-search-tree","date":"2018-09-25T15:43:15.000Z","updated":"2018-11-18T02:17:02.460Z","comments":true,"path":"2018/09/25/binary-search-tree/","link":"","permalink":"http://kaihaoli.github.io/2018/09/25/binary-search-tree/","excerpt":"","text":"Binary Search Tree: for every single node in the tree, the values in its left subtree are all smaller than its value, and the values in its right subtree are all larger than its value. any(left_substree) &lt; root.val &lt; any(right_subtree) for every sigle node in the tree for normal BST, we do not consider equal! ValidationYou have to know the definition of BST and how to use recursion to do validation! 98. Validate Binary Search TreeSol1. Primitive IdeaTime : O(n * h)for each node, check all its left-subtree, to determine whether they all smaller, check all its right-subtree, to determine wheter they are all larger. Sol2. Range123456789101112131415# Time : O(n), Space : O(h)class Solution(object): def isValidBST(self, root): return self.helper(root, -float('inf'), float('inf')) def helper(self, root, tmin, tmax): if not root: return True # BST 是不能有等于的！ if root.val &gt;= tmax or root.val &lt;= tmin: return False return (self.helper(root.left, tmin, root.val) and self.helper(root.right, root.val, tmax)) Sol3. Inorder TraversalBST Inorder traversal you will get an strictly increasing array!**123456789101112131415161718# Time : O(n), Space : O(n)class Solution(object): def isValidBST(self, root): res = [] self.dfs(root, res) for i in xrange(len(res)-1): if res[i+1] &lt;= res[i]: return False return True def dfs(self, root, res): if not root: return self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) 123456789101112131415161718# Time : O(n), Space : O(h)class Solution(object): def isValidBST(self, root): self.prev = None self.is_bst = True self.dfs(root) return self.is_bst def dfs(self, root): if not root: return self.dfs(root.left) if self.prev is not None and root.val &lt;= self.prev: self.is_bst = False return self.prev = root.val self.dfs(root.right) Insert &amp; Delete701. Insert into a Binary Search Tree12345678910# Time : O(height), Space : O(height)class Solution(object): def insertIntoBST(self, root, val): if not root: return TreeNode(val) if val &gt; root.val: root.right = self.insertIntoBST(root.right, val) else: root.left = self.insertIntoBST(root.left, val) return root 450. Delete Node in a BST1234567891011121314151617181920212223class Solution(object): def deleteNode(self, root, key): if not root: return None if key &gt; root.val: root.right = self.deleteNode(root.right, key) elif key &lt; root.val: root.left = self.deleteNode(root.left, key) else: if not root.left and not root.right: return None elif not root.left or not root.right: return root.left if root.left else root.right else: # Trick Point : swap the largest number in its left subree with current node # then we recursion delete the new val in its subtree cur = root.right while cur.left: cur = cur.left root.val = cur.val root.right = self.deleteNode(root.right, cur.val) return root Search700. Search in a Binary Search TreeTotally based on the definition of BST! 12345678910111213141516171819202122232425# RecursionTime : O(h), Space : O(h)class Solution(object): def searchBST(self, root, val): if not root: return None if root.val == val: return root elif root.val &gt; val: return self.searchBST(root.left, val) else: return self.searchBST(root.right, val)# IterationTime : O(h), Space : O(1)class Solution(object): def searchBST(self, root, val): cur = root while cur: if cur.val == val: return cur elif cur.val &lt; val: cur = cur.right else: cur = cur.left return None LintCode 11. Search Range in Binary Search Tree123456789101112131415161718class Solution: def searchRange(self, root, k1, k2): self.res = [] self.dfs(root, k1, k2) return self.res def dfs(self, root, k1, k2): if not root: return if k1 &lt; root.val: self.dfs(root.left, k1, k2) if k1 &lt;= root.val &lt;= k2: self.res.append(root.val) if root.val &lt; k2: self.dfs(root.right, k1, k2) 938. Range Sum of BST1234567891011121314class Solution(object): def rangeSumBST(self, root, L, R): if not root: return 0 if L &gt; root.val: return self.rangeSumBST(root.right, L, R) if R &lt; root.val: return self.rangeSumBST(root.left, L, R) left = self.rangeSumBST(root.left, L, R) right = self.rangeSumBST(root.right, L, R) return left + right + root.val 270. Closest Binary Search Tree Value Binary Search Tree actually seperate ordered list to three part, less than root.val, root.val, more than root.val instead of two part! 123456789101112131415class Solution(object): def closestValue(self, root, target): cur = root res = cur.val while cur: if abs(cur.val - target) &lt; abs(res - target): res = cur.val if cur.val == target: return cur.val elif cur.val &lt; target: cur = cur.right else: cur = cur.left return res 272. Closest Binary Search Tree Value IISol1. Inorder Traversal Time : O(n) 12345678910111213141516171819class Solution(object): def closestKValues(self, root, target, k): res = [] self.dfs(root, res) # Two Pointer Shrink left, right = 0, len(res)-1 while right - left + 1 &gt; k: if abs(res[left] - target) &lt; abs(res[right] - target): right -= 1 else: left += 1 return res[left:right+1] def dfs(self, root, res): if not root: return self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) follow up : Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)? What if we have parent node? Sol2. Successor &amp; Predecessor Key point : How to find the Successor and Predecessor in BST Q : for every node in BST, 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def getPredecessor(self, pre): cur = pre.pop() cur = cur.left while cur: pre.append(cur) cur = cur.right def getSuccessor(self, suc): cur = suc.pop() cur = cur.right while cur: suc.append(cur) cur = cur.left def closestKValues(self, root, target, k): pre, suc = [], [] # Init pre &amp; suc cur = root while cur: if cur.val &lt;= target: pre.append(cur) cur = cur.right else: suc.append(cur) cur = cur.left res = [] for _ in xrange(k): if len(suc) == 0 or (len(pre) &gt; 0 and abs(pre[-1].val - target) &lt; abs(suc[-1].val - target)): res.append(pre[-1].val) self.getPredecessor(pre) else: res.append(suc[-1].val) self.getSuccessor(suc) return res 530. Minimum Absolute Difference in BST Inorder Traversal 123456789101112131415class Solution(object): def getMinimumDifference(self, root): self.res = float('inf') self.dfs(root, [-float('inf')]) return self.res def dfs(self, root, prev): if not root: return self.dfs(root.left, prev) if prev: self.res = min(self.res, root.val - prev[-1]) prev[-1] = root.val self.dfs(root.right, prev) Build a BST108. Convert Sorted Array to Binary Search Tree123456789class Solution(object): def sortedArrayToBST(self, nums): if not nums: return None mid = len(nums) / 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 109. Convert Sorted List to Binary Search Tree1234567891011121314151617181920class Solution(object): def sortedListToBST(self, head): if not head: return None if not head.next: return TreeNode(head.val) # Find mid slow, fast = head, head.next.next while fast and fast.next: slow = slow.next fast = fast.next.next root = TreeNode(slow.next.val) nxt = slow.next.next slow.next = None root.left = self.sortedListToBST(head) root.right = self.sortedListToBST(nxt) return root Iterator173. Binary Search Tree IteratorIf we use Two Stack to solve PostOrder Traversal, Problem “Inorder Traversal” is more complexity than other two traversal! Whether it is or not a binary search tree, the solutions are the same! 1 push element to the stack until its left node is none 2 pop a node from the stack, traverse its right subtree Inorder Traversal Seperated two parts! 123456789101112131415161718class BSTIterator(object): def __init__(self, root): cur = root self.stack = [] while cur: self.stack.append(cur) cur = cur.left def hasNext(self): return len(self.stack) &gt; 0 def next(self): node = self.stack.pop() cur = node.right while cur: self.stack.append(cur) cur = cur.left return node.val","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"DP - Double Sequence","slug":"dp-double-sequence","date":"2018-09-19T18:56:15.000Z","updated":"2018-11-30T17:23:22.779Z","comments":true,"path":"2018/09/19/dp-double-sequence/","link":"","permalink":"http://kaihaoli.github.io/2018/09/19/dp-double-sequence/","excerpt":"","text":"Input Parameters have two Sequences or Strings Two Sequences Matching? 1 LongestLintCode 79. Longest Common Substring1234567891011class Solution: def longestCommonSubstring(self, A, B): m, n = len(A), len(B) dp = [[0] * (n+1) for _ in range(m+1)] res = 0 for i in range(m): for j in range(n): if A[i] == B[j]: dp[i+1][j+1] = dp[i][j] + 1 res = max(res, dp[i+1][j+1]) return res LintCode 77. Longest Common Subsequence State : dp[i][j] means Longest Common Subsequence for A[0…i-1] and B[0…j-1] Init : dp[i][0] = dp[0][j] = 0 Deduction Formula : 123456789101112131415# Time : O(mn), Space : O(mn)class Solution: def longestCommonSubsequence(self, A, B): m, n = len(A), len(B) if m == 0 or n == 0: return 0 dp = [[0] * (n+1) for _ in xrange(m+1)] for i in xrange(1, m+1): for j in xrange(1, n+1): if A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1] Space Improvementdp[i][j] -&gt; dp[i % 2][j] 123456789101112131415# Space : O(n)class Solution: def longestCommonSubsequence(self, A, B): m, n = len(A), len(B) if m == 0 or n == 0: return 0 dp = [[0] * (n+1) for _ in xrange(2)] for i in xrange(1, m+1): for j in xrange(1, n+1): if A[i-1] == B[j-1]: dp[i % 2][j] = dp[(i-1) % 2][j-1] + 1 else: dp[i % 2][j] = max(dp[(i-1) % 2][j], dp[i % 2][j-1]) return dp[m % 2][-1] 2 Exist10. Regular Expression Matching Case Analysis!!!123456789101112131415161718class Solution(object): def isMatch(self, s, p): m, n = len(s), len(p) dp = [[False] * (n+1) for _ in range(m+1)] dp[0][0] = True for i in range(n): if p[i] == \"*\": dp[0][i+1] = dp[0][i-1] for i in range(m): for j in range(n): if s[i] == p[j] or p[j] == '.': dp[i+1][j+1] = dp[i][j] elif p[j] == '*': dp[i+1][j+1] = dp[i+1][j-1] if p[j-1] == '.' or p[j-1] == s[i]: dp[i+1][j+1] = dp[i+1][j+1] or dp[i][j+1] return dp[-1][-1] 97. Interleaving String Three String!!1234567891011121314151617181920212223class Solution(object): def isInterleave(self, s1, s2, s3): m, n, l = len(s1), len(s2), len(s3) if m + n != l: return False dp = [[False] * (n+1) for _ in range(m+1)] dp[0][0] = True for i in range(m): if s1[i] == s3[i]: dp[i+1][0] = dp[i][0] for j in range(n): if s2[j] == s3[j]: dp[0][j+1] = dp[0][j] for i in range(m): for j in range(n): if s3[i+j+1] == s1[i]: dp[i+1][j+1] = dp[i+1][j+1] or dp[i][j+1] if s3[i+j+1] == s2[j]: dp[i+1][j+1] = dp[i+1][j+1] or dp[i+1][j] return dp[-1][-1] 3 Count72. Edit Distance1234567891011121314class Solution(object): def minDistance(self, word1, word2): m, n = len(word1), len(word2) dp = [[0] * (n+1) for _ in xrange(m+1)] for i in xrange(m): dp[i+1][0] = i+1 for i in xrange(n): dp[0][i+1] = i+1 for i in xrange(m): for j in xrange(n): dp[i+1][j+1] = min(dp[i][j+1]+1, dp[i+1][j]+1, dp[i][j] + (word1[i] != word2[j])) return dp[-1][-1] 161. One Edit Distance a littel like “Edit Distance”, but totally different solution!!! no dp here! 1234567891011121314151617181920class Solution(object): def isOneEditDistance(self, s, t): if len(s) &lt; len(t): return self.isOneEditDistance(t, s) m, n = len(s), len(t) if m - n &gt; 1: return False if m - n == 1: for i in xrange(n): if s[i] != t[i]: return s[i+1:] == t[i:] return True if m == n: for i in xrange(m): if s[i] != t[i]: return s[i+1:] == t[i+1:] return False 801. Minimum Swaps To Make Sequences Increasing Stateswap[i]: The cost of making both sequences increasing up to the first i columns in condition that we swap A[i] and B[i]notswap: The cost of making both sequences increasing up to the first i columns in condition that we do not swap A[i] and B[i] Init : swap[0] = 1; notswap[0] = 0 12345678910111213141516171819class Solution(object): def minSwap(self, A, B): n = len(A) swap, notswap = [1001] * n, [1001] * n swap[0] = 1 notswap[0] = 0 for i in range(1, n): # Case 1 : strictly increasing, swap 2 or not if A[i-1] &lt; A[i] and B[i-1] &lt; B[i]: swap[i] = swap[i-1] + 1 notswap[i] = notswap[i-1] # Case 2 : swap position i-1 or swap position i if A[i-1] &lt; B[i] and B[i-1] &lt; A[i]: swap[i] = min(swap[i], notswap[i-1] + 1) notswap[i] = min(notswap[i], swap[i-1]) return min(swap[n-1], notswap[n-1]) 我总是想记录上一个有没有swap，来record最优解，困于DFS的写法了！ 跳开DFS的方式还是定义对DP的State，如果能想到定义两个State一个表示Swap一个表示不Swap，后面思路就很顺了！","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"Dynamic Programming Overview","slug":"dp-overview","date":"2018-09-18T15:52:12.000Z","updated":"2018-10-14T14:48:20.845Z","comments":true,"path":"2018/09/18/dp-overview/","link":"","permalink":"http://kaihaoli.github.io/2018/09/18/dp-overview/","excerpt":"","text":"Overview Big Name 公司必考，难度中上 题目类型多，没有固定模板 1 问题引入Fibonacci F(n) = F(n-1) + F(n-1) Base Case : F(0) = 0, F(1) = 1 1234public int fibN(int n) &#123; if (n == 0 || n == 1) return n; // base case return fibN(n-1) + fibN(n-2); // recursice rule&#125; 1234567891011public int fibN(int n) &#123; int[] dp = new int[n+1]; dp[0] = 0; // base case dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i-1] + dp[i-2]; // dp[2] = dp[0] + dp[1] // dp[2] = dp[1] + dp[2]; &#125; return dp[n];&#125; 2 核心思想类似于高中学习的数学归纳法 把一个大问题(size == n)的解决方案用比他小的问题(问题们)来解决，也就是思考从问题size=n-1增加到size=n的时候，如何用小问题的solution构建大问题的solution 与Recursion的关系 Recursion, 从大到小解决问题(自顶至下)，不记录任何sub-solution只考虑Base Case和Recursive Rule DP, 从小到大解决问题(自底至上)，记录sub-solution 将计算中间结果保存下来，并改变计算顺序！ 3 动态规划题目特点 计数 有多少种方式走到右下角 有多少种发发选出k个数使得和是Sum 求最大最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和是Sum 4 动态规划组成部分 确定状态 解决动态规划的时候往往需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么物理意义(状态) 研究最优策略的最后一步 子问题 递推公式(转移方程) 根据子问题定义直接得到 初始条件和边界情况 细心，考虑周期 计算顺序 利用之前的计算结果","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"Graph - Topological Sort","slug":"graph-topological-sort","date":"2018-09-08T19:24:13.000Z","updated":"2018-12-05T14:30:26.970Z","comments":true,"path":"2018/09/08/graph-topological-sort/","link":"","permalink":"http://kaihaoli.github.io/2018/09/08/graph-topological-sort/","excerpt":"","text":"Given an directed graph, a topological order of the graph nodes is defined as follow: For each directed edge A -&gt; B in graph, A must before B in the order list. The first node in the order can be any node in the graph with no nodes direct to it. 无向图不存在topological sort的问题(无先后关系) 常见topological sort都是用indegree的方法遍历，其实用DFS也可以！ key point : 具有依赖关系的任务 LintCode 127. Topological Sorting 解法1. DFS 每次 DFS 得到一个符合正确拓扑顺序的 list，保证单序列顺序；每次新的 DFS 之后得到的 list 要排在之前结果的前面，保证全序列顺序 每次翻转都会改变单序列和全序列之间的顺序，对于每一个单序列或者全序列，两次翻转可以互相抵消 1234567891011121314151617181920class Solution: def topSort(self, graph): visited = set() ans = [] for root in graph: self.dfs(root, visited, ans) return ans[::-1] def dfs(self, root, visited, ans): if root in visited: return for nei in root.neighbors: if nei not in visited: self.dfs(nei, visited, ans) visited.add(root) ans.append(root) 解法2. BFS step1. 统计每个vertex/node的indegree step2. 从indegree==0开始放入queue，有edge的indegree-1，为0的放入queue 12345678910111213141516171819202122class Solution: def topSort(self, graph): indegree = collections.defaultdict(int) for node in graph: for nei in node.neighbors: indegree[nei] += 1 queue = collections.deque([]) for node in graph: if node not in indegree: queue.append(node) res = [] while queue: node = queue.popleft() res.append(node) for nei in node.neighbors: indegree[nei] -= 1 if indegree[nei] == 0: queue.append(nei) return res 210. Course Schedule II首先要检查有没有环，没有环的话才有topological sort的结果！ 123456789101112131415161718class Solution(object): def findOrder(self, numCourses, prerequisites): indegree = [0] * numCourses graph = collections.defaultdict(list) for u, v in prerequisites: indegree[u] += 1 graph[v].append(u) queue = collections.deque([i for i in xrange(numCourses) if indegree[i] == 0]) res = [] while queue: node = queue.popleft() res.append(node) for v in graph[node]: indegree[v] -= 1 if indegree[v] == 0: queue.append(v) return res if sum(indegree) == 0 else [] 269. Alien Dictionary Build the graph represent the dependency of characters! 1234567891011121314151617181920212223242526272829class Solution(object): def alienOrder(self, words): indegree = &#123;&#125; for word in words: for c in word: indegree[c] = 0 graph = [set() for _ in xrange(26)] for i in xrange(len(words)-1): cur = words[i] next = words[i+1] for j in xrange(min(len(cur), len(next))): if cur[j] != next[j]: if next[j] not in graph[ord(cur[j])-ord('a')]: graph[ord(cur[j])-ord('a')].add(next[j]) indegree[next[j]] += 1 break res = [] cnt = len(indegree.keys()) q = collections.deque([c for c in indegree.keys() if indegree[c] == 0]) while q: cur = q.popleft() res.append(cur) for n in list(graph[ord(cur)-ord('a')]): indegree[n] -= 1 if indegree[n] == 0: q.append(n) return ''.join(res) if len(res) == cnt else \"\" 欧拉通路（Eulerian path 若一个图为欧拉图或半欧拉图都可以通过一笔画遍历。通过图（有向图或无向图）中的所有边且每一条边仅通过一次的通路称为欧拉通路，若此通路为回路则称为欧拉回路 每次深度优先搜索的结果必然是图的一个连通分量。深度优先搜索可以从多点发起。如果将每个节点在深度优先搜索过程中的“结束时间”排序(具体做法是创建一个list,然后在每个节点的相邻节点都已被访问的情况下，将该节点加入list结尾，然后逆转整个链表),则我们可以得到所谓的“拓扑排序”，即topological sort.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://kaihaoli.github.io/tags/graph/"}]},{"title":"Recursion","slug":"recursion","date":"2018-09-06T00:07:39.000Z","updated":"2018-10-17T21:09:07.806Z","comments":true,"path":"2018/09/05/recursion/","link":"","permalink":"http://kaihaoli.github.io/2018/09/05/recursion/","excerpt":"","text":"What is recursion?Call Stack : Global accessible resource Usage : store the local information for each recursion function 1 Look Like function calls itself 2 In Fact Boil down a big problem to smaller ones(size n depends on size n-1, or n-2 or … n/2); Boil down size=n problem to size=n-1，n-2orn/2 problem 3 How to Implementate 1）Base Case:smallest problem to solve 2）Recursive rule:how to make the problem smaller (if we can resolve the same problem but with a smaller size, then what is left to do for the current problem size n) 4 In more detailsRecursive Function Signature must keep the same logic 1. Recursion与数学计算的结合50. Pow(x, n) a^b 数学计算常见陷阱:(Corner Case) 1) 0 as the denominator 2) 1/3 as an integer? or float? 精度问题 3) 0^0 12345678910111213141516171819public double power(double a, double b) &#123; if (a == 0 &amp;&amp; b &lt;= 0) &#123; return -1; &#125; else if (b &lt; 0) &#123; return 1 / (double)pow(a,b); &#125; else &#123; return (double) pow(a, b); &#125;&#125;public int pow(int a, int b) &#123; if (b == 0) &#123; return 1;&#125; int halfResult = pow(a, b/2); if (b % 2 == 0)&#123; return halfResult * halfResult; &#125; else &#123; return halfResult * halfResult * a;&#125; 12345678910# Time : O(logn), Space : O(logn)class Solution(object): def myPow(self, x, n): if n &lt; 0: return self.myPow(1.0/x, -n) elif n == 0: return 1 half = self.myPow(x, n//2) return half * half * (1 if n%2 == 0 else x) 2. Recursion与1D or 2D Array的结合1D Array - Merge Sort, Quick Sort2D ArrayLC51 N-Queens 1 逐层(row by row)递归：8 queen -&gt; n queen xQxxxxxx xxxQxxxx xxQxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxQx Recursive rule:For the i-th queen on the i-th row, we must make sure the Qi does no conflict with all previous queens that have been placed on the board.int Position[N] = {1 2 3 5 …} Base Case: The last row is done, 0 row left Recursive rule: iff position(i,j)valid - &gt;go to the next roe:(i+1)Time = O($$8^8$$) -&gt; O(8!) 2 How to print 2D array in spiral order (NxN) x x x x x x x x x x x x x x x x x x x x Recursive rule: size = size - 2 offset = offset + 1 旋转矩阵！ 3. Recursion和LinkedList的结合 Q1 Reverse a linked list Q2 Reverse linked list pair by pair 4. Recursion和String的结合 Q1 Reverse a String using recursion abcd -&gt; dcba Q2 A word such as “book” can be abbreviated to 4, “1o1k”, “b3”, “b2k”, etc. Given a string and an abbreviation, return if the string matches the abbreviation. Assume the original string only contains alphabetic characters. 5. Recursion和Tree的结合Binary tree 往往是最常见的，和recursion结合最紧密的面试题目类型 树本身就是Recursive的结构！ 每层的node具备的性质，传递的值和下一层的性质往往一致。比较容易定义recursive rule Base case(generally):null pointer under the leaf node Tree + Recursion 第一类问题:从下往上反值(int ,bool,etc.)* 从下往上反值 - getHeight(Node root) * 从下往上反值 - 统计tree里每个node的左子树有多少个node？ * 从下往上返值 - Find the node with **max difference** in the total number of descendents in its left subtree and right subtree 【Way of thinking】 (相当于后序遍历) 1.What do you expect from your lchild/rhild?(usually it is the return type of the recursion type) 2.What do you want to do in the current layer? 3.What do you want to report to your parent?(same as Q1 == Q3) ####LC236 Lowest Common Ancestor of a Binary Tree从下往上返值，最最经典例题! LCA Method1 use two additional arrays to buffer the prefix from root to a and from root to b Method2 (Recursion) Case1: if a is NOT the ancestor of b * 1.1 left == null, right == null, return null * 1.2 left and right reutrn c * 1.3 either left or right return NOT null, return not NULL Case2: if a is the ancestor of b * same thing Follow Up What if either a or b is not int the tree. Can this method take care of this case? A - It depends on your assumption. Assuming that both a and b are in the tree: case1: result = c (c != a &amp;&amp; c != b) it means a and b不直接隶属 case2a: result = a (a has a descendent which is b) case2b: result = b (b has a descendent which is a)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"http://kaihaoli.github.io/tags/recursion/"}]},{"title":"Tree Path","slug":"tree-path","date":"2018-08-30T15:17:12.000Z","updated":"2018-10-17T21:06:06.249Z","comments":true,"path":"2018/08/30/tree-path/","link":"","permalink":"http://kaihaoli.github.io/2018/08/30/tree-path/","excerpt":"","text":"Case1: looks like “人” path. We usually return integer value to parent node Case2: must through the root node Path112. Path Sum root to leaf True or False 123456789class Solution(object): def hasPathSum(self, root, sum): if not root: return False if not root.left and not root.right: return sum == root.val return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) 113. Path Sum II root to leaf all results 1234567891011121314151617class Solution(object): def pathSum(self, root, sum): res = [] self.dfs(root, sum, [], res) return res def dfs(self, root, sum, path, res): if not root: return if not root.left and not root.right: if sum == root.val: res.append(path+[root.val]) return self.dfs(root.left, sum-root.val, path+[root.val], res) self.dfs(root.right,sum-root.val, path+[root.val], res) 437. Path Sum III from any node to any node in the tree (can be the same node) 123456789101112class Solution(object): def pathSum(self, root, sum): if not root: return 0 return (self.findPaths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)) def findPaths(self, root, sum): if not root: return 0 return (sum == root.val) + self.findPaths(root.left, sum - root.val) + self.findPaths(root.right, sum - root.val) 666. Path Sum IV12345678910111213141516171819class Solution(object): def pathSum(self, nums): nodes = &#123;&#125; for num in nums: nodes[(num/100, num%100/10)] = num%10 self.res = 0 self.dfs(1, 1, 0, nodes) return self.res def dfs(self, d, p, curSum, nodes): if (d, p) not in nodes: return curSum += nodes[(d, p)] left, right = (d+1, p*2-1), (d+1, p*2) if left not in nodes and right not in nodes: self.res += curSum return self.dfs(left[0], left[1], curSum, nodes) self.dfs(right[0], right[1], curSum, nodes) 124. Binary Tree Maximum Path Sum 12345678910111213class Solution(object): def maxPathSum(self, root): self.res = -float('inf') self.dfs(root) return self.res def dfs(self, root): if not root: return 0 left = max(0, self.dfs(root.left)) right = max(0, self.dfs(root.right)) self.res = max(self.res, left+right+root.val) return max(left, right) + root.val Maximum Sum from leaf to leaf12345678910111213141516171819202122class Solution(object): def maxLeafSum(self, root): self.res = -float('inf') self.dfs(root) return self.res def dfs(self, root): if not root: return 0 left = self.dfs(root.left) right = self.dfs(root.right) cur = left + right + root.val if cur &gt; self.res and (root.left and root.right): self.res = cur if not root.left: return right elif not root.right: return left else: return max(left, right) + root.val Path Sum + Prefix sumMaximun Sum from any node to any node","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"Linked List Cycle","slug":"linked-list-cycle","date":"2018-08-25T14:38:12.000Z","updated":"2018-10-05T16:08:43.466Z","comments":true,"path":"2018/08/25/linked-list-cycle/","link":"","permalink":"http://kaihaoli.github.io/2018/08/25/linked-list-cycle/","excerpt":"","text":"单链表检测是否有环，如果有，返回环交点。 这种题主要考察这个知识点作为一种common sense是否了解了，如果没做过这类题型恐怕很难想到空间最优的快慢指针解法！ 141. Linked List Cycle单链表求是否存在环？ Sol1. HashSet12345678910# Time : O(n), Space : O(n)class Solution(object): def hasCycle(self, head): visited = set() while head: if head in visited: return True visited.add(head) head = head.next return False Sol2. 快慢指针 小trick : 如果有环，快指针一定会追上慢指针 12345678910# Time : O(n), Space : O(1)class Solution(object): def hasCycle(self, head): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 142. Linked List Cycle II单链表是否存在环，如果存在返回环交点 Sol1. HashSet12345678910# Time : O(n), Space : O(n)class Solution(object): def detectCycle(self, head): visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None Sol2. 快慢指针 小trick : 关于长度的证明，相遇点到交点的距离=起点到交点的距离！ 123456789101112131415# Time : O(n), Space : O(1)class Solution(object): def detectCycle(self, head): if not head: return None fast = slow = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Detect Cycle fast = head while slow != fast: fast = fast.next slow = slow.next return fast return None 287. Find the Duplicate Number 解1.HashSet(T:O(n),S:O(n)), 解2. Sort(T:O(nlogn),S:O(1)); 但是又要求 Time : O(n), Space : O(1), Input Array Read only，只能考虑其他解法！ (比较难想到)Array里index, value中把value当作”next”的index，就可以把问题转化成了Linked List II 123456789101112131415# Time : O(n), Space : O(1)class Solution(object): def findDuplicate(self, nums): if not nums: return 0 slow = fast = nums[0] # Start from index 0! while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break fast = nums[0] while fast != slow: fast = nums[fast] slow = nums[slow] return fast 160. Intersection of Two Linked ListsSol1. HashSet 挺喜欢这种解法，简单易懂，but空间复杂度略高，会让你优化空间！12345678910111213# Time : O(m+n), Space : O(m)class Solution(object): def getIntersectionNode(self, headA, headB): visited = set() while headA: visited.add(headA) headA = headA.next while headB: if headB in visited: return headB headB = headB.next return None Sol2. Two Pointer 这个解法灰常魔幻，不管有没有intersection都成立 链表走到tail了就去另一个链表，不相交那么会在None点走到 充分利用了两个链表的长度特性 1234567891011# Time : O(m+n), Space : O(1)class Solution(object): def getIntersectionNode(self, headA, headB): if not headA or not headB: return None pA, pB = headA, headB while pA is not pB: pA = pA.next if pA else headB pB = pB.next if pB else headA return pA","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://kaihaoli.github.io/tags/linked-list/"}]},{"title":"Reverse Linked List","slug":"linked-list-reverse","date":"2018-08-16T14:14:50.000Z","updated":"2018-10-12T20:20:42.874Z","comments":true,"path":"2018/08/16/linked-list-reverse/","link":"","permalink":"http://kaihaoli.github.io/2018/08/16/linked-list-reverse/","excerpt":"","text":"The most classic question in linked list 206. Reverse Linked ListIteration 其实就是双指针prev, cur同步移动修改链表结构 nxt指针暂存下一个指针的位置，最后prev到cur，cur到nxt 123456789101112131415161718# Iteration# Time : O(n), Space : (1)class Solution(object): def reverseList(self, head): prev, cur = None, head while cur: # Step1. Save the node, do not lost any control! nxt = cur.next # Step2. Modifying cur.next = prev # Step3. Iterative traverse next node prev = cur cur = nxt return prev Recursion 求n个node的情况，找n-1个node的情况如何拼起来 next-&gt;next = curr (subproblem head指向current node) curr-&gt;next = null (current node’s next is set to null) 123456789101112# Time : O(n), Space : (n)class Solution(object): def reverseList(self, head): # Base Case if not head or not head.next: return head nhead = self.reverseList(head.next) head.next.next = head head.next = None return nhead 92. Reverse Linked List II Reverse Linked List only from position m to position n 链表的操作需要像细心的医生，一根根的线要细心搭好 dummyNode =&gt; get the control of the first head 1234567891011121314151617181920212223class Solution(object): def reverseBetween(self, head, m, n): if m == n: return head # Step1. Previous node of the start position dummyNode = ListNode(0) dummyNode.next = head start = dummyNode for _ in xrange(m-1): start = start.next # Step2. Reverse from n to m prev, cur = start.next, start.next.next for _ in xrange(n-m): nxt = cur.next cur.next = prev prev = cur cur = nxt # Step3. (Amazing Point of this question!) start.next.next = cur start.next = prev return dummyNode.next 24. Swap Nodes in PairsIteration 4 pointers 一两个指针为一块，保留当前块的previous指针和块后next指针 12345678910111213141516171819class Solution(object): def swapPairs(self, head): if not head or not head.next: return head dummyNode = ListNode(0) dummyNode.next = head prev, p1 = dummyNode, head while p1 and p1.next: p2 = p1.next nxt = p2.next prev.next = p2 p2.next = p1 p1.next = nxt prev = p1 p1 = nxt return dummyNode.next Recursion Only have to care about relation between n and n-2 123456789101112class Solution(object): def swapPairs(self, head): # Base Case if not head or not head.next: return head p1 = head p2 = head.next nxt = self.swapPairs(p2.next) p1.next = nxt p2.next = p1 return p2 25. Reverse Nodes in k-Group 算是Recursion的写法，Case 2 当中这个previous指针的赋值十分巧妙！正好需要翻转的链表第一个要连接的位置是后面链表的头！完美拼接！ 123456789101112131415161718192021222324class Solution(object): def reverseKGroup(self, head, k): if not head or not head.next: return head cur = head cnt = 0 while cur and cnt &lt; k: cur = cur.next cnt += 1 # case 1 : less than k nodes if cnt &lt; k: return head # case 2 : reverse the k nodes prev = self.reverseKGroup(cur, k) cur = head for _ in xrange(k): nxt = cur.next cur.next = prev prev = cur cur = nxt return prev Convert a linked listN1-&gt;N2-&gt;N3-&gt;N4-&gt;N5-&gt;N6-&gt;….-&gt;Nn-&gt;null (convert to) N1-&gt;Nn-&gt;N2-&gt;Nn-1-&gt;…. Step1. Find the middle node of the linked List Step2. reverse the 2nd half Step3. Merge two linked list into one long Print Linked List in reverse orderfrom Google Phone Interview you can not modify the structure of linked list can you do it in sublinear space complexity? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Time : O(n), Space : O(sqrt(n))class ListNode(object): def __init__(self, x): self.val = x self.next = Noneimport mathclass Solution(object): def PrintLinkedListInReverseOrder(self, head): if not head: return # Calculate the length length = 0 cur = head while cur: cur = cur.next length += 1 # Space : O(sqrt(n) n = int(math.sqrt(length)) stack = [] cur = head while cur: stack.append(cur) for _ in range(n): if cur: cur = cur.next while stack: self.helper(stack.pop(), n) def helper(self, node, n): if not node or n == 0: return self.helper(node.next, n-1) print(node.val) returnnode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5sol = Solution()sol.PrintLinkedListInReverseOrder(node1)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://kaihaoli.github.io/tags/linked-list/"},{"name":"recursion","slug":"recursion","permalink":"http://kaihaoli.github.io/tags/recursion/"}]},{"title":"DP - Sequence","slug":"dp-sequence","date":"2018-08-13T15:55:16.000Z","updated":"2018-11-27T16:27:00.027Z","comments":true,"path":"2018/08/13/dp-sequence/","link":"","permalink":"http://kaihaoli.github.io/2018/08/13/dp-sequence/","excerpt":"","text":"Input is a single sequence, we should get the properties of previous i elements state : dp[i] is previous i elements position/numbers/charaters function : dp[i] = dp[j]… (j &lt; i) initialize : dp[0] … (means no element in the array) answer : dp[n] … Longest/Maximum Sequence Sub-array: contiguous elements in an array，number is $n^2$ Sub-sequence: not necessarily contiguous，number is n! 674. Longest Continuous Increasing Subsequence dp[i] = dp[i-1] + 1 if nums[i] &gt; nums[i-1] else 1 123456789101112131415# Time : O(n), Space : O(n)class Solution(object): def findLengthOfLCIS(self, nums): if not nums: return 0 n = len(nums) dp = [0] * n dp[0] = 1 for i in xrange(1, n): if nums[i] &gt; nums[i-1]: dp[i] = dp[i-1] + 1 else: dp[i] = 1 return max(dp) 1234567891011121314151617# Time : O(n), Space : O(1)class Solution(object): def findLengthOfLCIS(self, nums): if not nums: return 0 n = len(nums) res = 1 cur = 1 for i in xrange(1, n): if nums[i] &gt; nums[i-1]: cur += 1 res = max(res, cur) else: cur = 1 return res 300. Longest Increasing Subsequencedp[i] represents from the 0-the element to the i-th element, including the i-th element, the lenght of the longest ascending subsequence. Base Case : dp[0] = 1 Induction Rule : dp[i] = max(dp[i], dp[j] + 1 if nums[i] &gt; nums[j]) 123456789101112class Solution(object): def lengthOfLIS(self, nums): if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 53. Maximum Subarray State : dp[i] represents [from the 0-th element to the i-the element] the maximum sum of a subarray, including the i-th element. 123456789101112class Solution(object): def maxSubArray(self, nums): if not nums: return 0 n = len(nums) dp = [0] * n res = dp[0] = nums[0] for i in xrange(1, n): dp[i] = max(nums[i], nums[i] + dp[i-1]) res = max(res, dp[i]) return res Improve Space Complexity what if we want to optimize the space complexity?1234567891011class Solution(object): def maxSubArray(self, nums): if not nums: return 0 n = len(nums) res = cur = nums[0] for i in xrange(1, n): cur = max(nums[i], nums[i] + cur) res = max(res, cur) return res What if we want you to return the start and end indices of the solution array? when to move the start and end? need another two variables sol_start, sol_end, instead of global max length Path Search State : dp[i] means ending with i 70. Climbing Stairs1234567class Solution(object): def climbStairs(self, n): dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in xrange(1, n): dp[i+1] = dp[i] + dp[i-1] return dp[-1] 746. Min Cost Climbing Stairs State : dp[i] means the min cost to get stair[i] 1234567class Solution(object): def minCostClimbingStairs(self, cost): n = len(cost) dp = [0] * (n + 1) for i in xrange(2, n+1): dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) return dp[-1] 403. Frog Jump states are different! add a speed states!!!1234567891011121314class Solution(object): def canCross(self, stones): n = len(stones) dp = [set() for _ in range(n)] dp[0].add(1) for i in range(1, n): for j in range(i): gap = stones[i] - stones[j] if gap in dp[j]: dp[i].add(gap - 1) dp[i].add(gap) dp[i].add(gap + 1) return len(dp[-1]) != 0 Prefix SumGiven Array A[1..n]，Prefix Sum Array PrefixSum[1..n] defined as：PrefixSum[i] = A[0]+A[1]+…+A[i-1]； e.g. A[5,6,7,8] –&gt; PrefixSum[5,11,18,26]PrefixSum[0] =A[0] ;PrefixSum[1] =A[0] + A[1] ;PrefixSum[2] =A[0] + A[1] + A[2] ;PrefixSum[3] =A[0] + A[1] + A[2] + A[3] ; 303. Range Sum Query - ImmutableGiven an immutable array, call rangeSum multiple times! 123456789101112class NumArray(object): # Time : O(n), Space : O(n) def __init__(self, nums): self.preSum = [0] n = len(nums) s = 0 for i in xrange(n): s += nums[i] self.preSum.append(s) # Time : O(1) def sumRange(self, i, j): return self.preSum[j+1] - self.preSum[i] Follow up : What if the array is mutable? 304. Range Sum Query 2D - Immutable We use preSum trick in the array! How about the matrix? 123456789101112131415161718class NumMatrix(object): # Time : O(mn), Space : O(mn) def __init__(self, matrix): if not matrix: self.dp = [] return m, n = len(matrix), len(matrix[0]) self.dp = [[0] * (n+1) for _ in xrange(m+1)] dp = self.dp for i in xrange(1, m+1): for j in xrange(1, n+1): dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i-1][j-1] # Time : O(1) def sumRegion(self, row1, col1, row2, col2): if not self.dp: return 0 return self.dp[row2+1][col2+1] - self.dp[row2+1][col1] - self.dp[row1][col2+1] + self.dp[row1][col1] 363. Max Sum of Rectangle No Larger Than K How many sub-matrix are there in the matrix? O($n^2$ * $n^2$) = O($n^4$) 解法1.Naive计算矩阵和O($n^2$), 总Time:O($n^6$) 解法2.PreSum优化矩阵和计算计算矩阵和O(1), 总Time:O($n^4$)Space:O($n^2$)用来存左上角(0,0)-&gt;右下角(i,j)的矩阵和1234567891011121314151617181920212223class Solution(object): # TLE def maxSumSubmatrix(self, matrix, k): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) # PreSum matrix dp = [[0] * (n+1) for _ in xrange(m+1)] for i in xrange(1, m+1): for j in xrange(1, n+1): dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i-1][j-1] def sumRegion(row1, col1, row2, col2): return dp[row2+1][col2+1] - dp[row2+1][col1] - dp[row1][col2+1] + dp[row1][col1] res = -float('inf') for i in xrange(m): for j in xrange(n): for li in xrange(i, m): for lj in xrange(j, n): s = sumRegion(i, j, li, lj) if s &lt;= k: res = max(res, s) return res 解法3.极其巧妙！1 pre-processing 预处理 1D从上到下做1D的preSum, O($n^2$) 2 任意取两行压缩成一个Array瞬间把一个2D的matrix经过O($n^2$)转化成了1D的array 3 求一个Array里不大于k的连续subarray新问题：求数组里不大于k的连续subarray O(nlogn) TODO : python没有treeset的怎么搞？ 560. Subarray Sum Equals K Brute Force : $n^2$ subarray，Sum O($n$), Total O($n^3$) Sol1. preSumImprove Sum O($n^2$) to O(n)，but still O($n^2$), TLE Sol2. HashTable, O(n)A[0] + A[1] + … + A[j] = V preSum[j] - preSum[i] = V similar to the Two Sum Problem，Query wether another part in preSum Array? 1234567891011class Solution(object): def subarraySum(self, nums, k): preSum = defaultdict(int) s = count = 0 preSum[0] = 1 for n in nums: s += n if (s - k) in preSum: count += preSum[s - k] sums[s] += 1 return count 325. Maximum Size Subarray Sum Equals klongest subarray sum equals to k preSum + HashTable 12345678910111213141516class Solution(object): def maxSubArrayLen(self, nums, k): if not nums: return 0 preSum = &#123;&#125; preSum[0] = -1 s = res = 0 for i, n in enumerate(nums): s += n pre = s - k if pre in preSum: res = max(res, i-preSum[pre]) if s not in preSum: preSum[s] = i return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://kaihaoli.github.io/tags/dp/"}]},{"title":"Tree Recursion","slug":"tree-recursion","date":"2018-08-08T03:28:28.000Z","updated":"2018-10-31T03:57:15.338Z","comments":true,"path":"2018/08/07/tree-recursion/","link":"","permalink":"http://kaihaoli.github.io/2018/08/07/tree-recursion/","excerpt":"","text":"Basic Binary tree 往往是最常见的，和recursion结合最紧密的面试题目类型 树本身就是Recursive的结构！ 每层的node具备的性质，传递的值和下一层的性质往往一致。比较容易定义recursive rule Base case(generally):null pointer under the leaf node, Base case usually refers to the null childNode below leaf. Way of thinking (相当于后序遍历 - int ,bool,etc.) 1.What do you expect from your lchild/rhild?(usually it is the return type of the recursion type) 2.What do you want to do in the current layer? 3.What do you want to report to your parent?(same as Q1 == Q3) 104. Maximum Depth of Binary Tree 1 Child: 问左右两个孩子要一个值 2 Current: 当前层拿到左右孩子的值可以做些处理 3 Parent: 向父节点返回的值和child要的值要一样就接上了！！ 123456789# Time : O(n), Space : O(n)# Post Orderclass Solution(object): def maxDepth(self, root): if not root: return 0 left = self.maxDepth(root.left) right = self.maxDepth(root.right) return max(left,right) + 1 111. Minimum Depth of Binary Tree每个节点的状态可以划分为： 叶子节点 - lchild is None, rchild is None 有两个孩子 - lchild is not None, rchild is not None 有一个孩子 - not left child OR not right child 1234567class Solution(object): def minDepth(self, root): if not root: return 0 if not root.left or not root.right: return self.minDepth(root.left) + self.minDepth(root.right) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 从下往上反值 - 统计tree里每个node的左子树有多少个node？ 从下往上返值 - Find the node with max difference in the total number of descendents in its left subtree and right subtree 110. Balanced Binary TreeA binary tree in which the depth of the two subtrees of every node never differ by more than 1. 123456789101112131415# Time : O(nlogn), Space : O(n)class Solution(object): def height(self, root): if not root: return 0 return max(self.height(root.left), self.height(root.right)) + 1 def isBalanced(self, root): if not root: return True left = self.height(root.left) right = self.height(root.right) if abs(left-right) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right) 1234567891011121314151617# Time : O(n), Space : O(n)class Solution(object): def isBalanced(self, root): return self.dfs(root) != -1 def dfs(self, root): if not root: return 0 left = self.dfs(root.left) if left == -1: return -1 right = self.dfs(root.right) if right == -1: return -1 if abs(left - right) &gt; 1: return -1 return max(left, right) + 1 101. Symmetric Tree 判断空间复杂度的时候一定要注意树不一定是balanced的！！！ 12345678910111213# Time : O(n), Space : O(n)class Solution(object): def isSymmetric(self, root): return self.isMirror(root, root) def isMirror(self, root1, root2): if not root1 and not root2: return True elif not root1 or not root2: return False else: return ( root1.val == root2.val and self.isMirror(root1.left, root2.right) and self.isMirror(root1.right, root2.left)) 226. Invert Binary Tree 注意赋值的过程已经有改变结构，用temp来swap！ 123456class Solution(object): def invertTree(self, root): if not root: return None root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off. 100. Same Tree12345678910class Solution(object): def isSameTree(self, p, q): if not p and not q: return True elif not p or not q: return False else: return (p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)) 543. Diameter of Binary Tree DFS + maxDepth postorder to deal with the value returned from left and right subtree 1234567891011121314class Solution(object): def diameterOfBinaryTree(self, root): if not root: return 0 self.res = 0 self.maxDepth(root) return self.res def maxDepth(self, root): if not root: return 0 left = self.maxDepth(root.left) right = self.maxDepth(root.right) self.res = max(self.res, left + right) return max(left, right) + 1 222. Count Complete Tree Nodes Time : O($(logn)^2$)1234567891011121314151617class Solution: def countNodes(self, root): if not root: return 0 left = self.depth(root.left) right = self.depth(root.right) if left == right: return (2**left) + self.countNodes(root.right) else: return (2**right) + self.countNodes(root.left) def depth(self, root): cnt = 0 while root: root = root.left cnt += 1 return cnt","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"},{"name":"recursion","slug":"recursion","permalink":"http://kaihaoli.github.io/tags/recursion/"}]},{"title":"Linked List Basic","slug":"linked-list-basic","date":"2018-08-06T12:42:40.000Z","updated":"2018-10-25T02:15:34.392Z","comments":true,"path":"2018/08/06/linked-list-basic/","link":"","permalink":"http://kaihaoli.github.io/2018/08/06/linked-list-basic/","excerpt":"","text":"IntroductionPrerequisite Linear Structure : Array:Phisical, Linked List:是由Pointer连起来的，不一定是物理连续的！ 链表的题目往往算不上“算法性”题，只是一种模拟操作的题 考察的重点在于bug free，是否对写代码有熟练度！ Key Point 1 When you want to de-reference a List Node, make sure it is not a NULL Pointer. No matter when you use “.”, 一定要注意判断前面的Reference是否为空！！！ 2 Never ever lost the control of the head pointer of the Linked List. 经常需要缓存nxt指针或者prev指针,都是因为当你改变链表结构的时候很容易丢失之前或者之后的信息！ Tips DummyNode, Why or When should we use a dummy Node? When we want to append new elements to an initially empty linkedlist, we do not have an initial head node. In this case, we can new a dummy node to act as a head node. 链表的结构发生变化 Two or More Pointers We usually use many pointer to manipulate the node of the linked list Basic FunctionFind the middle node of a linked List Odd, Even1234567def findMiddleNode(head): if not head: return head fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return fast Insert a node in a sorted linked list203. Remove Linked List Elements Two pointers : prev, cur 123456789101112class Solution(object): def removeElements(self, head, val): dummyNode = ListNode(0) dummyNode.next = head prev, cur = dummyNode, head while cur: if cur.val == val: prev.next = cur.next else: prev = cur cur = cur.next return dummyNode.next 19. Remove Nth Node From End of List 快慢指针维护一个长度为n的滑动窗口 12345678910111213class Solution(object): def removeNthFromEnd(self, head, n): dummyNode = ListNode(0) dummyNode.next = head slow = fast = dummyNode for _ in xrange(n): fast = fast.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return dummyNode.next 237. Delete Node in a Linked List 很奇怪的一道题，做法也很奇怪 往往删除单链表的一个节点，需要有头节点或者前一个节点来绕过删除的节点，这道题只给了要删除的节点(单链表拿不到previous的节点)，只能通过节点覆盖来做。 1234class Solution(object): def deleteNode(self, node): node.val = node.next.val node.next = node.next.next 83. Remove Duplicates from Sorted List 和Remove Duplicate from Array一毛一样同样是同向双指针 1234567891011121314class Solution(object): def deleteDuplicates(self, head): if not head: return head prev = head cur = head.next while cur: if cur.val == prev.val: prev.next = cur.next cur = cur.next else: prev = cur cur = cur.next return head 82. Remove Duplicates from Sorted List II 删除所有的duplicate，只保留distinct的元素！ 1 找到重复的元素 2 用while循环删除掉所有 123456789101112131415class Solution(object): def deleteDuplicates(self, head): dummyNode = ListNode(-1) dummyNode.next = head prev = dummyNode cur = head while cur: if cur.next and cur.val == cur.next.val: while cur.next and cur.val == cur.next.val: cur = cur.next prev.next = cur.next else: prev = cur cur = cur.next return dummyNode.next 21. Merge Two Sorted Lists DummyNode的使用 1234567891011121314class Solution(object): def mergeTwoLists(self, l1, l2): dummyNode = ListNode(-1) cur = dummyNode while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 if l1 else l2 return dummyNode.next 23. Merge k Sorted Lists heap 1234567891011121314151617# Time : O(nlogk), Space : (k)class Solution(object): def mergeKLists(self, lists): heap = [] for head in lists: if head: heapq.heappush(heap, (head.val, head)) DummyNode = ListNode(-1) cur = DummyNode while heap: val, node = heapq.heappop(heap) if node.next: heapq.heappush(heap, (node.next.val, node.next)) cur.next = node cur = cur.next return DummyNode.next 138. Copy List with Random Pointer Hash Table = NewNode 123456789101112131415161718192021class Solution(object): def copyRandomList(self, head): if not head: return None # Step1. copy New Node cur = head nodeMap = &#123;&#125; while cur: nodeMap[cur] = RandomListNode(cur.label) cur = cur.next # Step2. link the next and random pointer cur = head while cur: node = nodeMap[cur] node.next = nodeMap[cur.next] if cur.next else None node.random = nodeMap[cur.random] if cur.random else None cur = cur.next return nodeMap[head] 123456789101112131415161718# Recursionclass Solution(object): def copyRandomList(self, head): def copyNode(node, cache): if not node: return None if node in cache: return cache[node] copy = RandomListNode(node.label) cache[node] = copy copy.next = copyNode(node.next, cache) copy.random = copyNode(node.random, cache) return copy return copyNode(head, &#123;&#125;) 430. Flatten a Multilevel Doubly Linked List1234567891011121314151617181920class Solution(object): def flatten(self, head): if not head: return None stack = [] cur = head while cur: if cur.child: if cur.next: stack.append(cur.next) cur.next = cur.child cur.child.prev = cur cur.child = None if not cur.next and stack: temp = stack.pop() cur.next = temp temp.prev = cur cur = cur.next return head","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://kaihaoli.github.io/tags/linked-list/"}]},{"title":"Graph","slug":"graph","date":"2018-08-02T02:43:25.000Z","updated":"2018-10-16T13:38:41.738Z","comments":true,"path":"2018/08/01/graph/","link":"","permalink":"http://kaihaoli.github.io/2018/08/01/graph/","excerpt":"","text":"LeetCode 上很多问题都可以抽象成 “图” ，比如搜索类问题，树类问题，迷宫问题，矩阵路径问题，等等。Graph 是非常重要而又涵盖很广的内容，以至于有单独的”图论”研究方向。 1 图的计算机表示 Node / State Edge / Action Directed vs Undirected graph Representation of the graph Edge List题目给的Nodes and Edges(Edge List)形式的图 要么考虑用Union Find，要么考虑重新建立图的表示 Adjacency Matrix Pros: Representation is easy to implement. Edge removal takes O(1) time. Queries like whether there is an edge from vertex ‘u’ to vertec ‘v’ are efficient and can be done O(1) Cons: Consumes more space O(V^2)(V is the number of vertex/node) Even if the graph is sparse(contains less number of edges) == waste of space Adjacency List Vertices/Nodes : V, Edges : E Pros: Space Complexity = O(V + E). Adding a vertex.node to the graph is easier Cons: Time Complexity is O(V) to check wheter there is an edge from a node to the other.(Comprared to O(1) in adjacent matrix) Adjacency “Hash Set”用hashset替代list表示相邻的节点，综合了Adjacency Matrix和Adjacency List的优点！ 2 Graph Search AlgorithmBreadth First SearchHow to describe a BFS’s action during an interview? Definition 1: expand a node s, 延展一个node Definition 2: generate s’s neighbor node: reach out to its neighboring node Data Structure : Maintain a FIFO queue, put all generated nodes in the queue Termination condition : do a loop until the queue is empty Discussion When we deal with the tree-related problem and in the meantime we need to address the relationship on the same level BFS is NOT the right algorithm to find the shortest path in the graph BFS 的时间空间占用以 branching factor 为底, 到解的距离 d 为指数增长； BFS 空间占用上 Queue 是不会像 DFS 一样只存一条路径的，而是从起点出发越扩越大，因此会有空间不够的风险，空间占用为 O(b^d)。 Assume Input - graph adjacency “hash set” Undirected Graph Queue, visited 123456789101112# 其实和Tree的BFS traversal是一样的！# Why visited array? 如果有环的话需要，没有环的话就是tree了，所以不需要！def BFS1(): visited = [0] * n queue = collections.deque([0]) while queue: node = queue.popleft() print(node) visited[node] = 1 for nei in graph[node]: if visited[nei] == 0: queue.append(nei) Directed Graph Only directed graph has indegree and outdegree! 12345678910# 从Indegree == 0 的node开始！def BFS2(): queue = collections.deque([i for i in xrange(n) if indegree[i] == 0]） while queue: node = queue.popleft() print(node) for nei in graph[course]: indegree[nei] -= 1 if indegree[nei] == 0: queue.append(nei) Dijkstra’s Algorithm“呆克斯戳” Best First Search, 也是BFS Usages: Find the shortest path cost from a single node (source node) to any other nodes in that graph Data Structure: Priority Queue (Min Heap) Process Initial state (start node) Node expansion/ Generation rule Termination condition 所有点计算完毕也是”Queue is empty” Properties One node can be expanded once and only once One node can be generated more than once. (cost can be reduced over time) all the cost of the nodes that are expanded are monotonically non-decreasing（所有从 priority queue里面pop出来的元素的值是单调非递减-&gt;单调递增） time complexity, for a graph with n node and the connectivity of the node is O(nlogn) when a node is popped out for expansion, its value is fixed which is equal to the shortest distance from the start node (非负权重) 743. Network Delay Time1234567891011121314151617class Solution(object): def networkDelayTime(self, times, N, K): graph = [[] for _ in xrange(N+1)] for u, v, w in times: graph[u].append((v, w)) dis = [0] + [-1] * N pq = [(0, K)] while pq: w, s = heapq.heappop(pq) if dis[s] &gt;= 0: continue dis[s] = w for nxt, nw in graph[s]: heapq.heappush(pq, (w+nw, nxt)) return -1 if -1 in dis else max(dis) 378. Kth Smallest Element in a Sorted Matrix Time : O(klogk), Space : O(k) 1234567891011121314151617181920class Solution(object): def kthSmallest(self, matrix, k): n = len(matrix) visited = set([(0, 0)]) heap = [(matrix[0][0], 0, 0)] for _ in xrange(k): val, x, y = heapq.heappop(heap) # next row if x+1 &lt;= n-1 and (x+1, y) not in visited: heapq.heappush(heap, (matrix[x+1][y], x+1, y)) visited.add((x+1,y)) # next col if y+1 &lt;= n-1 and (x, y+1) not in visited: heapq.heappush(heap, (matrix[x][y+1], x, y+1)) visited.add((x,y+1)) return val Depth First SearchBacktracking is just a behavior of DFS DFS 的时间占用以 branching factor 为底，树的深度 m 为指数增长 DFS 的空间占用上，却只是 O(bm)，可视化探索过程中只把每个 Node 的所有子节点存在 Stack 上， 探索完了再 pop 出来接着探，因此储存的节点数为 O(bm)。 可以看到无论是 BFS 还是 DFS，树的 branching factor 都是对空间与时间复杂度影响最大的参数；除此之外，BFS 中最重要的是到解的距离，而 DFS 看从当前节点的深度。普遍来讲，DFS 空间上会经济一些，当然也要分情况讨论。 Undirected Graph12345def dfs(node): visited.add(node) for nei in node.neighbors: if nei not in visited: dfs(nei) Directed Graph visited 需要 三种状态!!! 0-未访问，1-正在访问，2-已经访问 3 Application785. Is Graph Bipartite? BFS的做法有一个问题，就是这个图可能不是连通图！！！所以要遍历所有点！ 所有点有两次一次push进Queue，一次pop出Queue！ 12345678910111213141516171819202122232425class Solution(object): def isBipartite(self, graph): n = len(graph) visited = [False] * n A, B = set(), set() for i in range(n): if visited[i]: continue queue = collections.deque([(i,0)]) while queue: node, level = queue.popleft() if level: B.add(node) else: A.add(node) if visited[node]: continue for nei in graph[node]: queue.append((nei, 1 - level)) visited[node] = True return not A&amp;B 133. Clone Graph克隆Graph，很多graph都是用HashTable一一映射 Hash Table 新旧node一一映射，再把关系同样映射！ DFS，BFS都可以把所有node遍历一遍就好 123456789101112131415161718192021222324252627282930313233343536# BFSclass Solution: def cloneGraph(self, node): if not node: return None gmap = &#123;node:UndirectedGraphNode(node.label)&#125; queue = collections.deque([node]) while queue: nnode = queue.popleft() for nei in nnode.neighbors: if nei not in gmap: gmap[nei] = UndirectedGraphNode(nei.label) queue.append(nei) gmap[nnode].neighbors.append(gmap[nei]) return gmap[node]# DFSclass Solution: def cloneGraph(self, node): return self.dfs(node, &#123;&#125;) def dfs(self, node, cache): if not node: return None if node in cache: return cache[node] copy = UndirectedGraphNode(node.label) cache[node] = copy for nei in node.neighbors: nnei = self.dfs(nei, cache) copy.neighbors.append(nnei) return copy","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://kaihaoli.github.io/tags/graph/"}]},{"title":"Union Find 并查集","slug":"union-find","date":"2018-05-23T02:32:20.000Z","updated":"2018-10-30T03:23:29.863Z","comments":true,"path":"2018/05/22/union-find/","link":"","permalink":"http://kaihaoli.github.io/2018/05/22/union-find/","excerpt":"","text":"What is Union Find ? Union-Find算法(并查集算法)是解决动态连通性（Dynamic Conectivity）问题的一种算法，”人以类聚,物以群分” 一种用来解决集合查询合并的数据结构，支持 O(1)find, O(1)union 查询 Find 确定某个元素x属于哪一个集合 合并 Union 将两个集合合并 应用场景 Computer Network 两个网络节点是否联通 最小的布线使得整个网络联通 Social Network Linkedin 两个用户可能认识的人 集合论 Union Find vs DFS在对问题进行建模的时候，我们应该尽量想清楚需要解决的问题是什么!因为模型中选择的数据结构和算法显然会根据问题的不同而不同! Union Find - 给出两个节点，判断它们是否连通，如果连通，不需要给出具体的路径 DFS - 给出两个节点，判断它们是否连通，如果连通，需要给出具体的路径 AlgorithmQuick-Find有点类似于染色的过程，每个节点一个颜色，然后相同的节点设置成相同的颜色。quick-find算法十分直观符合简单的思考过程。 12345678910111213# Time : O(1)def find(x): return root[x]# Time : O(n)def union(x, y): rootx = root[x] rooty = root[y] if rootx == rooty: return for i in xrange(len(root)): if root[i] == rootx: root[i] = rooty 每次添加新路径(Union)就是 “牵一发而动全身”，想要解决这个问题，关键就是要提高union方法的效率，让它不再需要遍历整个数组。 Quick-Union 以树的思想，表示集合！！！ 这是UF算法里最关键的思路，以树的形式表示集合，这样组织正好可是很高效的实现find和union! 123456789101112# Time : O(Tree Height), Worst Case O(n)# Recursiondef find(x): if root[x] == x: return x return find(root[x])# Iterationdef find(x): while root[x] != x: x = root[x] return x 123456# Time : O(Tree Height), Worst Case O(n)def union(x, y): rootx = find(x) rooty = find(y) if rootx != rooty: 判断两个Element在不在同一个集合当中 root[rootx] = rooty Weighted Quick-Union既然树的高度成为制约时间复杂度的瓶颈，我们就想办法让树平衡！ 以Quick union为基础，我们 额外利用一个size[]保存每一个联通集中对象的数量。 在调用union()的时候，我们总是把 对象数目较少的联通集连接到对象数目较多的联通集 中。 通过这种方式，我们可以在一定程度上缓解树的高度太大的问题，从而改善Quick union的时间复杂度。 12345678910111213141516# Time : O(logn)def find(x): if root[x] == x: return x return find(root[x])# Time : O(logn)def union(x, y): rootx = find(x) rooty = find(y) if size[rootx] &gt;= size[rooty]: root[rooty] = rootx size[rootx] += size[rooty] else: root[rootx] = rooty size[rooty] += size[rootx] Path Compression随着数据的增加，树的深度不断增加，性能会逐渐变差。这个时候，如果我们在计算一个node的root时，将node为根的树摘下来，挂在当前树的根结点上，会降低树的深度，也就是提高效率，降低时间复杂度。123456789# Path Compression 是在find的过程当中处理的def find(x): if root[x] == x: return x # make every other node in path point to its grandparent. root[x] = find(root[x]) # Only one extra line return root[x] Weighted Quick-Union With Path CompressionProof is very difficult, But the algorithm is still simple! 12345678910111213# Weighted 是体现在Union的过程当中# Time : Very Near to O(1)def union(x, y): rootx = find(x) rooty = find(y) if rootx == rooty: return if size[rootx] &gt;= size[rooty]: root[rooty] = rootx size[rootx] += size[rooty] else: root[rootx] = rooty size[rooty] += size[rootx] Connected查询两个元素是否在同一个集合内。 LintCode 589. Connecting GraphGiven n nodes in a graph labeled from 1 to n. There is no edges in the graph at beginning. You need to support the following method: connect(a, b), add an edge to connect node a and node b. query(a, b), check if two nodes are connected 123456789101112131415161718192021222324class ConnectingGraph: def __init__(self, n): self.root = range(n+1) # Find the Root of node x def find(self, x): root = self.root # tip1 : root在类里面要加上\"self.\" if root[x] == x: return x root[x] = self.find(root[x]) return root[x] def union(self, x, y): root = self.root rootx = self.find(x) # tip2 : root[x] vs find(x) rooty = self.find(y) if rootx != rooty: root[rootx] = rooty def connect(self, a, b): self.union(a, b) def query(self, a, b): return self.find(a) == self.find(b) LintCode 590. Connecting Graph II 统计每个联通块的元素个数 query(a), Returns the number of connected component nodes which include node a. 1234567891011121314151617181920212223class ConnectingGraph2: def __init__(self, n): self.root = range(n+1) self.size = [1] * (n+1) def find(self, x): root = self.root if root[x] == x: return x root[x] = self.find(root[x]) return root[x] def connect(self, a, b): root = self.root size = self.size roota = self.find(a) rootb = self.find(b) if roota != rootb: root[roota] = rootb size[rootb] += size[roota] def query(self, a): return self.size[self.find(a)] 130. Surrounded Regions 解法1 DFS 从边缘的’O’出发，通过DFS，所有能够遍历的’O’都可以暂时被标记为’#’，那么剩下未能被标记的’O’说明被surrounded，需要在遍历结束之后全部转为’X’ 解法2 Union Find 将与边缘相连通的’O’全部union到一个dummy node（也可以用hasEdge[]来存储，不过内存占用更多,最终将没有和这个dummy node是一个component的’O’点全部标记为’X12345678910111213141516171819202122232425262728293031323334353637383940414243444546class UnionFind(object): def __init__(self, n): self.root = range(n) def find(self, x): root = self.root if root[x] == x: return x root[x] = self.find(root[x]) return root[x] def union(self, x, y): root = self.root rootx = self.find(x) rooty = self.find(y) if rootx != rooty: # tip : 为了总是以dummy node(total)为父节点 root[min(rootx, rooty)] = max(rootx, rooty)class Solution(object): def solve(self, board): if not board: return m, n = len(board), len(board[0]) total = m*n uf = UnionFind(total+1) grid = board for i in xrange(m): for j in xrange(n): if grid[i][j] == 'X': continue # Connect to \"total\" root if i == 0 or j == 0 or i == m-1 or j == n-1: uf.union(total, i*n+j) else: d = [(1, 0), (0, 1), (-1, 0), (0, -1)] for k in xrange(4): ni, nj = i + d[k][0], j + d[k][1] if grid[ni][nj] == 'O': uf.union(ni*n + nj, i*n + j) for i in xrange(m): for j in xrange(n): if grid[i][j] == 'X': continue if uf.find(i*n + j) != total: grid[i][j] = 'X' 737. Sentence Similarity II典型的Union Find 应用题，两个单词是不是similarity其实就是两个单词在不在同一个集合内(connected 操作)！ 12345678910111213141516171819202122232425262728293031323334353637383940class UnionFind(object): def __init__(self, n): self.root = range(n) def find(self, x): root = self.root if root[x] == x: return x root[x] = self.find(root[x]) return root[x] def union(self, x, y): self.root[self.find(x)] = self.find(y)class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): m, n = len(words1), len(words2) if m != n: return False # 建立words到index的映射关系！UnionFind 只支持数字的index！ uf = UnionFind(len(pairs)*2) cnt = 0 pdic = &#123;&#125; for w1, w2 in pairs: if w1 not in pdic: pdic[w1] = cnt cnt += 1 if w2 not in pdic: pdic[w2] = cnt cnt += 1 uf.union(pdic[w1], pdic[w2]) for w1, w2 in zip(words1, words2): if w1 == w2: continue if w1 not in pdic or w2 not in pdic: return False if uf.find(pdic[w1]) != uf.find(pdic[w2]): return False return True 统计连通块的个数the number of connected components. LintCode 591. Connecting Graph III Query() - Returns the number of connected component in the graph 12345678910111213141516171819202122class ConnectingGraph3: def __init__(self, n): self.root = range(n+1) self.cnt = n def find(self, x): root = self.root if root[x] == x: return x root[x] = self.find(root[x]) return root[x] def connect(self, a, b): root = self.root roota = self.find(a) rootb = self.find(b) if roota != rootb: root[roota] = rootb self.cnt -= 1 def query(self): return self.cnt 323. Number of Connected Components in an Undirected Graph 解法1. DFS 将Graph原本的nodes和edges表达形式，改成hash做的邻接表，这个就可以查询从每个节点出发到的节点！12345678910111213141516171819202122class Solution(object): def countComponents(self, n, edges): visited = [0] * n graph = [set() for _ in xrange(n)] # Adjacent Table for i, j in edges: graph[i].add(j) graph[j].add(i) res = 0 for i in xrange(n): if visited[i] == 1: continue self.dfs(i, visited, graph) res += 1 return res def dfs(self, n, visited, graph): if visited[n] == 1: return visited[n] = 1 for i in graph[n]: self.dfs(i, visited, graph) 解法2. Union Find 1234567891011121314151617181920class Solution(object): def countComponents(self, n, edges): root = range(n) self.cnt = n def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] def union(x, y): rootx = find(x) rooty = find(y) if rootx != rooty: root[rootx] = rooty self.cnt -= 1 for i, j in edges: union(i, j) return self.cnt 305. Number of Islands II实时放入island显示出联通块的个数，算是一个online的算法！ 原始UF算法是一维的，2D坐标和1D坐标的转化 体现Union Find的Online特性，可以实时添加边！ 123456789101112131415161718192021222324252627282930313233343536373839404142# Time : O(m * n + k)class UnionFind(object): def __init__(self, n): self.root = [-1] * n self.cnt = 0 def find(self, x): root = self.root if root[x] == x: return x root[x] = self.find(root[x]) return root[x] def add(self, x): self.root[x] = x self.cnt += 1 def union(self, x, y): root = self.root rootx = self.find(x) rooty = self.find(y) if rootx != rooty: root[rootx] = rooty self.cnt -= 1class Solution(object): def numIslands2(self, m, n, positions): uf = UnionFind(m * n) res = [] d = [(1, 0), (-1, 0), (0, 1), (0, -1)] for i, j in positions: p = i*n + j uf.add(p) for k in range(4): ni, nj = i + d[k][0], j + d[k][1] q = ni * n + nj if ( 0 &lt;= ni &lt;= m-1 and 0 &lt;= nj &lt;= n-1 and uf.root[q] != -1): uf.union(p, q) res.append(uf.cnt) return res 547. Friend Circles123456789101112131415161718192021222324class Solution(object): def findCircleNum(self, M): n = len(M) root = range(n) self.cnt = n def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] def union(x, y): rootx = find(x) rooty = find(y) if rootx != rooty: root[rootx] = rooty self.cnt -= 1 for i in xrange(n): for j in xrange(i+1, n): if M[i][j]: union(i, j) return self.cnt Redundant Connection261. Graph Valid Tree1234567891011121314151617181920212223class Solution(object): def validTree(self, n, edges): root = range(n) self.cnt = n def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] def union(x, y): rootx = find(x) rooty = find(y) if rootx != rooty: root[rootx] = rooty self.cnt -= 1 return True return False for i, j in edges: if not union(i, j): return False return self.cnt == 1 684. Redundant Connection12345678910111213141516class Solution(object): def findRedundantConnection(self, edges): root = range(1001) def find(x): if root[x] == x: return x root[x] = find(root[x]) return root[x] for i, j in edges: rooti = find(i) rootj = find(j) if rooti == rootj: return [i, j] root[rooti] = rootj 685. Redundant Connection II Case1: There is a loop in the graph, and no vertex has more than 1 parent. 有环，且没有入度大于1的node =&gt; Union Find Case2: A vertex has more than 1 parent, but there isn’t a loop in the graph. 无环，且有入度大于2的node =&gt; last node (indegree &gt; 1) Case3: A vertex has more than 1 parent, and is part of a loop. 有环，且有入度大于2的node 这种复杂的情况怎么筛选? Delete the second edge! 1234567891011121314151617181920212223242526272829303132class Solution(object): def findRedundantDirectedConnection(self, edges): n = len(edges) parent = [0] * (n+1) ans = None # Step1 : calculate indegree &gt; 1 node for i in xrange(n): u, v = edges[i] if parent[v] == 0: parent[v] = u else: ans = [[parent[v], v], [u, v]] # !!! Delete the second Edge edges[i][1] = 0 # Step2 : Union Find detect cycle root = range(n+1) def find(x): if root[x] == x: return x return find(root[x]) for u, v in edges: rootu = find(u) rootv = find(v) if rootu == rootv: # Detect Cycle if not ans: return [u, v] else: return ans[0] root[rootu] = rootv return ans[1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://kaihaoli.github.io/tags/graph/"}]},{"title":"OOD in Interview","slug":"ood-in-interview","date":"2018-05-19T01:46:38.000Z","updated":"2018-05-19T02:25:53.692Z","comments":true,"path":"2018/05/18/ood-in-interview/","link":"","permalink":"http://kaihaoli.github.io/2018/05/18/ood-in-interview/","excerpt":"","text":"总结自:九章算法 - OOD1 OOD in InterviewEverything is an object, Usable!!! 面试频率 Phone interview 低 Onsite interview 中高频 高频公司 Amazon, Bloomberg, TripAdvisor, EMC, Uber… 主要考察CS设计的基本素养，属于开放型设计类题目，能用上OOD的常见的一些设计思想！ OOA(Analysis) -&gt; OOD(Design) -&gt; OOP(Programming) OOD问法 Can you design a … system? little amount of coding Can you … for … system? need implementation OOD要避免的情况 1 不问清需求就开始设计，一定要和面试官!沟通”甲方”的需求！ Communication 2 没有理解面试官想要问System Design，还是OOD，还是算法！ Think loud 3 思路混乱，反复更改之前的设计！Usable！！！就好 Correctness &amp; Reasonable use case “SOLOD”原则 S - Single responsibility principle 一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。 O – Open close principle 对象或实体应该对扩展开放，对修改封闭 (Open to extension, close to modification) L - Liskov substitution principle 里氏替换原则 任何一个子类或派生类应该可以替换它们的基类或父类 I - Interface segregation principle 接口分离原则 不应该强迫一个类实现它用不上的接口 Implement D - Dependency inversion principle 依赖反转原则 抽象不应该依赖于具体实现，具体实现应该依赖于抽象 只能class 依赖于Abstract, Imterface Design an elevator systemClarify : 通过和面试官交流，去除题目中的歧义，确定答题范围 What? - 什么? 针对题目中的关键字来􏰁问，帮助自己更好的确定答题范围 大多数的关键字为名词，通过名词的属性来考虑 Elevator, Building How? - 怎样? 针对问题主题的规则来􏰁问，帮助自己明确解题方向。 此类问题没有标准答案，你可以􏰁出一些解决方法，通过面试官的反应， 选择一个你比较有信心(简单)的方案 Rule 同向 &gt; 静止 &gt; 反向，当运行时不能按下反向的楼层 电梯至少需要三种状态，并且要知道当前在哪一层 Who? - 谁? 设计由人主导 VS. 设计由系统主导? (Optional)通过思考题目当中是否有人的出现，来帮助确定解题范围 一般可以考虑人的角色以及人的属性，看是否题目需要 When? - 什么时间? (Optional)通过思考题目当中和时间相关的属性，来帮助确定解题范围 和时间相关的问题一般都比较细节，可能会有意想不到的帮助 Think ProcessCore Object为了完成设计，需要哪些class？ 以一个Object为基础，往往就是需要设计的system！ 确定objects之间的映射关系(4~5个Object) Access modifier package 如果什么都不声明，变量和函数都是package level visible的，在同一个package内的其他类都可以访问 public 如果声明为public，变量和函数都是public level visible的，任何其他的类都可以访问 用”+”表示一个变量或者函数为public private 如果声明为private，变量和函数都是class level visible的，这是所有access modifier中限制最多的一个。 仅有定义这些变量和函数的类自己可以访问。 在类图中，用”-”表示一个变量或者函数为private protected 如果声明为protected，变量和函数在能被定义他们的类访问的基础上，还能够被该类的子类所访问。 protected也是OOD当中实现继承的重要手段 在类图中，用”#”表示一个变量或者函数为protected Use Casese.g. Elevator Take external request Take internal request Open gate Close gate Check weight Class diagram 类图 为什么要画类图? 可交付，MinimalViableProduct 节省时间，不容易在Coding上挣扎 建立在Usecase上，和之前的步骤层层递进，条例清晰，便于交流和修改 如果时间允许/面试官要求，便于转化成Code 怎么画类图? 遍历你所列出的usecases 对于每一个usecase，更加详细的􏰀述这个usecase在做什么事情 (例如:take external request -&gt; ElevatorSystem takes an external request, and decide to push this request to an appropriate elevator) 针对这个􏰀述，在已有的Coreobjects里填充进所需要的信息 Challenge What if I want to apply different ways to handle external requests during different time of a day? Solution 1: if - else Solution 2: Strategy design pattern","categories":[{"name":"OOD","slug":"OOD","permalink":"http://kaihaoli.github.io/categories/OOD/"}],"tags":[]},{"title":"Binary Indexed Tree","slug":"binary-indexed-tree","date":"2018-05-17T00:56:24.000Z","updated":"2018-11-19T16:52:49.073Z","comments":true,"path":"2018/05/16/binary-indexed-tree/","link":"","permalink":"http://kaihaoli.github.io/2018/05/16/binary-indexed-tree/","excerpt":"","text":"A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. What is Binary Indexed Tree？12345# PrefixSumdef update(idx, n):# O(n), update idx-th num in the arraydef rangeSum(idx1, idx2):# O(1), calculate the sum from idx1-th to idx2-th in the arrayk 传统的数组单点修改的复杂度为 O(1)，查询子段和的复杂度为 O(n)前缀和数组单点修改的复杂度为 O(n)，查询子段和的复杂度为 O(1) Binary Indexed Tree 修改和查询子段和复杂度均为 O(logn) 所以在多组查询或动态查询时，用树状数组可以有效减小耗时，提高程序效率。 Binary Indexed Tree vs Segmented Tree 树状数组 容易实现，代码量小，时间复杂度低，并且经过数学处理后也可以实现成段更新。线段树也可以做到和树状数组一样的效果，但是代码要复杂得多。 不过要注意，一般情况下 树状数组能解决的问题线段树都能解决，反之有些线段树能解决的问题树状数组却不行。 Operation1 Build从已知数组构建树状数组就是把线性的数组变成一棵树。那么，树状数组是如何把线性结构的数组变成一棵树的呢？以下以一个长度为8的数组为例： 原始数组：1A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8] 在修改和查询子段和时，很容易想到一种类似二分的想法来构建一棵树状的数组来保存原数组的所有信息。12345678C1 = A1C2 = C1 + A2 = A1 + A2C3 = A3C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4C5 = A5C6 = C5 + A6 = A5 + A6C7 = A7C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 从中可以发现，若结点的标号为 n ，则该结点的求和区域长度为 2k ，此处的 k 为 n 的二进制表示的末尾 0 的个数。12# 只保留n的二进制里最低位的12^k = n &amp; (n ^ (n-1)) = n &amp; (-n) 前n项和分别保存在n二进制表示的每个“1”表示 i 二进制 包含A的个数 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 1 6 0110 2 7 0111 1 8 1000 8 12345678910# Time : O(nlogn)def build(self, nums): n = len(nums) # BIT 数组比原数组多一位！ A, C = nums, [0] * (n + 1) for i in range(n): k = i + 1 # Start From i+1 while k &lt;= n: C[k] += A[i] k += (k &amp; -k) # Next Parent Node 2 Update C[i]的父节点为C[i + i &amp; (-i)] 当我们修改A[i]的值时，记录变化，可以 从C[i]往根节点一路上溯，调整这条路上的所有C[p]即可，这个操作的复杂度在最坏情况下就是树的高度即O(logn)。123456def update(self, i, val): diff, self.A[i] = val - self.A[i], val i += 1 # Start From i+1 while i &lt;= self.n: self.C[i] += diff i += (i &amp; -i) # Next Parent Node 3 Range Sum 而对于求数列的前n项和S[n]，只需找到C[n]以前（包括C[n]）的所有最大子树，把其根节点的C[c]加起来即可。 123456789def sumRange(self, i, j): res, j = 0, j + 1 while j: # 前j项和(j=j+1了,数组是从0开始index的！) res += self.C[j] j -= (j &amp; -j) # Next Sum Node while i: # 前i-1项和 res -= self.C[i] i -= (i &amp; -i) return res Application307. Range Sum Query - Mutable update &amp; range sumSolution1. Update O(1), RangeSum O(n)12345678910111213class NumArray(object): def __init__(self, nums): self.nums = nums def update(self, i, val): self.nums[i] = val def sumRange(self, i, j): s = 0 for k in range(i, j+1): s += self.nums[k] return s Solution2. Update O(n), RangeSum O(1) Prefix Sum array Solution3. Update O(logn), RangeSum O(logn)123456789101112131415161718192021222324252627282930class NumArray(object): def __init__(self, nums): self.n = n = len(nums) self.A, self.C = nums, [0] *(n + 1) for i in xrange(n): k = i + 1 # tip1 : BIT index from 1 while k &lt;= n: self.C[k] += nums[i] k += k &amp; (-k) def update(self, i, val): diff = val - self.A[i] self.A[i] = val # tip2 : remember to update original array i += 1 while i &lt;= self.n: self.C[i] += diff i += i &amp; (-i) def sumRange(self, i, j): res = 0 j += 1 while j: res += self.C[j] j -= j &amp; (-j) while i: # tip3 : excluding i, so i do not need to +1 res -= self.C[i] i -= i &amp; (-i) return res 308. Range Sum Query 2D - MutableSolution1. PrefixSum Build : O(mn) Update : O(n) Region Sum : O(m) 1234567891011121314151617181920212223242526class NumMatrix(object): def __init__(self, matrix): if not matrix: return self.matrix = matrix self.preSum = copy.deepcopy(matrix) for row in self.preSum: for j in range(1, len(matrix[0])): row[j] += row[j-1] def update(self, row, col, val): diff = val - self.matrix[row][col] self.matrix[row][col] = val for j in range(col, len(self.matrix[0])): self.preSum[row][j] += diff def sumRegion(self, row1, col1, row2, col2): s = 0 for i in range(row1, row2+1): row_sum = self.preSum[i][col2] - (self.preSum[i][col1-1] if col1 &gt; 0 else 0) s += row_sum return s Solution2. BIT Build : O(mn(logm)(logn)) Update : O(logm logn) Region Sum : O(logm logn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class NumMatrix(object): def __init__(self, matrix): if not matrix: return m, n = len(matrix), len(matrix[0]) self.m, self.n = m, n self.matrix = matrix self.bit = [[0] * (n+1) for _ in xrange(m+1)] for i in xrange(m): for j in xrange(n): self.build(i, j) def build(self, row, col): val = self.matrix[row][col] i = row+1 while i &lt;= self.m: j = col + 1 while j &lt;= self.n: self.bit[i][j] += val j += j &amp; (-j) i += i &amp; (-i) def update(self, row, col, val): diff = val - self.matrix[row][col] self.matrix[row][col] = val i = row+1 while i &lt;= self.m: j = col + 1 while j &lt;= self.n: self.bit[i][j] += diff j += j &amp; (-j) i += i &amp; (-i) def getSum(self, row, col): i = row+1 res = 0 while i: j = col + 1 while j: res += self.bit[i][j] j -= j &amp; (-j) i -= i &amp; (-i) return res def sumRegion(self, row1, col1, row2, col2): return self.getSum(row2, col2) - self.getSum(row1-1, col2) - self.getSum(row2, col1-1) + self.getSum(row1-1, col1-1) 315. Count of Smaller Numbers After SelfBinary Indexed Tree &amp; Fenwick Tree 对原数组nums进行 离散化处理 排序+去重，将nums从实数范围映射到 [1, len(set(nums))]，记得到的新数组为iNums 123456idxes = &#123;&#125;for k, v in enumerate(sorted(set(nums))): idxes[v] = k + 1iNums = [idxes[x] for x in nums]# iNums 相当于重新映射后的Array，其间数值的相对大小没有改变，# 但是值总的范围映射到了[0, n]这样就可以作为BIT的index了！！ 从右向左遍历iNums，对树状数组的iNums[i]位置执行+1操作，然后统计(0, iNums[i])的区间和,也可以用线段树 把计数问题转化成了求区间和的问题！ 12345678910111213141516171819202122232425262728293031class FenwickTree(object): def __init__(self, n): self.n = n self.BIT = [0] * (n+1) def add(self, i, val): while i &lt;= self.n: self.BIT[i] += val i += i &amp; -i def sum(self, i): res = 0 while i: res += self.BIT[i] i -= i &amp; -i return resclass Solution(object): def countSmaller(self, nums): if not nums: return [] idxs = &#123;&#125; for k, v in enumerate(sorted(set(nums))): idxs[v] = k + 1 n = len(nums) ftree = FenwickTree(n) res = [] for i in xrange(n-1, -1, -1): res.append(ftree.sum(idxs[nums[i]]-1)) ftree.add(idxs[nums[i]], 1) return res[::-1]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"Tree Traversal BFS","slug":"tree-traversal-bfs","date":"2018-05-09T18:15:59.000Z","updated":"2018-11-04T16:29:41.046Z","comments":true,"path":"2018/05/09/tree-traversal-bfs/","link":"","permalink":"http://kaihaoli.github.io/2018/05/09/tree-traversal-bfs/","excerpt":"","text":"BFS Level Order Traversal When should we change layer to the next? use a new Queue to record next level! use a value to record the size of the queue on the current level 102. Binary Tree Level Order Traversal use two Queue 12345678910111213141516class Solution(object): def levelOrder(self, root): if not root: return [] queue = [root] res = [] while queue: res.append([node.val for node in queue]) nqueue = [] for node in queue: if node.left: nqueue.append(node.left) if node.right: nqueue.append(node.right) queue = nqueue return res 107. Binary Tree Level Order Traversal II just reverse the results of 102? 12345678910111213141516class Solution(object): def levelOrderBottom(self, root): if not root: return [] queue = [root] res = [] while queue: res.append([node.val for node in queue]) nqueue = [] for node in queue: if node.left: nqueue.append(node.left) if node.right: nqueue.append(node.right) queue = nqueue return res[::-1] 637. Average of Levels in Binary Tree123456789101112131415161718class Solution(object): def averageOfLevels(self, root): if not root: return [] res = [] queue = [root] while queue: level = [node.val for node in queue] ret = 1.0 * sum(level) / len(level) res.append(ret) nqueue = [] for node in queue: if node.left: nqueue.append(node.left) if node.right: nqueue.append(node.right) queue = nqueue return res 103. Binary Tree Zigzag Level Order Traversal123456789101112131415161718class Solution(object): def zigzagLevelOrder(self, root): if not root: return [] queue = [root] res = [] while queue: level = [node.val for node in queue] if len(res) % 2: level.reverse() res.append(level) nqueue = [] for node in queue: if node.left: nqueue.append(node.left) if node.right: nqueue.append(node.right) queue = nqueue return res Another Solution : Use Deque!In the even level:expand a node from the right end of the dequ, generate right and then left child, and insert them to the left end of the deque. 662. Maximum Width of Binary Treeif use index to calculate whicn index in its level 2 idx, 2 idx + 1 123456789101112131415161718class Solution(object): def widthOfBinaryTree(self, root): if not root: return 0 queue = [(root, 0)] res = 1 while queue: nqueue = [] for node, idx in queue: if node.left: nqueue.append((node.left, 2*idx)) if node.right: nqueue.append((node.right, 2*idx+1)) if nqueue: res = max(res, nqueue[-1][1] - nqueue[0][1] + 1) queue = nqueue return res Linked List Queue O(1) Space complexity 116. Populating Next Right Pointers in Each Node Actually its the “linked list” version BFS, so space complexity is constant!!1234567891011121314class Solution: def connect(self, root): if not root: return cur = root while cur.left: head = cur.left while cur: cur.left.next = cur.right if cur.next: cur.right.next = cur.next.left cur = cur.next cur = head 117. Populating Next Right Pointers in Each Node II Do not know the head of next level, so DummyNode make it easier to implement!!!1234567891011121314151617181920class Solution: def connect(self, root): if not root: return DummyNode = TreeLinkNode(-1) head = root while head: DummyNode.next = None prev = DummyNode cur = head while cur: if cur.left: prev.next = cur.left prev = cur.left if cur.right: prev.next = cur.right prev = cur.right cur = cur.next head = DummyNode.next","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"},{"name":"bfs","slug":"bfs","permalink":"http://kaihaoli.github.io/tags/bfs/"}]},{"title":"Tree Traversal DFS","slug":"tree-traversal-dfs","date":"2018-05-08T16:31:42.000Z","updated":"2018-11-06T15:56:36.342Z","comments":true,"path":"2018/05/08/tree-traversal-dfs/","link":"","permalink":"http://kaihaoli.github.io/2018/05/08/tree-traversal-dfs/","excerpt":"","text":"Tree DFS Recursion vs Iteration.Too easy to use recursion to solve the traversal problem, Why we need the iterative solution? Java meomory area STACK: storing the local variables and other information for each of the method calls HEAP: allocationg spaces for dynamically created objects Threads have their own stack, but they share same heap! Python内存中没有真正的堆栈，因为所有的对象都是在堆上分配的，but python默认的递归深度是很有限的（默认是1000） STACK In Java, STACK is usually a size limited memory area.By default, a several thousands levels recursion call would easily eat up all the space and throw StackOverFlowException - this is something you have to keep in mind Iterative way is good because it needs much less space of STACK(There is probably only O(1) method call levels, so O(1) space on STACK.) It is not easy to convert all recursion solutions to a “while loop” solution without any other auxiliary data structures’ help. 12345678# Recursive Inorder Traversalclass Solution(object): def inorderTraversal(self, root): if not root: return [] self.inorderTraversal(root.left) print(root.val) self.inorderTraversal(root.right) There are two paths of recursion need to follow instead of one, and we need to finish the first branch, then the second one. In this case, we will need something else to help us: The recursion is internally done by using STACK to maintain the method call levels and directions, we can simulate this ourselves, so a stack will be needed. The difference is, we use our own stack and the space used by our own stack is on HEAP. The space consumed on STACK is trivial. We do not change the total space consumption, but we move out the space consumption of STACK to HEAP!!! 144. Binary Tree Preorder TraversalRecursion123456class Solution(object): def preorderTraversal(self, root): if not root: return [] return ([root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)) Iteration (Stack) 1 stack一出栈 一看见就访问！ 2 出栈元素的右子节点先加入栈，再加左子节点 每个node其实处理了两次，一次是入栈，一次是出栈 1234567891011121314class Solution(object): def preorderTraversal(self, root): if not root: return [] stack = [root] res = [] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 94. Binary Tree Inorder TraversalRecursion1234567class Solution(object): def inorderTraversal(self, root): if not root: return [] left = self.inorderTraversal(root.left) right = self.inorderTraversal(root.right) return left + [root.val] + right Iteration (Stack + cur)The problem is, we can not throw away the root in the stack before we traversed all the nodes in left subtreee. How can we know we have already traversed all the nodes in left sub? The root is the top element in the stack, use a helper node to store the next “visiting” node and subtree. 1 When helper node is not null, we should traverse the subtree, so we push helper and we go left 2 When helper is null, means the left subtree of the roots finished, the root is the top element in the stack. We can print the top, and let helper = top.right.(traverse the left subtree firtst, then top. then right subtree) 3 do 1 and 2 until helper is null and there is no nodes left in the stack 123456789101112131415161718192021222324252627282930313233# 写法1.class Solution(object): def inorderTraversal(self, root): if not root: return [] res, stack = [], [] cur = root while stack or cur: while cur: stack.append(cur) cur = cur.left cur = stack.pop() res.append(cur.val) cur = cur.right return res# 写法2.class Solution(object):def inorderTraversal(self, root): if not root: return [] stack, res = [], [] cur = root while stack or cur: if cur: stack.append(cur) cur = cur.left else: cur = stack.pop() res.append(cur.val) cur = cur.right return res 145. Binary Tree Postorder TraversalRecursion1234567class Solution(object): def inorderTraversal(self, root): if not root: return [] left = self.inorderTraversal(root.left) right = self.inorderTraversal(root.right) return left + right + [root.val] Iteration解法1. Two Stacks left-&gt;right-&gt;root (reverse)=&gt; root-&gt;right-&gt;left Preorder -&gt; Postorder 1234567891011class Solution(object): def postorderTraversal(self, root): # Pre-order, but root-&gt;right-&gt;left stack, res = [root], [] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1] What is the drawback of two stacks solution, if we deal with the nodes on the fly? (Online)Need to store everything in memory before we can get the whole post order traversal sequenct. 解法2. Stack + cur + prevThe problem is, we need to traverse both left and right subtrees first, then we can eliminate the root from the stack. We need an mechanism to know, when we finished visiting all subtrees’ nodes. What we need to know? Direction!!!!!!! we are visiting down? or returning from left? or returning from right? 思路1. 细分三种caseThe root is the top element in the stackMaintain a previous Node, to record the previous visiting node on the tracersing path, so that we know what the direction we are taking now and what is the direction we are taking next. root = stack.top if previous is null -&gt; going down(left subtree has priority) if previous is current’parent -&gt; going down (left subtree has priority) if previous == current.left -&gt; left subtree finished, going current.right if previous == current.right -&gt; right subtree finished, pop current, going up. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 思路写法class Solution(object): def postorderTraversal(self, root): if not root: return [] prev = None stack = [root] res = [] while stack: cur = stack[-1] # Case1: 从父节点而来 if not prev or cur == prev.left or cur == prev.right: if cur.left: stack.append(cur.left) elif cur.right: stack.append(cur.right) else: # 叶子节点 res.append(cur.val) stack.pop() # Case2: 从左子树遍历完而来 elif prev == cur.left: if cur.right: stack.append(cur.right) else: res.append(cur.val) stack.pop() # Case3: 从右子树遍历完而来 else: res.append(cur.val) stack.pop() prev = cur return res# 简化写法class Solution(object): def postorderTraversal1(self, root): if not root: return [] prev = None stack = [root] res = [] while stack: cur = stack[-1] # Case1: 从父节点而来 if not prev or cur == prev.left or cur == prev.right: if cur.left: stack.append(cur.left) elif cur.right: stack.append(cur.right) # Case2: 从左子树遍历完而来 elif prev == cur.left: if cur.right: stack.append(cur.right) # Case3: 从右子树遍历完而来 或者 是叶子节点 else: res.append(cur.val) stack.pop() prev = cur return res 思路2 只划分上下两种case 12345678910111213141516171819202122class Solution(object): def postorderTraversal(self, root): if not root: return [] prev = None stack, res = [root], [] while stack: cur = stack[-1] # Case1: 什么时候访问节点？ # 1.叶子节点 2.从子节点而来 if (not cur.left and not cur.right) or (prev and (cur.right == prev or cur.left == prev)): node = stack.pop() res.append(node.val) prev = node # Case2: 从父节点而来 else: if cur.right: stack.append(cur.right) if cur.left: stack.append(cur.left) return res 什么时候访问root节点？ preorder: 直接访问 stack inorder: 左subtree访问完了，再访问 stack+cur postorder: 左右subtree访问完了，再访问 stack+cur+prev 590. N-ary Tree Postorder Traversal Recursion 1234567891011121314class Solution(object): def postorder(self, root): res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return for child in root.children: self.dfs(child, res) res.append(root.val) IterationUse ‘Two Stack’ Postorder Traversal Way! 12345678910111213class Solution(object): def postorder(self, root): if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) for child in node.children: stack.append(child) return res[::-1] 589. N-ary Tree Preorder Traversal12345678910111213# Iterationclass Solution(object): def preorder(self, root): if not root: return [] stack = [root] res = [] while stack: node = stack.pop() res.append(node.val) for child in node.children[::-1]: stack.append(child) return res Morris Traversal 1968年，Knuth提出说能否将该问题的空间复杂度压缩到O(1)，同时原树的结构不能改变。 大约十年后，1979年，Morris在”Traversing Binary Trees Simply and Cheaply”这篇论文中用一种Threaded Binary Tree的方法解决了该问题。 Morris算法在遍历过程中动态的构建Threaded Binary Tree，同时在结束时又将树恢复原样，在满足O(1)空间复杂度的同时也恰好满足Knuth对树结构不能改变的要求。适合空间复杂度要求高的场合！ 1234567891011121314151617181920212223242526# Inorder Demo Morris Traversalclass Solution(object): def inorderTraversal(self, root): if not root: return [] res = [] cur = root while cur: if not cur.left: res.append(cur.val) cur = cur.right else: # 1 Find Inorder Predecessor of cur prev = cur.left while prev.right and prev.right != cur: prev = prev.right # 2 Connect or Restore the Pointer if not prev.right: prev.right = cur cur = cur.left else: prev.right = None res.append(cur.val) cur = cur.right return res","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]},{"title":"Spark Quick Start","slug":"spark-quick-start","date":"2018-05-01T18:24:06.000Z","updated":"2018-05-02T18:13:12.776Z","comments":true,"path":"2018/05/01/spark-quick-start/","link":"","permalink":"http://kaihaoli.github.io/2018/05/01/spark-quick-start/","excerpt":"","text":"Apache Spark™ is a unified analytics engine for large-scale data processing. Speed Computation optimization (DAG, thread-based) In memory computing Easy to Use &amp; Generality Interactive Shell with the Scala, Python, R, and SQL shells. 80 high-level operators that make it easy to build parallel apps. Combine SQL, streaming, and complex analytics.(多个框架的学习成本) Runs Everywhere Spark runs on Hadoop, Apache Mesos, Kubernetes, standalone, or in the cloud. 技术选型！Access data in HDFS, Apache Cassandra, Apache HBase, Apache Hive, and hundreds of other data sources. Overview History Quick Start Reference : Quick Start Spark Install Spark without Hadoop Download a packaged release of Spark from the Spark website. Since we won’t be using HDFS, you can download a package for any version of Hadoop. 下载即可用 Interact with the Spark ShellSpark’s shell provides a simple way to learn the API, as well as a powerful tool to analyze data interactively. It is available in either Scala or Python. Start Start it by running pyspark in the Spark directory 1./bin/pyspark DataSetSpark’s primary abstraction is a distributed collection of items called a Dataset.(Before Spark2.x, it called Resilient Distributed Dataset (RDD)) Datasets can be created from Hadoop InputFormats (such as HDFS files) or by transforming other Datasets. Due to Python’s dynamic nature, we don’t need the Dataset to be strongly-typed in Python. As a result, all Datasets in Python are Dataset[Row], and we call it DataFrame to be consistent with the data frame concept in Pandas and R. Make a new DataFrame from the text of the README file 123456&gt;&gt;&gt; textFile = spark.read.text(\"README.md\")&gt;&gt;&gt; textFile.count() # Number of rows in this DataFrame103&gt;&gt;&gt; textFile.first() # First row in this DataFrameRow(value=u'# Apache Spark') Transform this DataFrame to a new one12345# We call filter to return a new DataFrame with a subset of the lines in the file.&gt;&gt;&gt; linesWithSpark = textFile.filter(textFile.value.contains(\"Spark\"))# How many lines contain \"Spark\"?&gt;&gt;&gt; textFile.filter(textFile.value.contains(\"Spark\")).count() 20 Self-Contained ApplicationsScala (with sbt), Java (with Maven), and Python (pip). This program just counts the number of lines containing ‘a’ and the number containing ‘b’ in a text file. 1234567891011121314\"\"\"spark-test.py\"\"\"from pyspark.sql import SparkSession# TODO : YOUR_SPARK_HOMElogFile = \"/Users/kaihaoli/Downloads/spark-2.3.0-bin-hadoop2.7/README.md\"spark = SparkSession.builder.appName(\"SimpleApp\").getOrCreate()logData = spark.read.text(logFile).cache()numAs = logData.filter(logData.value.contains('a')).count()numBs = logData.filter(logData.value.contains('b')).count()print(\"Lines with a: %i, lines with b: %i\" % (numAs, numBs))spark.stop() Install pySpark 1&gt; pip install pyspark Run the simple application 1234&gt; python spark-test.py........Lines with a: 61, lines with b: 30....... Spark Streaming With KafkaSparkContext Main entry point for Spark functionality. A SparkContext represents the connection to a Spark cluster, and can be used to create RDD and broadcast variables on that cluster. master = “local[2]”, appName = “StockAveragePrice“123from pyspark import SparkContextsc = SparkContext(\"local[2]\", \"StockAveragePrice\")sc.setLogLevel('ERROR') StreamingContext Main entry point for Spark Streaming functionality. A StreamingContext represents the connection to a Spark cluster, and can be used to create DStream various input sources.123from pyspark.streaming import StreamingContextssc = StreamingContext(sc, 5)# sparkContext = sc, batchDuration = 5 KafkaUtils KafkaUtils.createDirectStream(ssc, topics, kafkaParams,…) Create an input stream that directly pulls messages from a Kafka Broker and specific offset.12345678from pyspark.streaming.kafka import KafkaUtilstopic = \"test\"brokers = \"192.168.99.100:9092\"# Kafka ConsumerdirectKafkaStream = KafkaUtils.createDirectStream( ssc, [topic], &#123;'metadata.broker.list': brokers&#125;)","categories":[{"name":"Big Data","slug":"Big-Data","permalink":"http://kaihaoli.github.io/categories/Big-Data/"}],"tags":[]},{"title":"Bit Manipulation 位运算","slug":"bit-manipulation","date":"2018-04-30T01:17:56.000Z","updated":"2018-05-06T01:21:58.230Z","comments":true,"path":"2018/04/29/bit-manipulation/","link":"","permalink":"http://kaihaoli.github.io/2018/04/29/bit-manipulation/","excerpt":"","text":"Basic知识点1 原码 反码 补码最高位存符号位。 正数：原码=反码=补码 ； 负数：符号位不变，原码 –(取反)–&gt; 反码 –(+1)–&gt; 补码 浮点数的位表示123456&gt;&gt;&gt; 0.2+0.4==0.6False&gt;&gt;&gt; 0.2+0.40.6000000000000001# Python, Java(Double), Why not 0.6?# tips:做浮点数的时候，知道有精度丢失这么个点 知识点2 位运算符 Java 位运算符 位运算符号 &amp; 注意和逻辑运算符区别 &amp;&amp; &#124; 逻辑运算符 &#124;&#124; ～ 逻辑运算符 ！ ^ 异或 相异为1 相同为0 &lt;&lt; left shift 补0, 会溢出的”*2” &gt;&gt; right shift 补0或1，保持和最高位相同Why？”/2” &gt;&gt;&gt; 无符号right shift 补0 Python 位运算符 位运算符号 &amp; and &#124; or ～ not ^ 异或 相异为1 相同为0 &lt;&lt; left shift 补0 无溢出的 “*2” &gt;&gt; right shift 补0或1，保持和最高位相同 “/2” 知识点3 空间优化Contain Unique Letter WordDetermine whether a word contains all letters that are unique (no duplicate letters in the word). 1 HashSet 2 Array，256个ASCII码 长度256的Array 3 Bit Vector 充分利用空间！！ xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx 0~31th bit xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx 32~63th bit … … 318. Maximum Product of Word Lengths给定一个字符串数组words，寻找length(words[i]) * length(words[j])的最大值，其中两个单词不包含相同字母。你可以假设每一个单词只包含小写字母。如果不存在这样的两个单词，返回0 1 Two words do not share common letters ：Bit！ 2 包含相同类型letter的word只用取长度最长的 1234567891011121314151617181920class Solution(object): def maxProduct(self, words): n = len(words) if n &lt;= 1: return 0 d = &#123;&#125; for word in words: mask = 0 for ch in word: mask |= (1 &lt;&lt; (ord(ch) - ord('a'))) d[mask] = max(d.get(mask, 0), len(word)) # pythonic： # return max([d[x]*d[y] for x in d for y in d if not x &amp; y]) res = 0 for x in d: for y in d: if not x &amp; y: res = max(res, d[x] * d[y]) return res 异或^ 两个相等的数经过异或运算会相互抵消 通常用来删除偶数个相同的数字，保留基数个个数的数字 Swap Two Integers不建议在实际应用中采用 1 不一定比朴素方法快 2 a 和 b 引用同一变量 123456789void Swap(int &amp;a, int &amp;b) &#123; if (a != b) &#123; a ^= b; b ^= a; a ^= b; &#125; &#125; 389. Find the Difference给定两个字符串s和t，都只包含小写字母。字符串t由字符串s打乱顺序并且额外在随机位置添加一个字母组成。寻找t中新增的那个字母。（和single number一样）1234567class Solution(object): def findTheDifference(self, s, t): res = 0 n = len(s) for i in range(n): res ^= ord(s[i]) ^ ord(t[i]) return chr(res ^ ord(t[n])) 268. Missing Number给定一个包含从0, 1, 2, …, n, 选出的n个不同数字的数组，从中找出数组中缺失的那一个数。这里是少了一个数，single number 是多了一个数。123456class Solution(object): def missingNumber(self, nums): ret = 0 for n in nums+range(len(nums)+1): ret ^= n return ret 136. Single Number所有数字都出现偶数次，只有一个数字出现奇数次，求出现奇数次的那个数 解法1. HashSet 12345678910# Time : O(n), Space : O(n)class Solution(object): def singleNumber(self, nums): numSet = set() for n in nums: if n in numSet: numSet.remove(n) else: numSet.add(n) return list(numSet)[0] 解法2.异或 12345678# Time : O(n), Space : O(1)# 偶数次异或可以抵消class Solution(object): def singleNumber(self, nums): ret = 0 for n in nums: ret ^= n return ret 137. Single Number II所有数字出现三次，只有一个数字出现一次，求出现一次那个数。 解法1. HashTable 12345678910111213# Time : O(n), Space : O(n)class Solution(object): def singleNumber(self, nums): dic = &#123;&#125; for n in nums: if n in dic: if dic[n] == 2: del dic[n] else: dic[n] += 1 else: dic[n] = 1 return dic.keys()[0] 解法2. 用二进制模拟三进制运算从一个bit出发考虑到32个bits 1234cnt : 0 1 2 3 4one : 0 -&gt; 1 -&gt; 0 -&gt; (1 -&gt; 0) -&gt; 1two : 0 -&gt; 0 -&gt; 1 -&gt; (1 -&gt; 0) -&gt; 0mask : 1 1 1 1 0 1234567891011# Time : O(n), Space : O(1)class Solution(object): def singleNumber(self, nums): one = two = 0 for n in nums: two |= n &amp; one one ^= n mask = ~(one &amp; two) one &amp;= mask two &amp;= mask return one 260. Single Number III所有数字都出现两次，但是有两个数字只出现了一次。1234a ^ a ^ b ^ b ^ c ^ d = c ^ d0101 0100 c1001 0010 d1100 0110 c^d 把只出现一次的c和d分到两个组里 123456789101112131415class Solution(object): def singleNumber(self, nums): mask = 0 for n in nums: mask ^= n mask &amp;= (-mask) a, b = 0, 0 for n in nums: if n &amp; mask: a ^= n else: b ^= n return [a, b] 371. Sum of Two Integers 用^和&amp;，构成加法运算 ^表示相加后的结果，&amp;后的&lt;&lt; 1表示相加后的进位(理解加减法的位操作) 1234567891011121314151617// Iterativepublic int getSum(int a, int b) &#123; if (a == 0) return b; if (b == 0) return a; while (b != 0) &#123; int carry = a &amp; b; a = a ^ b; b = carry &lt;&lt; 1; &#125; return a;&#125;// Recursivepublic int getSum(int a, int b) &#123; return (b == 0) ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);&#125; n &amp; (n-1) 算是一个小trick！ n&amp;(n-1)可消除n中最右边(低位)的一个1 1230101 1000 n0101 0111 n - 1 0101 0000 n &amp; (n-1) 191. Number of 1 Bits统计一个整数用二进制表示时1的个数123456789// Javapublic int hammingWeight(int n) &#123; int cnt = 0; while (n != 0) &#123; cnt++; n &amp;= (n - 1); &#125; return cnt;&#125; 231. Power of Two判断一个数是不是2的n次幂12340000 0001 2^00000 0010 2^10000 0100 2^20000 1000 2^3 123456// Javaclass Solution &#123; public boolean isPowerOfTwo(int n) &#123; return (n &gt; 0) &amp;&amp; (((n - 1) &amp; n) == 0); &#125;&#125; 326. Power of Three 也有一行代码更数学上tricky的方法：return n &gt; 0 &amp;&amp; 1162261467 % n == 0; 12345678910111213141516// Java1 - Mathpublic class Solution &#123; public boolean isPowerOfThree(int n) &#123; return (Math.log10(n) / Math.log10(3)) % 1 == 0; &#125;&#125;// Java2 - Forloopclass Solution &#123; public boolean isPowerOfThree(int n) &#123; while (n &gt; 0 &amp;&amp; (n%3 == 0)) &#123; n /= 3; &#125; return n == 1; &#125;&#125; 342. Power of Four1234567891011121314151617181920// Java1 for loopclass Solution: def isPowerOfFour(self, n): if n &lt; 1: return False while n % 4 == 0: n = n / 4 return n == 1// Java2 Math// 0000 0001 1// 0000 0100 4// 0001 0000 16// 0100 0000 64class Solution &#123; public boolean isPowerOfFour(int n) &#123; //一个数学的方法：(4^n - 1) is multiple of 3 return (n &gt; 0) &amp;&amp; (n&amp;(n-1)) == 0 &amp;&amp; (n-1) % 3 == 0; &#125;&#125; 461. Hamming Distance两个整数的汉明距离是指其二进制不相等的位的个数12345678910111213141516class Solution(object): def hammingDistance(self, x, y): n = x ^ y # =&gt; Count bits of a number cnt = 0 while n: n &amp;= (n-1) cnt += 1 return cnt def hammingDistance1(self, x, y): n = x ^ y cnt = 0 while n: cnt += n &amp; 1 n &gt;&gt;= 1 return cnt 477. Total Hamming Distance两个整数的汉明距离是指其二进制不相等的位的个数, 计算给定的整数数组两两之间的汉明距离之和。 解法1. n^2 paris (TLE) 解法2. 拆解integer12345678910111213141516# Time : O(32 * n), Space : O(1)class Solution(object): def totalHammingDistance(self, nums): n = len(nums) if n &lt;= 1: return 0 res = 0 mask = 1 for _ in xrange(32): cnt1 = 0 for num in nums: if num &amp; mask: cnt1 += 1 mask &lt;&lt;= 1 res += (n - cnt1) * cnt1 return res 201. Bitwise AND of Numbers Range123456# [26, 30]1101011011111001110111110 仔细观察这个过程我们可以得出^_^，最后的结果是该范围内所有数的左边的共同部分，即公共左边首部(left header)12345class Solution(object): def rangeBitwiseAnd(self, m, n): while m &lt; n: n &amp;= n-1 return n Advanced Topicn &amp; (-n)n &amp;-n returns the rightmost 1 bit in n., 属于第一次见，很难理解的小trick，这个会在Binary Indexed Tree中用到！ 123456789101112n &amp; (n ^ (n-1)) = n &amp; (-n)0000 1011 111111 01001111 0101 -110000 0001 11 &amp; (-11)1010 1000 1680101 01110101 1000 -1680000 1000 168 &amp; (-168)# 充分利用了“取反加一”！ 正整数n的二进制表示中，只保留最低位的1的值！","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[]},{"title":"Kafka Quick Start using Docker","slug":"docker-quick-start","date":"2018-04-26T01:20:22.000Z","updated":"2018-04-26T01:24:35.459Z","comments":true,"path":"2018/04/25/docker-quick-start/","link":"","permalink":"http://kaihaoli.github.io/2018/04/25/docker-quick-start/","excerpt":"","text":"Reference : Kafka Quick Start Guide Pre-RequisitesDocker 1 Create Virtual MachineGet the env for docker-machine, 2CPU, 2G1&gt; docker-machine create --driver virtualbox --virtualbox-cpu-count 2 --virtualbox-memory 2048 bigdata This command downloads a lightweight Linux distribution (boot2docker) with the Docker daemon installed, and creates and starts a VirtualBox VM with Docker running. docker-machine create 创建一个Docker主机 –driver virtualbox flag to indicate which provider (VirtualBox, DigitalOcean, AWS, etc.) the machine should be created on. ‘bigdata’ is an argument to indicate the name of the created machine. list available machines.1&gt; docker-machine ls Get the IP address of one or more machines.1&gt; docker-machine ip bigdata 2 Connect your shell to the machine Show the virtual machine environment variable 12345&gt; docker-machine env bigdataexport DOCKER_TLS_VERIFY=\"1\"export DOCKER_HOST=\"tcp://192.168.99.100:2376\"export DOCKER_CERT_PATH=\"/Users/yourhostname/.docker/machine/machines/bigdata\"export DOCKER_MACHINE_NAME=\"bigdata\" Run this command to configure your shell 12# Each time you want to use this virtual machine, you should run this command first!&gt; eval $(docker-machine env bigdata) 3 Pull Images12&gt; docker pull wurstmeister/zookeeper &gt; docker pull wurstmeister/kafka 4 Run Images Start zookeeper container 1234567&gt; docker run \\ -d \\ -p 2181:2181 \\ -p 2888:2888 \\ -p 3888:3888 \\ --name zookeeper \\ wurstmeister/zookeeper Start kafka container 12345678910&gt; docker run \\ -d \\ -p 9092:9092 \\ # IP=$(docker-machine ip $&#123;MACHINE_NAME&#125;) -e KAFKA_ADVERTISED_HOST_NAME=\"$&#123;IP&#125;\" \\ -e KAFKA_ADVERTISED_PORT=9092 \\ --name kafka \\ --link zookeeper:zookeeper \\ -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\ wurstmeister/kafka 5 Kafka Test Enter the Kafka container 12# here CONTAINER ID = kafka&gt; docker exec -it $&#123;CONTAINER ID&#125; /bin/bash Change to kafka default directory 1&gt; cd opt/kafka_2.xx-x.xx.x.x/ Create a Topic 1&gt; bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic mykafka Run a Producer 1&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka Run a Consumer(in another terminal!) 1&gt; bin/kafka-console-consumer.sh --zookeeper zookeeper:2181 --topic mykafka --from-beginning TESTWhen you type in some words in producer, it will appear in the consumer terminal. Kafka will replay the messages you have sent as a producer. All Done! :)","categories":[{"name":"Big Data","slug":"Big-Data","permalink":"http://kaihaoli.github.io/categories/Big-Data/"}],"tags":[]},{"title":"Docker","slug":"docker","date":"2018-04-22T00:31:44.000Z","updated":"2018-04-22T01:57:45.616Z","comments":true,"path":"2018/04/21/docker/","link":"","permalink":"http://kaihaoli.github.io/2018/04/21/docker/","excerpt":"","text":"参考资源: Docker — 从入门到实践 Docker 入门教程 阮一峰 History Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 Why use Docker? Docker - Build, Ship, and Run Any App, Anywhere 向服务器部署代码非常困难 复杂的技术栈, 不同技术栈的版本依赖与冲突 How to solve it?Docker vs VM What is Docker?Docker的三个概念 1 镜像(Image) 类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。 任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 2 容器(Container) 类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。 Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。 注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 3 仓库(Repository) 类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。 注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 Union File System Docker Components Docker daemon Runs on a host machine. It does the heavy lifting of building, running, and distributing Docker containers Docker client The primary user interface to Docker. It accepts commands from the user and communicates back and forth with a Docker daemon Docker images Docker image is a read-only template, which is used to create containers Docker registries Docker registries hold images, which are public or private stores from which you upload or download images. Docker containers Docker containers are similar to a directory. 性质 A Docker container holds everything that is needed for an application to run. Each container is created from a Docker image. Docker containers can be run, started, stopped, moved, and deleted. Each container is an isolated and secure application platform. ApplicationDocker 的主要用途，目前有三大类。 1 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 2 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 3 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 Docker on MacInstall1$ brew cask install docker","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Message Queue 消息队列","slug":"message-queue","date":"2018-04-18T22:21:34.000Z","updated":"2018-04-18T22:28:21.883Z","comments":true,"path":"2018/04/18/message-queue/","link":"","permalink":"http://kaihaoli.github.io/2018/04/18/message-queue/","excerpt":"","text":"参考资料: 大型网站架构系列：分布式消息队列 What is Message Queue A message queue is a queue of messages sent between applications. 中间人 Message queues provide an asynchronous communications protocol, meaning that the sender and receiver of the message do not need to interact with the message queue at the same time. An application framework for sending and receiving messages A way to communicate between applications / systems A way to decouple components A way to offload work (handle to another worker) Application Allow web servers to respond to requests quickly instead of being forced to perform resource-heavy procedures. Able to distribute a message to multiple recipients for consumption or for balancing loads between workers. 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。 目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。 Message Queue in Real Life对实时性要求不高的任务！ Image Resizing Video Processing Sending out Emails (Ad Campaigns) Log Analysis … AMPQ协议Message Queue Protocol AMQP - Advanced Message Queue Protocol (RabbitMQ) STOMP - Streaming Text Oriented Messaging Protocol (ActiveMQ) XMPP - Extensible Messaging and Presence Protocol Network wire-level protocol Defines how clients and brokers talk Data serialization, heartbeat AMQP Model Defines routing and storing of messages Defines rules how these are wired together Exported API RabbitMQ RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。Implements AMQP Easy to use, 支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 Open source and commercially supported RabiitMQ Solution Could-based Solution CloudAMQP CloudAMPQ in Python使用教程 Local1brew install rabbitmq # would take long","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Redis","slug":"redis","date":"2018-04-17T23:23:40.000Z","updated":"2018-04-18T22:32:23.103Z","comments":true,"path":"2018/04/17/redis/","link":"","permalink":"http://kaihaoli.github.io/2018/04/17/redis/","excerpt":"","text":"(参考资料:Redis学习教程Gitbook, RUNOOB Redis 教程) What is Redis Redis is an opensource(BSDlicensed), in-memory datas tructure store, used as database, cache and message broker. database只是Redis的一个应用， In-memory data structure store Data Structure Operations Strings - 字符串 SET, GET, APPEND Hashes - 哈希表 HSET, HGET List - 列表 LPUSH, LRANGE, LSET, LTRIM Set - 集合 SADD, SMEMBERS Sorted Set ZADD, ZRANGE, ZRANGEBYSCORE Why Redis Redis 有三个主要的特点, 有别于其它很多竞争对手 ： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以 再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Application (1) Cache Replacement - LRU LFU Pre-load (2) Message Broker MQ (3) Database Redis Install &amp; Config Install Redis with MAC 12345678910# Installbrew install redis# Startbrew services start redis# or redis-server /usr/local/etc/redis.conf# CMD~ % redis-cli127.0.0.1:6379&gt; Try CMD here : Redis Interactive Online Redis in PythonThe Python interface to the Redis key-value store. Install1sudo pip install redis ConnectionOpening a Connection to Redis Using redis-py123456#The following code creates a connection to Redis using redis-py:import redisredis_client = redis.Redis( host = 'hostname', port = port # redis default port 6379) redis提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。 redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。如果需要另一个Redis实例（or Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。同理，python的redis没有实现select命令。 12345# set, getr.set('name', 'junxi') # key是\"foo\" value是\"bar\" 将键值对存入redis缓存print(r['name'])print(r.get('name')) # 取出键name对应的值print(type(r.get('name')))","categories":[{"name":"Full Stack","slug":"Full-Stack","permalink":"http://kaihaoli.github.io/categories/Full-Stack/"}],"tags":[]},{"title":"Binary Search","slug":"binary-search","date":"2018-04-16T03:31:10.000Z","updated":"2018-10-10T19:41:09.635Z","comments":true,"path":"2018/04/15/binary-search/","link":"","permalink":"http://kaihaoli.github.io/2018/04/15/binary-search/","excerpt":"","text":"Given a sorted array of n elements, write a function to search a given element x in array. Search算法里的入门算法，其实很多高级算法的思路都是以二分查找为基本思想引出的，特别是那些和logn相关的算法，比如说自平衡二叉树 经典二分查找 LintCode 457. \bClassical Binary Search 有序, 数组 Why 链表不可以？Why 无序不可以？ 1234567891011121314151617181920class Solution: def findPosition(self, nums, target): if not nums: return -1 # 1 Two Pointers 指向可行解的范围 start, end = 0, len(nums)-1 while start &lt;= end: # 2 Median Index mid = start + (end - start) // 2 # 3 Check Median Index Val if nums[mid] == target: return mid elif nums[mid] &gt; target: end = mid - 1 # Adjust end else: start = mid + 1 # Adjust start return -1 74. Search a 2D Matrix 一维Array和二维Matrix的转换 index =&gt; (x, y) x = index / col y = index % col 12345678910111213141516class Solution(object): def searchMatrix(self, matrix, target): if not matrix: return False m, n = len(matrix), len(matrix[0]) start, end = 0, m*n-1 while start &lt;= end: mid = start + (end - start) / 2 row, col = mid / n, mid % n if matrix[row][col] &lt; target: start = mid + 1 elif matrix[row][col] &gt; target: end = mid - 1 else: return True return False 九章算法二分查找模板 while 循环 ? while start + 1 &lt; end, 留两个值做post processing while start &lt; end, 留一个值做post processing while start &lt; = end, 不留值 缩小查找范围 ? start = mid 还是 start = mid + 1 end = mid 还是 end = mid + 1 1234567891011121314151617181920212223def findPosition(self, A, target): if(len(A) == 0): return -1 start = 0 end = len(A) - 1 while(start + 1 &lt; end): mid = start + (end - start) / 2 if(A[mid] == target): return mid if(A[mid] &lt; target): start = mid else: end = mid #post processing if (A[start] == target): return start elif (A[end] == target): return end else: return -1 Double Check 小技巧: 当前这个mid对应的值是不是 可能是要找的结果，mid + 1 还是 mid ? start = mid 一定要用 while start + 1 &lt; end !!! 要找的结果是不是一定在数组当中！start &lt; end 还是 start &lt; = end 边界系列 Input是标准的 Sorted Array（单调增或者单调减） First or Last of Occrance! 大于等于，小于等于，大于，小于，等于 每次淘汰的空间要确定是不属于结果范围的！ 278. First Bad Version 000000011111111 Find The First Occrance of an Element 找的元素在不在数组里？while start &lt; end 还是 while start &lt; = end How about Last Good Version? 1234567891011121314151617181920212223242526272829303132# 写法1. 这种写法条件是target存在，且start = mid + 1class Solution(object): def firstBadVersion(self, n): start, end = 1, n while start &lt; end: mid = start + (end - start) / 2 ret = isBadVersion(mid) if ret: end = mid else: start = mid + 1 return start# 写法2. 九章算法模板 - 预留两位做post processingclass Solution(object): def firstBadVersion(self, n): start, end = 1, n # 预留两位最后处理 while start + 1 &lt; end: mid = start + (end - start) / 2 ret = isBadVersion(mid) if ret: end = mid else: start = mid + 1 # Post Processing if isBadVersion(start): return start else: return end 35. Search Insert Position 找 &gt; = target 的 first occrence 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): if not nums: return 0 if target &gt; nums[-1]: return len(nums) start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt;= target: end = mid else: start = mid + 1 # Post Precessing if nums[start] &gt;= target: return start else: return end 34. Search for a Range12345678910111213141516171819202122232425262728293031323334class Solution(object): def searchRange(self, nums, target): if not nums: return [-1, -1] # First Occurance start, end = 0 , len(nums) - 1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt;= target: end = mid else: start = mid + 1 if nums[start] == target: first = start elif nums[end] == target: first = end else: return [-1, -1] # Last Occurance start, end = 0, len(nums) - 1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt;= target: start = mid else: end = mid - 1 if nums[end] == target: return [first, end] else: return [first, start] 旋转数组系列 只有Sorted Array才能做Binary Search？ Input数组不再是单调递增或者单调递减 每次淘汰的空间要确定是不属于结果范围的！ 162. Find Peak Element 根据要找的Target条件缩小Search的范围！ 1234567891011121314151617# 模版解法class Solution(object): def findPeakElement(self, nums): if len(nums) &lt;= 1: return 0 start, end = 0 , len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[mid+1]: start = mid + 1 else: end = mid if nums[start] &gt; nums[end]: return start else: return end 12345678910111213class Solution(object): def findPeakElement(self, nums): if len(nums) &lt;= 1: return 0 start, end = 0 , len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[mid+1]: start = mid + 1 else: end = mid return start 153. Find Minimum in Rotated Sorted Array Why nums[mid] 和 nums[end]比较？ 1234567891011# 模版解法class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt; nums[end]: start = mid + 1 else: end = mid return min(nums[start], nums[end]) 12345678910class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &gt; nums[end]: start = mid + 1 else: end = mid return nums[start] 154. Find Minimum in Rotated Sorted Array II What if duplicates are allowed? Worst Case O(n) 123456789101112131415161718192021222324252627# nums[mid] == nums[end] ?class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return nums[start]# 套模板class Solution(object): def findMin(self, nums): start, end = 0, len(nums)-1 while start + 1 &lt; end: mid = start + (end - start) / 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return min(nums[start], nums[end]) 33. Search in Rotated Sorted Array 1 把Array先根据nums[end]分成在前段还是后段 2 再根据nums[mid]的大小 12345678910111213141516171819class Solution(object): def search(self, nums, target): start, end = 0, len(nums)-1 while start &lt;= end: mid = start + (end - start) / 2 if nums[mid] == target: return mid # 前还是后，根据 num[end] 根据nums[start]也行 if nums[mid] &lt;= nums[end]: if nums[mid] &lt; target &lt;= nums[end]: start = mid + 1 else: end = mid - 1 else: if nums[start] &lt;= target &lt; nums[mid]: end = mid - 1 else: start = mid + 1 return -1 81. Search in Rotated Sorted Array II nums may contain duplicates nums[mid] == nums[start] 或者 nums[mid] == nums[end]的时候无法判断nums[mid]是在前段还是后段！ start += 1 缩减范围, Worst Case : O(n) 123456789101112131415161718192021class Solution(object): def search(self, nums, target): start, end = 0, len(nums)-1 while start &lt;= end: mid = (start + end) / 2 if nums[mid] == target: return True if nums[mid] &lt; nums[start]: if nums[mid] &lt; target &lt;= nums[end]: start = mid + 1 else: end = mid - 1 elif nums[mid] &gt; nums[start]: if nums[start] &lt;= target &lt; nums[mid]: end = mid - 1 else: start = mid + 1 else: start += 1 return False 数值二分型 典型的二分法: 输入是数组，双指针分别是数组的index Input不再是Array，不再以index，而是以value来做二分 374. Guess Number Higher or Lower12345678910111213class Solution(object): def guessNumber(self, n): start, end = 1, n while start &lt; end: mid = start + (end - start) // 2 ret = guess(mid) if ret == 0: return mid elif ret &lt; 0: end = mid - 1 else: start = mid + 1 return start 367. Valid Perfect Square ret = mid * mid 来判断范围 12345678910111213class Solution(object): def isPerfectSquare(self, num): start, end = 1, num while start &lt;= end: mid = start + (end - start) / 2 ret = mid * mid if ret &gt; num: end = mid - 1 elif ret &lt; num: start = mid + 1 else: return True return False 69. Sqrt(x) 在0～x中找最大的数r，满足r * r &lt; = x Why start + 1 &lt; end ? 剩余的搜索范围都是满足搜索条件的！ 1234567891011121314151617class Solution(object): def mySqrt(self, x): start, end = 0, x while start + 1 &lt; end: mid = start + (end - start) / 2 ret = mid * mid if ret &gt; x: end = mid - 1 elif ret &lt; x: start = mid else: return mid if end * end &lt;= x: return end else: return start","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"binary search","slug":"binary-search","permalink":"http://kaihaoli.github.io/tags/binary-search/"}]},{"title":"Segment Tree","slug":"segment-tree","date":"2018-04-10T18:13:18.000Z","updated":"2018-10-06T15:41:56.421Z","comments":true,"path":"2018/04/10/segment-tree/","link":"","permalink":"http://kaihaoli.github.io/2018/04/10/segment-tree/","excerpt":"","text":"Segment Tree 线段树线段树参考整理自：九章算法线段树教程 1 线段树是什么？Google常考数据结构，国内也经常问这个。 线段树是一种高级数据结构，也是一种树结构，准确的说是二叉树，它能够高效的处理区间修改查询等问题。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 2 线段树的创建因为每次将区间的长度一分为二,所有创造的节点个数，即底层有n个节点，那么倒数第二次约n/2个节点，倒数第三次约n/4个节点，依次类推：123n + 1/2 * n + 1/4 * n + 1/8 * n + ...= (1 + 1/2 + 1/4 + 1/8 + ...) * n= 2n 所以构造线段树的时间复杂度和空间复杂度都为O(n) LintCode 201. Segment Tree Build线段树的创建，其实就是按照区间的index进行二分,然后Recursion的定义！ 12345678910111213141516\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end): self.start, self.end = start, end self.left, self.right = None, None\"\"\"class Solution: def build(self, start, end): if start &gt; end: return root = SegmentTreeNode(start, end) if start == end: return root mid = (start + end ) / 2 root.left = self.build(start, mid) root.right = self.build(mid + 1, end) return root LintCode 439. Segment Tree Build II每个节点node除了有区间index的信息外，还包括其他信息，比如区间内的最大值。Node(start, end, val) 12345678910111213141516171819202122232425\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end, max): self.start, self.end, self.max = start, end, max self.left, self.right = None, None\"\"\"class Solution: def build(self, A): if not A: return return self.buildTree(0, len(A)-1, A) def buildTree(self, start, end, A): if start &gt; end: return root = SegmentTreeNode(start, end, A[start]) if start == end: return root mid = (start + end) / 2 root.left = self.buildTree(start, mid, A) root.right = self.buildTree(mid+1, end, A) # Post Order update Max if root.left and root.left.max &gt; root.max: root.max = root.left.max if root.right and root.right.max &gt; root.max: root.max = root.right.max return root 如果需要区间的最小值:1root.min = Math.min(root.left.min, root.right.min); 如果需要区间的和:1root.sum = root.left.sum + root.right.sum; 3 线段树的更新更新是从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为log(n),所以更新序列中一个节点的复杂度为log(n)。 LintCode 203. Segment Tree Modify给一个Maximum Segment Tree, 更新某个index的value。1234567891011121314class Solution: def modify(self, root, index, value): if not root: return if root.start == root.end: root.val = value root.max = value return mid = (root.start + root.end) / 2 if index &lt;= mid: self.modify(root.left, index, value) else: self.modify(root.right, index, value) if root.right and root.left: root.max = max(root.right.max, root.left.max) 4 线段树的查询构造线段树的目的就是为了更快的查询。 给定一个区间，要求区间中最大的值。线段树的区间查询操作就是将当前区间分解为较小的子区间,然后由子区间的最大值就可以快速得到需要查询区间的最大值。 任意长度的线段，最多被拆分成logn条线段树上存在的线段，所以查询的时间复杂度为O(log(n)) LintCode 202. Segment Tree Query12345678910111213class Solution:def query(self, root, start, end): if not root: return if root.start == start and root.end == end: return root.max mid = (root.start + root.end) / 2 if start &gt; mid: return self.query(root.right, start, end) elif end &lt;= mid: return self.query(root.left, start, end) else: return max(self.query(root.left, start, mid), self.query(root.right, mid+1, end)) 5 线段树的应用线段树的基本应用 支持动态更改数组一个元素的值 O(logn) 求区间的和、最大值、最小值 O(logn) 创建，更新，求和或者求最大最小，只有这三个function！ 307. Range Sum Query - Mutable区间求和，如果原序列不变的话直接用preSum前缀和就可以了，但是如果序列可变的话update前缀和的复杂度就变成O(n) LintCode 249. Count of Smaller Number before itsel统计数组中每个元素后面比自己小的数。 初始化[0, max(nums)]的数组全部都是0 把数组中的数值当作index，统计数量就转化成了求区间和 其他解法：Binary Indexed Tree，Binary Search Tree 315. Count of Smaller Numbers After Self 值为负数或者最大值特别大的时候用Segment Tree，val无法作为index，导致 非常不合适！ 所以这个题得考虑别的解决方案","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://kaihaoli.github.io/tags/tree/"}]}]}