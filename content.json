{"meta":{"title":"kaihao","subtitle":"屠龙的少年仍在燃烧","description":null,"author":"Kaihao Li","url":"http://kaihaoli.github.io"},"pages":[{"title":"categories","date":"2018-04-10T20:18:48.000Z","updated":"2018-04-10T20:19:56.378Z","comments":true,"path":"categories/index.html","permalink":"http://kaihaoli.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-10T20:22:05.000Z","updated":"2018-04-10T20:22:32.914Z","comments":true,"path":"tags/index.html","permalink":"http://kaihaoli.github.io/tags/index.html","excerpt":"","text":""},{"title":"Kaihao Li","date":"2018-04-10T21:03:53.000Z","updated":"2018-04-11T02:13:48.024Z","comments":true,"path":"about/index.html","permalink":"http://kaihaoli.github.io/about/index.html","excerpt":"","text":"Email: kaihaohust#gmail.com (replace # with @ please) Tel: (+1)631-428-7454 OBJECTIVE Seeking 2018 Summer Software Engineer Internship EDUCATION 2017.01 ~ 2018.12: M.S. in Computer Science, Stony Brook University 2011.09 ~ 2015.06: B.S. in Computer Science Engineering, Huazhong University of Science and Technology SKILLS Programming Languages: Python, Java, C. Go, Scala Full Stack:React, Express, Node.js ~~Tools: Tensorflow, ~~"}],"posts":[{"title":"Binary Search 二分查找","slug":"binary-search","date":"2018-04-16T03:31:10.000Z","updated":"2018-04-16T03:39:04.806Z","comments":true,"path":"2018/04/15/binary-search/","link":"","permalink":"http://kaihaoli.github.io/2018/04/15/binary-search/","excerpt":"","text":"#Binary Search 二分查找 经典二分查找LintCode 457. \bClassical Binary Search1 基础应用 输入是单调递增或者单调递减的数组(sorted array) 278. First Bad Version35. Search Insert Position34. Search for a Range74. Search a 2D Matrix2 旋转数组系列 Input的数组不再是单调递增或者单调递减 162. Find Peak Element153. Find Minimum in Rotated Sorted Array154. Find Minimum in Rotated Sorted Array II33. Search in Rotated Sorted Array81. Search in Rotated Sorted Array II3 倍增法 Input不再是数组 367. Valid Perfect Square69. Sqrt(x)29. Divide Two Integers综合拔高4. Median of Two Sorted Arrays658. Find K Closest Elements","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://kaihaoli.github.io/tags/Binary-Search/"}]},{"title":"Segment Tree 线段树","slug":"Segment-Tree","date":"2018-04-10T18:13:18.000Z","updated":"2018-04-10T21:36:39.075Z","comments":true,"path":"2018/04/10/Segment-Tree/","link":"","permalink":"http://kaihaoli.github.io/2018/04/10/Segment-Tree/","excerpt":"","text":"Segment Tree 线段树线段树参考整理自：九章算法线段树教程 1 线段树是什么？Google常考数据结构，国内也经常问这个。 线段树是一种高级数据结构，也是一种树结构，准确的说是二叉树，它能够高效的处理区间修改查询等问题。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 2 线段树的创建因为每次将区间的长度一分为二,所有创造的节点个数，即底层有n个节点，那么倒数第二次约n/2个节点，倒数第三次约n/4个节点，依次类推：123n + 1/2 * n + 1/4 * n + 1/8 * n + ...= (1 + 1/2 + 1/4 + 1/8 + ...) * n= 2n 所以构造线段树的时间复杂度和空间复杂度都为O(n) LintCode 201. Segment Tree Build线段树的创建，其实就是按照区间的index进行二分,然后Recursion的定义！ 12345678910111213141516\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end): self.start, self.end = start, end self.left, self.right = None, None\"\"\"class Solution: def build(self, start, end): if start &gt; end: return root = SegmentTreeNode(start, end) if start == end: return root mid = (start + end ) / 2 root.left = self.build(start, mid) root.right = self.build(mid + 1, end) return root LintCode 439. Segment Tree Build II每个节点node除了有区间index的信息外，还包括其他信息，比如区间内的最大值。Node(start, end, val) 12345678910111213141516171819202122232425\"\"\"Definition of SegmentTreeNode:class SegmentTreeNode:def __init__(self, start, end, max): self.start, self.end, self.max = start, end, max self.left, self.right = None, None\"\"\"class Solution: def build(self, A): if not A: return return self.buildTree(0, len(A)-1, A) def buildTree(self, start, end, A): if start &gt; end: return root = SegmentTreeNode(start, end, A[start]) if start == end: return root mid = (start + end) / 2 root.left = self.buildTree(start, mid, A) root.right = self.buildTree(mid+1, end, A) # Post Order update Max if root.left and root.left.max &gt; root.max: root.max = root.left.max if root.right and root.right.max &gt; root.max: root.max = root.right.max return root 如果需要区间的最小值:1root.min = Math.min(root.left.min, root.right.min); 如果需要区间的和:1root.sum = root.left.sum + root.right.sum; 3 线段树的更新更新是从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为log(n),所以更新序列中一个节点的复杂度为log(n)。 LintCode 203. Segment Tree Modify给一个Maximum Segment Tree, 更新某个index的value。1234567891011121314class Solution: def modify(self, root, index, value): if not root: return if root.start == root.end: root.val = value root.max = value return mid = (root.start + root.end) / 2 if index &lt;= mid: self.modify(root.left, index, value) else: self.modify(root.right, index, value) if root.right and root.left: root.max = max(root.right.max, root.left.max) 4 线段树的查询构造线段树的目的就是为了更快的查询。 给定一个区间，要求区间中最大的值。线段树的区间查询操作就是将当前区间分解为较小的子区间,然后由子区间的最大值就可以快速得到需要查询区间的最大值。 任意长度的线段，最多被拆分成logn条线段树上存在的线段，所以查询的时间复杂度为O(log(n)) LintCode 202. Segment Tree Query12345678910111213class Solution:def query(self, root, start, end): if not root: return if root.start == start and root.end == end: return root.max mid = (root.start + root.end) / 2 if start &gt; mid: return self.query(root.right, start, end) elif end &lt;= mid: return self.query(root.left, start, end) else: return max(self.query(root.left, start, mid), self.query(root.right, mid+1, end)) 5 线段树的应用线段树的基本应用 支持动态更改数组一个元素的值 O(logn) 求区间的和、最大值、最小值 O(logn) 创建，更新，求和或者求最大最小，只有这三个function！ 307. Range Sum Query - Mutable区间求和，如果原序列不变的话直接用preSum前缀和就可以了，但是如果序列可变的话update前缀和的复杂度就变成O(n) LintCode 249. Count of Smaller Number before itsel统计数组中每个元素后面比自己小的数。 初始化[0, max(nums)]的数组全部都是0 把数组中的数值当作index，统计数量就转化成了求区间和 其他解法：Binary Indexed Tree，Binary Search Tree 315. Count of Smaller Numbers After Self 值为负数或者最大值特别大的时候用Segment Tree，val无法作为index，导致 非常不合适！ 所以这个题得考虑别的解决方案","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://kaihaoli.github.io/categories/Algorithms/"}],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://kaihaoli.github.io/tags/segment-tree/"},{"name":"binary indexed tree","slug":"binary-indexed-tree","permalink":"http://kaihaoli.github.io/tags/binary-indexed-tree/"}]}]}